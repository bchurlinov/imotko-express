
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model AgencyClientNotes
 * 
 */
export type AgencyClientNotes = $Result.DefaultSelection<Prisma.$AgencyClientNotesPayload>
/**
 * Model AgencyClient
 * 
 */
export type AgencyClient = $Result.DefaultSelection<Prisma.$AgencyClientPayload>
/**
 * Model AgencyClientPreference
 * 
 */
export type AgencyClientPreference = $Result.DefaultSelection<Prisma.$AgencyClientPreferencePayload>
/**
 * Model AgencyMember
 * 
 */
export type AgencyMember = $Result.DefaultSelection<Prisma.$AgencyMemberPayload>
/**
 * Model AgencyInvitation
 * 
 */
export type AgencyInvitation = $Result.DefaultSelection<Prisma.$AgencyInvitationPayload>
/**
 * Model AgencySubmissionReview
 * 
 */
export type AgencySubmissionReview = $Result.DefaultSelection<Prisma.$AgencySubmissionReviewPayload>
/**
 * Model AgencyView
 * 
 */
export type AgencyView = $Result.DefaultSelection<Prisma.$AgencyViewPayload>
/**
 * Model AgencyReview
 * 
 */
export type AgencyReview = $Result.DefaultSelection<Prisma.$AgencyReviewPayload>
/**
 * Model AgentReminder
 * 
 */
export type AgentReminder = $Result.DefaultSelection<Prisma.$AgentReminderPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientSearch
 * 
 */
export type ClientSearch = $Result.DefaultSelection<Prisma.$ClientSearchPayload>
/**
 * Model ClientPropertySubscription
 * 
 */
export type ClientPropertySubscription = $Result.DefaultSelection<Prisma.$ClientPropertySubscriptionPayload>
/**
 * Model SearchQuery
 * 
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model ExternalListing
 * 
 */
export type ExternalListing = $Result.DefaultSelection<Prisma.$ExternalListingPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model PropertyCategory
 * 
 */
export type PropertyCategory = $Result.DefaultSelection<Prisma.$PropertyCategoryPayload>
/**
 * Model PropertySubcategory
 * 
 */
export type PropertySubcategory = $Result.DefaultSelection<Prisma.$PropertySubcategoryPayload>
/**
 * Model PropertyLocation
 * 
 */
export type PropertyLocation = $Result.DefaultSelection<Prisma.$PropertyLocationPayload>
/**
 * Model PropertySubmissionReview
 * 
 */
export type PropertySubmissionReview = $Result.DefaultSelection<Prisma.$PropertySubmissionReviewPayload>
/**
 * Model PropertySale
 * 
 */
export type PropertySale = $Result.DefaultSelection<Prisma.$PropertySalePayload>
/**
 * Model PropertyView
 * 
 */
export type PropertyView = $Result.DefaultSelection<Prisma.$PropertyViewPayload>
/**
 * Model PropertyFavorite
 * 
 */
export type PropertyFavorite = $Result.DefaultSelection<Prisma.$PropertyFavoritePayload>
/**
 * Model PropertyEngagement
 * 
 */
export type PropertyEngagement = $Result.DefaultSelection<Prisma.$PropertyEngagementPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>
/**
 * Model ProposalOffer
 * 
 */
export type ProposalOffer = $Result.DefaultSelection<Prisma.$ProposalOfferPayload>
/**
 * Model ProposalCollaboration
 * 
 */
export type ProposalCollaboration = $Result.DefaultSelection<Prisma.$ProposalCollaborationPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserFeatureRequest
 * 
 */
export type UserFeatureRequest = $Result.DefaultSelection<Prisma.$UserFeatureRequestPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AgencyPlan: {
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM'
};

export type AgencyPlan = (typeof AgencyPlan)[keyof typeof AgencyPlan]


export const AgencyApprovalStatus: {
  DECLINED: 'DECLINED',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  DELETED: 'DELETED'
};

export type AgencyApprovalStatus = (typeof AgencyApprovalStatus)[keyof typeof AgencyApprovalStatus]


export const AgencyInvitationStatus: {
  pending: 'pending',
  accepted: 'accepted',
  declined: 'declined',
  expired: 'expired'
};

export type AgencyInvitationStatus = (typeof AgencyInvitationStatus)[keyof typeof AgencyInvitationStatus]


export const AgencyRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  AGENT: 'AGENT',
  MEMBER: 'MEMBER'
};

export type AgencyRole = (typeof AgencyRole)[keyof typeof AgencyRole]


export const AgencyClientStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type AgencyClientStatus = (typeof AgencyClientStatus)[keyof typeof AgencyClientStatus]


export const AgencyClientPreferenceStatus: {
  active: 'active',
  sent: 'sent',
  interested: 'interested',
  not_interested: 'not_interested',
  inactive: 'inactive',
  expired: 'expired'
};

export type AgencyClientPreferenceStatus = (typeof AgencyClientPreferenceStatus)[keyof typeof AgencyClientPreferenceStatus]


export const AgencyMemberStatus: {
  active: 'active',
  suspended: 'suspended',
  inactive: 'inactive',
  deleted: 'deleted'
};

export type AgencyMemberStatus = (typeof AgencyMemberStatus)[keyof typeof AgencyMemberStatus]


export const AgencyMemberRole: {
  viewer: 'viewer',
  collaborator: 'collaborator',
  agent: 'agent',
  manager: 'manager',
  admin: 'admin'
};

export type AgencyMemberRole = (typeof AgencyMemberRole)[keyof typeof AgencyMemberRole]


export const ReminderStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type ReminderStatus = (typeof ReminderStatus)[keyof typeof ReminderStatus]


export const ExternalListingCategory: {
  FOR_SALE: 'FOR_SALE',
  FOR_RENT: 'FOR_RENT',
  TO_BUY: 'TO_BUY',
  TO_RENT: 'TO_RENT'
};

export type ExternalListingCategory = (typeof ExternalListingCategory)[keyof typeof ExternalListingCategory]


export const PropertyType: {
  flat: 'flat',
  house: 'house',
  land: 'land',
  holiday_home: 'holiday_home',
  garage: 'garage',
  commercial: 'commercial'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const PropertyListingType: {
  for_rent: 'for_rent',
  for_sale: 'for_sale'
};

export type PropertyListingType = (typeof PropertyListingType)[keyof typeof PropertyListingType]


export const PropertyOrientation: {
  north: 'north',
  south: 'south',
  east: 'east',
  west: 'west',
  northeast: 'northeast',
  southeast: 'southeast',
  northwest: 'northwest',
  southwest: 'southwest'
};

export type PropertyOrientation = (typeof PropertyOrientation)[keyof typeof PropertyOrientation]


export const PropertyReviewStatus: {
  PENDING: 'PENDING',
  DECLINED: 'DECLINED',
  APPROVED: 'APPROVED'
};

export type PropertyReviewStatus = (typeof PropertyReviewStatus)[keyof typeof PropertyReviewStatus]


export const PropertyStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  DECLINED: 'DECLINED',
  PUBLISHED: 'PUBLISHED',
  UNPUBLISHED: 'UNPUBLISHED',
  DELETED: 'DELETED'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const EngagementType: {
  SHARE: 'SHARE',
  SUBSCRIBE: 'SUBSCRIBE',
  FAVORITE: 'FAVORITE'
};

export type EngagementType = (typeof EngagementType)[keyof typeof EngagementType]


export const ProposalStatus: {
  published: 'published',
  unpublished: 'unpublished',
  deleted: 'deleted'
};

export type ProposalStatus = (typeof ProposalStatus)[keyof typeof ProposalStatus]


export const UserRole: {
  CLIENT: 'CLIENT',
  AGENCY: 'AGENCY',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserLanguage: {
  EN: 'EN',
  MK: 'MK',
  AL: 'AL',
  SQ: 'SQ'
};

export type UserLanguage = (typeof UserLanguage)[keyof typeof UserLanguage]


export const NotificationStatus: {
  READ: 'READ',
  UNREAD: 'UNREAD'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]

}

export type AgencyPlan = $Enums.AgencyPlan

export const AgencyPlan: typeof $Enums.AgencyPlan

export type AgencyApprovalStatus = $Enums.AgencyApprovalStatus

export const AgencyApprovalStatus: typeof $Enums.AgencyApprovalStatus

export type AgencyInvitationStatus = $Enums.AgencyInvitationStatus

export const AgencyInvitationStatus: typeof $Enums.AgencyInvitationStatus

export type AgencyRole = $Enums.AgencyRole

export const AgencyRole: typeof $Enums.AgencyRole

export type AgencyClientStatus = $Enums.AgencyClientStatus

export const AgencyClientStatus: typeof $Enums.AgencyClientStatus

export type AgencyClientPreferenceStatus = $Enums.AgencyClientPreferenceStatus

export const AgencyClientPreferenceStatus: typeof $Enums.AgencyClientPreferenceStatus

export type AgencyMemberStatus = $Enums.AgencyMemberStatus

export const AgencyMemberStatus: typeof $Enums.AgencyMemberStatus

export type AgencyMemberRole = $Enums.AgencyMemberRole

export const AgencyMemberRole: typeof $Enums.AgencyMemberRole

export type ReminderStatus = $Enums.ReminderStatus

export const ReminderStatus: typeof $Enums.ReminderStatus

export type ExternalListingCategory = $Enums.ExternalListingCategory

export const ExternalListingCategory: typeof $Enums.ExternalListingCategory

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type PropertyListingType = $Enums.PropertyListingType

export const PropertyListingType: typeof $Enums.PropertyListingType

export type PropertyOrientation = $Enums.PropertyOrientation

export const PropertyOrientation: typeof $Enums.PropertyOrientation

export type PropertyReviewStatus = $Enums.PropertyReviewStatus

export const PropertyReviewStatus: typeof $Enums.PropertyReviewStatus

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type EngagementType = $Enums.EngagementType

export const EngagementType: typeof $Enums.EngagementType

export type ProposalStatus = $Enums.ProposalStatus

export const ProposalStatus: typeof $Enums.ProposalStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserLanguage = $Enums.UserLanguage

export const UserLanguage: typeof $Enums.UserLanguage

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Agencies
 * const agencies = await prisma.agency.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Agencies
   * const agencies = await prisma.agency.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyClientNotes`: Exposes CRUD operations for the **AgencyClientNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyClientNotes
    * const agencyClientNotes = await prisma.agencyClientNotes.findMany()
    * ```
    */
  get agencyClientNotes(): Prisma.AgencyClientNotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyClient`: Exposes CRUD operations for the **AgencyClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyClients
    * const agencyClients = await prisma.agencyClient.findMany()
    * ```
    */
  get agencyClient(): Prisma.AgencyClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyClientPreference`: Exposes CRUD operations for the **AgencyClientPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyClientPreferences
    * const agencyClientPreferences = await prisma.agencyClientPreference.findMany()
    * ```
    */
  get agencyClientPreference(): Prisma.AgencyClientPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyMember`: Exposes CRUD operations for the **AgencyMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyMembers
    * const agencyMembers = await prisma.agencyMember.findMany()
    * ```
    */
  get agencyMember(): Prisma.AgencyMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyInvitation`: Exposes CRUD operations for the **AgencyInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyInvitations
    * const agencyInvitations = await prisma.agencyInvitation.findMany()
    * ```
    */
  get agencyInvitation(): Prisma.AgencyInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencySubmissionReview`: Exposes CRUD operations for the **AgencySubmissionReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencySubmissionReviews
    * const agencySubmissionReviews = await prisma.agencySubmissionReview.findMany()
    * ```
    */
  get agencySubmissionReview(): Prisma.AgencySubmissionReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyView`: Exposes CRUD operations for the **AgencyView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyViews
    * const agencyViews = await prisma.agencyView.findMany()
    * ```
    */
  get agencyView(): Prisma.AgencyViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyReview`: Exposes CRUD operations for the **AgencyReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyReviews
    * const agencyReviews = await prisma.agencyReview.findMany()
    * ```
    */
  get agencyReview(): Prisma.AgencyReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentReminder`: Exposes CRUD operations for the **AgentReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentReminders
    * const agentReminders = await prisma.agentReminder.findMany()
    * ```
    */
  get agentReminder(): Prisma.AgentReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientSearch`: Exposes CRUD operations for the **ClientSearch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientSearches
    * const clientSearches = await prisma.clientSearch.findMany()
    * ```
    */
  get clientSearch(): Prisma.ClientSearchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientPropertySubscription`: Exposes CRUD operations for the **ClientPropertySubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPropertySubscriptions
    * const clientPropertySubscriptions = await prisma.clientPropertySubscription.findMany()
    * ```
    */
  get clientPropertySubscription(): Prisma.ClientPropertySubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalListing`: Exposes CRUD operations for the **ExternalListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalListings
    * const externalListings = await prisma.externalListing.findMany()
    * ```
    */
  get externalListing(): Prisma.ExternalListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyCategory`: Exposes CRUD operations for the **PropertyCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyCategories
    * const propertyCategories = await prisma.propertyCategory.findMany()
    * ```
    */
  get propertyCategory(): Prisma.PropertyCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySubcategory`: Exposes CRUD operations for the **PropertySubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySubcategories
    * const propertySubcategories = await prisma.propertySubcategory.findMany()
    * ```
    */
  get propertySubcategory(): Prisma.PropertySubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyLocation`: Exposes CRUD operations for the **PropertyLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyLocations
    * const propertyLocations = await prisma.propertyLocation.findMany()
    * ```
    */
  get propertyLocation(): Prisma.PropertyLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySubmissionReview`: Exposes CRUD operations for the **PropertySubmissionReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySubmissionReviews
    * const propertySubmissionReviews = await prisma.propertySubmissionReview.findMany()
    * ```
    */
  get propertySubmissionReview(): Prisma.PropertySubmissionReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySale`: Exposes CRUD operations for the **PropertySale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySales
    * const propertySales = await prisma.propertySale.findMany()
    * ```
    */
  get propertySale(): Prisma.PropertySaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyView`: Exposes CRUD operations for the **PropertyView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyViews
    * const propertyViews = await prisma.propertyView.findMany()
    * ```
    */
  get propertyView(): Prisma.PropertyViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyFavorite`: Exposes CRUD operations for the **PropertyFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyFavorites
    * const propertyFavorites = await prisma.propertyFavorite.findMany()
    * ```
    */
  get propertyFavorite(): Prisma.PropertyFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyEngagement`: Exposes CRUD operations for the **PropertyEngagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyEngagements
    * const propertyEngagements = await prisma.propertyEngagement.findMany()
    * ```
    */
  get propertyEngagement(): Prisma.PropertyEngagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposalOffer`: Exposes CRUD operations for the **ProposalOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalOffers
    * const proposalOffers = await prisma.proposalOffer.findMany()
    * ```
    */
  get proposalOffer(): Prisma.ProposalOfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposalCollaboration`: Exposes CRUD operations for the **ProposalCollaboration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalCollaborations
    * const proposalCollaborations = await prisma.proposalCollaboration.findMany()
    * ```
    */
  get proposalCollaboration(): Prisma.ProposalCollaborationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFeatureRequest`: Exposes CRUD operations for the **UserFeatureRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeatureRequests
    * const userFeatureRequests = await prisma.userFeatureRequest.findMany()
    * ```
    */
  get userFeatureRequest(): Prisma.UserFeatureRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Agency: 'Agency',
    AgencyClientNotes: 'AgencyClientNotes',
    AgencyClient: 'AgencyClient',
    AgencyClientPreference: 'AgencyClientPreference',
    AgencyMember: 'AgencyMember',
    AgencyInvitation: 'AgencyInvitation',
    AgencySubmissionReview: 'AgencySubmissionReview',
    AgencyView: 'AgencyView',
    AgencyReview: 'AgencyReview',
    AgentReminder: 'AgentReminder',
    Client: 'Client',
    ClientSearch: 'ClientSearch',
    ClientPropertySubscription: 'ClientPropertySubscription',
    SearchQuery: 'SearchQuery',
    ExternalListing: 'ExternalListing',
    Property: 'Property',
    PropertyCategory: 'PropertyCategory',
    PropertySubcategory: 'PropertySubcategory',
    PropertyLocation: 'PropertyLocation',
    PropertySubmissionReview: 'PropertySubmissionReview',
    PropertySale: 'PropertySale',
    PropertyView: 'PropertyView',
    PropertyFavorite: 'PropertyFavorite',
    PropertyEngagement: 'PropertyEngagement',
    Proposal: 'Proposal',
    ProposalOffer: 'ProposalOffer',
    ProposalCollaboration: 'ProposalCollaboration',
    Admin: 'Admin',
    User: 'User',
    Account: 'Account',
    Notification: 'Notification',
    UserFeatureRequest: 'UserFeatureRequest',
    PasswordResetToken: 'PasswordResetToken',
    VerificationToken: 'VerificationToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "agency" | "agencyClientNotes" | "agencyClient" | "agencyClientPreference" | "agencyMember" | "agencyInvitation" | "agencySubmissionReview" | "agencyView" | "agencyReview" | "agentReminder" | "client" | "clientSearch" | "clientPropertySubscription" | "searchQuery" | "externalListing" | "property" | "propertyCategory" | "propertySubcategory" | "propertyLocation" | "propertySubmissionReview" | "propertySale" | "propertyView" | "propertyFavorite" | "propertyEngagement" | "proposal" | "proposalOffer" | "proposalCollaboration" | "admin" | "user" | "account" | "notification" | "userFeatureRequest" | "passwordResetToken" | "verificationToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      AgencyClientNotes: {
        payload: Prisma.$AgencyClientNotesPayload<ExtArgs>
        fields: Prisma.AgencyClientNotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyClientNotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyClientNotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          findFirst: {
            args: Prisma.AgencyClientNotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyClientNotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          findMany: {
            args: Prisma.AgencyClientNotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>[]
          }
          create: {
            args: Prisma.AgencyClientNotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          createMany: {
            args: Prisma.AgencyClientNotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyClientNotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>[]
          }
          delete: {
            args: Prisma.AgencyClientNotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          update: {
            args: Prisma.AgencyClientNotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          deleteMany: {
            args: Prisma.AgencyClientNotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyClientNotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyClientNotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>[]
          }
          upsert: {
            args: Prisma.AgencyClientNotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientNotesPayload>
          }
          aggregate: {
            args: Prisma.AgencyClientNotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyClientNotes>
          }
          groupBy: {
            args: Prisma.AgencyClientNotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientNotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyClientNotesCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientNotesCountAggregateOutputType> | number
          }
        }
      }
      AgencyClient: {
        payload: Prisma.$AgencyClientPayload<ExtArgs>
        fields: Prisma.AgencyClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          findFirst: {
            args: Prisma.AgencyClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          findMany: {
            args: Prisma.AgencyClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>[]
          }
          create: {
            args: Prisma.AgencyClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          createMany: {
            args: Prisma.AgencyClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>[]
          }
          delete: {
            args: Prisma.AgencyClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          update: {
            args: Prisma.AgencyClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          deleteMany: {
            args: Prisma.AgencyClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>[]
          }
          upsert: {
            args: Prisma.AgencyClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPayload>
          }
          aggregate: {
            args: Prisma.AgencyClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyClient>
          }
          groupBy: {
            args: Prisma.AgencyClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyClientCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientCountAggregateOutputType> | number
          }
        }
      }
      AgencyClientPreference: {
        payload: Prisma.$AgencyClientPreferencePayload<ExtArgs>
        fields: Prisma.AgencyClientPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyClientPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyClientPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          findFirst: {
            args: Prisma.AgencyClientPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyClientPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          findMany: {
            args: Prisma.AgencyClientPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>[]
          }
          create: {
            args: Prisma.AgencyClientPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          createMany: {
            args: Prisma.AgencyClientPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyClientPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>[]
          }
          delete: {
            args: Prisma.AgencyClientPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          update: {
            args: Prisma.AgencyClientPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          deleteMany: {
            args: Prisma.AgencyClientPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyClientPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyClientPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>[]
          }
          upsert: {
            args: Prisma.AgencyClientPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyClientPreferencePayload>
          }
          aggregate: {
            args: Prisma.AgencyClientPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyClientPreference>
          }
          groupBy: {
            args: Prisma.AgencyClientPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyClientPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyClientPreferenceCountAggregateOutputType> | number
          }
        }
      }
      AgencyMember: {
        payload: Prisma.$AgencyMemberPayload<ExtArgs>
        fields: Prisma.AgencyMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          findFirst: {
            args: Prisma.AgencyMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          findMany: {
            args: Prisma.AgencyMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>[]
          }
          create: {
            args: Prisma.AgencyMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          createMany: {
            args: Prisma.AgencyMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>[]
          }
          delete: {
            args: Prisma.AgencyMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          update: {
            args: Prisma.AgencyMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          deleteMany: {
            args: Prisma.AgencyMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>[]
          }
          upsert: {
            args: Prisma.AgencyMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyMemberPayload>
          }
          aggregate: {
            args: Prisma.AgencyMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyMember>
          }
          groupBy: {
            args: Prisma.AgencyMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyMemberCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyMemberCountAggregateOutputType> | number
          }
        }
      }
      AgencyInvitation: {
        payload: Prisma.$AgencyInvitationPayload<ExtArgs>
        fields: Prisma.AgencyInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          findFirst: {
            args: Prisma.AgencyInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          findMany: {
            args: Prisma.AgencyInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>[]
          }
          create: {
            args: Prisma.AgencyInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          createMany: {
            args: Prisma.AgencyInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>[]
          }
          delete: {
            args: Prisma.AgencyInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          update: {
            args: Prisma.AgencyInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          deleteMany: {
            args: Prisma.AgencyInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>[]
          }
          upsert: {
            args: Prisma.AgencyInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyInvitationPayload>
          }
          aggregate: {
            args: Prisma.AgencyInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyInvitation>
          }
          groupBy: {
            args: Prisma.AgencyInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyInvitationCountAggregateOutputType> | number
          }
        }
      }
      AgencySubmissionReview: {
        payload: Prisma.$AgencySubmissionReviewPayload<ExtArgs>
        fields: Prisma.AgencySubmissionReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencySubmissionReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencySubmissionReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          findFirst: {
            args: Prisma.AgencySubmissionReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencySubmissionReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          findMany: {
            args: Prisma.AgencySubmissionReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>[]
          }
          create: {
            args: Prisma.AgencySubmissionReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          createMany: {
            args: Prisma.AgencySubmissionReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencySubmissionReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>[]
          }
          delete: {
            args: Prisma.AgencySubmissionReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          update: {
            args: Prisma.AgencySubmissionReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          deleteMany: {
            args: Prisma.AgencySubmissionReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencySubmissionReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencySubmissionReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>[]
          }
          upsert: {
            args: Prisma.AgencySubmissionReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySubmissionReviewPayload>
          }
          aggregate: {
            args: Prisma.AgencySubmissionReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencySubmissionReview>
          }
          groupBy: {
            args: Prisma.AgencySubmissionReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencySubmissionReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencySubmissionReviewCountArgs<ExtArgs>
            result: $Utils.Optional<AgencySubmissionReviewCountAggregateOutputType> | number
          }
        }
      }
      AgencyView: {
        payload: Prisma.$AgencyViewPayload<ExtArgs>
        fields: Prisma.AgencyViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          findFirst: {
            args: Prisma.AgencyViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          findMany: {
            args: Prisma.AgencyViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>[]
          }
          create: {
            args: Prisma.AgencyViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          createMany: {
            args: Prisma.AgencyViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>[]
          }
          delete: {
            args: Prisma.AgencyViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          update: {
            args: Prisma.AgencyViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          deleteMany: {
            args: Prisma.AgencyViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>[]
          }
          upsert: {
            args: Prisma.AgencyViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyViewPayload>
          }
          aggregate: {
            args: Prisma.AgencyViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyView>
          }
          groupBy: {
            args: Prisma.AgencyViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyViewCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyViewCountAggregateOutputType> | number
          }
        }
      }
      AgencyReview: {
        payload: Prisma.$AgencyReviewPayload<ExtArgs>
        fields: Prisma.AgencyReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          findFirst: {
            args: Prisma.AgencyReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          findMany: {
            args: Prisma.AgencyReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>[]
          }
          create: {
            args: Prisma.AgencyReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          createMany: {
            args: Prisma.AgencyReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>[]
          }
          delete: {
            args: Prisma.AgencyReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          update: {
            args: Prisma.AgencyReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          deleteMany: {
            args: Prisma.AgencyReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>[]
          }
          upsert: {
            args: Prisma.AgencyReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyReviewPayload>
          }
          aggregate: {
            args: Prisma.AgencyReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyReview>
          }
          groupBy: {
            args: Prisma.AgencyReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyReviewCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyReviewCountAggregateOutputType> | number
          }
        }
      }
      AgentReminder: {
        payload: Prisma.$AgentReminderPayload<ExtArgs>
        fields: Prisma.AgentReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          findFirst: {
            args: Prisma.AgentReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          findMany: {
            args: Prisma.AgentReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>[]
          }
          create: {
            args: Prisma.AgentReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          createMany: {
            args: Prisma.AgentReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>[]
          }
          delete: {
            args: Prisma.AgentReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          update: {
            args: Prisma.AgentReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          deleteMany: {
            args: Prisma.AgentReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>[]
          }
          upsert: {
            args: Prisma.AgentReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentReminderPayload>
          }
          aggregate: {
            args: Prisma.AgentReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentReminder>
          }
          groupBy: {
            args: Prisma.AgentReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentReminderCountArgs<ExtArgs>
            result: $Utils.Optional<AgentReminderCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientSearch: {
        payload: Prisma.$ClientSearchPayload<ExtArgs>
        fields: Prisma.ClientSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          findFirst: {
            args: Prisma.ClientSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          findMany: {
            args: Prisma.ClientSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>[]
          }
          create: {
            args: Prisma.ClientSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          createMany: {
            args: Prisma.ClientSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>[]
          }
          delete: {
            args: Prisma.ClientSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          update: {
            args: Prisma.ClientSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          deleteMany: {
            args: Prisma.ClientSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientSearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>[]
          }
          upsert: {
            args: Prisma.ClientSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSearchPayload>
          }
          aggregate: {
            args: Prisma.ClientSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientSearch>
          }
          groupBy: {
            args: Prisma.ClientSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientSearchCountArgs<ExtArgs>
            result: $Utils.Optional<ClientSearchCountAggregateOutputType> | number
          }
        }
      }
      ClientPropertySubscription: {
        payload: Prisma.$ClientPropertySubscriptionPayload<ExtArgs>
        fields: Prisma.ClientPropertySubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPropertySubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPropertySubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ClientPropertySubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPropertySubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          findMany: {
            args: Prisma.ClientPropertySubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>[]
          }
          create: {
            args: Prisma.ClientPropertySubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          createMany: {
            args: Prisma.ClientPropertySubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientPropertySubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>[]
          }
          delete: {
            args: Prisma.ClientPropertySubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          update: {
            args: Prisma.ClientPropertySubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ClientPropertySubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPropertySubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientPropertySubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.ClientPropertySubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPropertySubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ClientPropertySubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientPropertySubscription>
          }
          groupBy: {
            args: Prisma.ClientPropertySubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientPropertySubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPropertySubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ClientPropertySubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchQueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      ExternalListing: {
        payload: Prisma.$ExternalListingPayload<ExtArgs>
        fields: Prisma.ExternalListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          findFirst: {
            args: Prisma.ExternalListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          findMany: {
            args: Prisma.ExternalListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>[]
          }
          create: {
            args: Prisma.ExternalListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          createMany: {
            args: Prisma.ExternalListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>[]
          }
          delete: {
            args: Prisma.ExternalListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          update: {
            args: Prisma.ExternalListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          deleteMany: {
            args: Prisma.ExternalListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>[]
          }
          upsert: {
            args: Prisma.ExternalListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalListingPayload>
          }
          aggregate: {
            args: Prisma.ExternalListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalListing>
          }
          groupBy: {
            args: Prisma.ExternalListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalListingCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalListingCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      PropertyCategory: {
        payload: Prisma.$PropertyCategoryPayload<ExtArgs>
        fields: Prisma.PropertyCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          findFirst: {
            args: Prisma.PropertyCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          findMany: {
            args: Prisma.PropertyCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          create: {
            args: Prisma.PropertyCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          createMany: {
            args: Prisma.PropertyCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          delete: {
            args: Prisma.PropertyCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          update: {
            args: Prisma.PropertyCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PropertyCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          upsert: {
            args: Prisma.PropertyCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          aggregate: {
            args: Prisma.PropertyCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyCategory>
          }
          groupBy: {
            args: Prisma.PropertyCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryCountAggregateOutputType> | number
          }
        }
      }
      PropertySubcategory: {
        payload: Prisma.$PropertySubcategoryPayload<ExtArgs>
        fields: Prisma.PropertySubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          findFirst: {
            args: Prisma.PropertySubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          findMany: {
            args: Prisma.PropertySubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>[]
          }
          create: {
            args: Prisma.PropertySubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          createMany: {
            args: Prisma.PropertySubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>[]
          }
          delete: {
            args: Prisma.PropertySubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          update: {
            args: Prisma.PropertySubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.PropertySubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.PropertySubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubcategoryPayload>
          }
          aggregate: {
            args: Prisma.PropertySubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySubcategory>
          }
          groupBy: {
            args: Prisma.PropertySubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySubcategoryCountAggregateOutputType> | number
          }
        }
      }
      PropertyLocation: {
        payload: Prisma.$PropertyLocationPayload<ExtArgs>
        fields: Prisma.PropertyLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          findFirst: {
            args: Prisma.PropertyLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          findMany: {
            args: Prisma.PropertyLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>[]
          }
          create: {
            args: Prisma.PropertyLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          createMany: {
            args: Prisma.PropertyLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>[]
          }
          delete: {
            args: Prisma.PropertyLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          update: {
            args: Prisma.PropertyLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          deleteMany: {
            args: Prisma.PropertyLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>[]
          }
          upsert: {
            args: Prisma.PropertyLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyLocationPayload>
          }
          aggregate: {
            args: Prisma.PropertyLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyLocation>
          }
          groupBy: {
            args: Prisma.PropertyLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyLocationCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyLocationCountAggregateOutputType> | number
          }
        }
      }
      PropertySubmissionReview: {
        payload: Prisma.$PropertySubmissionReviewPayload<ExtArgs>
        fields: Prisma.PropertySubmissionReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySubmissionReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySubmissionReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          findFirst: {
            args: Prisma.PropertySubmissionReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySubmissionReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          findMany: {
            args: Prisma.PropertySubmissionReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>[]
          }
          create: {
            args: Prisma.PropertySubmissionReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          createMany: {
            args: Prisma.PropertySubmissionReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySubmissionReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>[]
          }
          delete: {
            args: Prisma.PropertySubmissionReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          update: {
            args: Prisma.PropertySubmissionReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          deleteMany: {
            args: Prisma.PropertySubmissionReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySubmissionReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySubmissionReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>[]
          }
          upsert: {
            args: Prisma.PropertySubmissionReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionReviewPayload>
          }
          aggregate: {
            args: Prisma.PropertySubmissionReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySubmissionReview>
          }
          groupBy: {
            args: Prisma.PropertySubmissionReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySubmissionReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySubmissionReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySubmissionReviewCountAggregateOutputType> | number
          }
        }
      }
      PropertySale: {
        payload: Prisma.$PropertySalePayload<ExtArgs>
        fields: Prisma.PropertySaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          findFirst: {
            args: Prisma.PropertySaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          findMany: {
            args: Prisma.PropertySaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>[]
          }
          create: {
            args: Prisma.PropertySaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          createMany: {
            args: Prisma.PropertySaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>[]
          }
          delete: {
            args: Prisma.PropertySaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          update: {
            args: Prisma.PropertySaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          deleteMany: {
            args: Prisma.PropertySaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>[]
          }
          upsert: {
            args: Prisma.PropertySaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySalePayload>
          }
          aggregate: {
            args: Prisma.PropertySaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySale>
          }
          groupBy: {
            args: Prisma.PropertySaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySaleCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySaleCountAggregateOutputType> | number
          }
        }
      }
      PropertyView: {
        payload: Prisma.$PropertyViewPayload<ExtArgs>
        fields: Prisma.PropertyViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findFirst: {
            args: Prisma.PropertyViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findMany: {
            args: Prisma.PropertyViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          create: {
            args: Prisma.PropertyViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          createMany: {
            args: Prisma.PropertyViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          delete: {
            args: Prisma.PropertyViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          update: {
            args: Prisma.PropertyViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          deleteMany: {
            args: Prisma.PropertyViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          upsert: {
            args: Prisma.PropertyViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          aggregate: {
            args: Prisma.PropertyViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyView>
          }
          groupBy: {
            args: Prisma.PropertyViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyViewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewCountAggregateOutputType> | number
          }
        }
      }
      PropertyFavorite: {
        payload: Prisma.$PropertyFavoritePayload<ExtArgs>
        fields: Prisma.PropertyFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          findFirst: {
            args: Prisma.PropertyFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          findMany: {
            args: Prisma.PropertyFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>[]
          }
          create: {
            args: Prisma.PropertyFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          createMany: {
            args: Prisma.PropertyFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>[]
          }
          delete: {
            args: Prisma.PropertyFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          update: {
            args: Prisma.PropertyFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          deleteMany: {
            args: Prisma.PropertyFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>[]
          }
          upsert: {
            args: Prisma.PropertyFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFavoritePayload>
          }
          aggregate: {
            args: Prisma.PropertyFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyFavorite>
          }
          groupBy: {
            args: Prisma.PropertyFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyFavoriteCountAggregateOutputType> | number
          }
        }
      }
      PropertyEngagement: {
        payload: Prisma.$PropertyEngagementPayload<ExtArgs>
        fields: Prisma.PropertyEngagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyEngagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyEngagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          findFirst: {
            args: Prisma.PropertyEngagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyEngagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          findMany: {
            args: Prisma.PropertyEngagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>[]
          }
          create: {
            args: Prisma.PropertyEngagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          createMany: {
            args: Prisma.PropertyEngagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyEngagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>[]
          }
          delete: {
            args: Prisma.PropertyEngagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          update: {
            args: Prisma.PropertyEngagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          deleteMany: {
            args: Prisma.PropertyEngagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyEngagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyEngagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>[]
          }
          upsert: {
            args: Prisma.PropertyEngagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyEngagementPayload>
          }
          aggregate: {
            args: Prisma.PropertyEngagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyEngagement>
          }
          groupBy: {
            args: Prisma.PropertyEngagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyEngagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyEngagementCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyEngagementCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      ProposalOffer: {
        payload: Prisma.$ProposalOfferPayload<ExtArgs>
        fields: Prisma.ProposalOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          findFirst: {
            args: Prisma.ProposalOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          findMany: {
            args: Prisma.ProposalOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>[]
          }
          create: {
            args: Prisma.ProposalOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          createMany: {
            args: Prisma.ProposalOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>[]
          }
          delete: {
            args: Prisma.ProposalOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          update: {
            args: Prisma.ProposalOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          deleteMany: {
            args: Prisma.ProposalOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>[]
          }
          upsert: {
            args: Prisma.ProposalOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOfferPayload>
          }
          aggregate: {
            args: Prisma.ProposalOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalOffer>
          }
          groupBy: {
            args: Prisma.ProposalOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalOfferCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalOfferCountAggregateOutputType> | number
          }
        }
      }
      ProposalCollaboration: {
        payload: Prisma.$ProposalCollaborationPayload<ExtArgs>
        fields: Prisma.ProposalCollaborationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalCollaborationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalCollaborationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          findFirst: {
            args: Prisma.ProposalCollaborationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalCollaborationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          findMany: {
            args: Prisma.ProposalCollaborationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>[]
          }
          create: {
            args: Prisma.ProposalCollaborationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          createMany: {
            args: Prisma.ProposalCollaborationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCollaborationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>[]
          }
          delete: {
            args: Prisma.ProposalCollaborationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          update: {
            args: Prisma.ProposalCollaborationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          deleteMany: {
            args: Prisma.ProposalCollaborationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalCollaborationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalCollaborationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>[]
          }
          upsert: {
            args: Prisma.ProposalCollaborationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCollaborationPayload>
          }
          aggregate: {
            args: Prisma.ProposalCollaborationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalCollaboration>
          }
          groupBy: {
            args: Prisma.ProposalCollaborationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalCollaborationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCollaborationCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCollaborationCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserFeatureRequest: {
        payload: Prisma.$UserFeatureRequestPayload<ExtArgs>
        fields: Prisma.UserFeatureRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeatureRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeatureRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          findFirst: {
            args: Prisma.UserFeatureRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeatureRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          findMany: {
            args: Prisma.UserFeatureRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>[]
          }
          create: {
            args: Prisma.UserFeatureRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          createMany: {
            args: Prisma.UserFeatureRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeatureRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>[]
          }
          delete: {
            args: Prisma.UserFeatureRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          update: {
            args: Prisma.UserFeatureRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          deleteMany: {
            args: Prisma.UserFeatureRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeatureRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFeatureRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>[]
          }
          upsert: {
            args: Prisma.UserFeatureRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureRequestPayload>
          }
          aggregate: {
            args: Prisma.UserFeatureRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeatureRequest>
          }
          groupBy: {
            args: Prisma.UserFeatureRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeatureRequestCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureRequestCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    agency?: AgencyOmit
    agencyClientNotes?: AgencyClientNotesOmit
    agencyClient?: AgencyClientOmit
    agencyClientPreference?: AgencyClientPreferenceOmit
    agencyMember?: AgencyMemberOmit
    agencyInvitation?: AgencyInvitationOmit
    agencySubmissionReview?: AgencySubmissionReviewOmit
    agencyView?: AgencyViewOmit
    agencyReview?: AgencyReviewOmit
    agentReminder?: AgentReminderOmit
    client?: ClientOmit
    clientSearch?: ClientSearchOmit
    clientPropertySubscription?: ClientPropertySubscriptionOmit
    searchQuery?: SearchQueryOmit
    externalListing?: ExternalListingOmit
    property?: PropertyOmit
    propertyCategory?: PropertyCategoryOmit
    propertySubcategory?: PropertySubcategoryOmit
    propertyLocation?: PropertyLocationOmit
    propertySubmissionReview?: PropertySubmissionReviewOmit
    propertySale?: PropertySaleOmit
    propertyView?: PropertyViewOmit
    propertyFavorite?: PropertyFavoriteOmit
    propertyEngagement?: PropertyEngagementOmit
    proposal?: ProposalOmit
    proposalOffer?: ProposalOfferOmit
    proposalCollaboration?: ProposalCollaborationOmit
    admin?: AdminOmit
    user?: UserOmit
    account?: AccountOmit
    notification?: NotificationOmit
    userFeatureRequest?: UserFeatureRequestOmit
    passwordResetToken?: PasswordResetTokenOmit
    verificationToken?: VerificationTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    users: number
    ratings: number
    properties: number
    propertySale: number
    agencyView: number
    proposalOffer: number
    agencyMembers: number
    agencyInvitation: number
    agencyClient: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AgencyCountOutputTypeCountUsersArgs
    ratings?: boolean | AgencyCountOutputTypeCountRatingsArgs
    properties?: boolean | AgencyCountOutputTypeCountPropertiesArgs
    propertySale?: boolean | AgencyCountOutputTypeCountPropertySaleArgs
    agencyView?: boolean | AgencyCountOutputTypeCountAgencyViewArgs
    proposalOffer?: boolean | AgencyCountOutputTypeCountProposalOfferArgs
    agencyMembers?: boolean | AgencyCountOutputTypeCountAgencyMembersArgs
    agencyInvitation?: boolean | AgencyCountOutputTypeCountAgencyInvitationArgs
    agencyClient?: boolean | AgencyCountOutputTypeCountAgencyClientArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyReviewWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountPropertySaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySaleWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyViewWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountProposalOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalOfferWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyMemberWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyInvitationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAgencyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientWhereInput
  }


  /**
   * Count Type AgencyClientCountOutputType
   */

  export type AgencyClientCountOutputType = {
    memberNotes: number
    preferences: number
    ownedProperties: number
    rentedProperties: number
  }

  export type AgencyClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberNotes?: boolean | AgencyClientCountOutputTypeCountMemberNotesArgs
    preferences?: boolean | AgencyClientCountOutputTypeCountPreferencesArgs
    ownedProperties?: boolean | AgencyClientCountOutputTypeCountOwnedPropertiesArgs
    rentedProperties?: boolean | AgencyClientCountOutputTypeCountRentedPropertiesArgs
  }

  // Custom InputTypes
  /**
   * AgencyClientCountOutputType without action
   */
  export type AgencyClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientCountOutputType
     */
    select?: AgencyClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyClientCountOutputType without action
   */
  export type AgencyClientCountOutputTypeCountMemberNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientNotesWhereInput
  }

  /**
   * AgencyClientCountOutputType without action
   */
  export type AgencyClientCountOutputTypeCountPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientPreferenceWhereInput
  }

  /**
   * AgencyClientCountOutputType without action
   */
  export type AgencyClientCountOutputTypeCountOwnedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * AgencyClientCountOutputType without action
   */
  export type AgencyClientCountOutputTypeCountRentedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type AgencyMemberCountOutputType
   */

  export type AgencyMemberCountOutputType = {
    createdProperties: number
    agencyClientNotes: number
    agencyClient: number
    AgencyClientPreference: number
    reminders: number
  }

  export type AgencyMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdProperties?: boolean | AgencyMemberCountOutputTypeCountCreatedPropertiesArgs
    agencyClientNotes?: boolean | AgencyMemberCountOutputTypeCountAgencyClientNotesArgs
    agencyClient?: boolean | AgencyMemberCountOutputTypeCountAgencyClientArgs
    AgencyClientPreference?: boolean | AgencyMemberCountOutputTypeCountAgencyClientPreferenceArgs
    reminders?: boolean | AgencyMemberCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes
  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMemberCountOutputType
     */
    select?: AgencyMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeCountCreatedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeCountAgencyClientNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientNotesWhereInput
  }

  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeCountAgencyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientWhereInput
  }

  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeCountAgencyClientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientPreferenceWhereInput
  }

  /**
   * AgencyMemberCountOutputType without action
   */
  export type AgencyMemberCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentReminderWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    clientSubscription: number
    favorites: number
    propertyViews: number
    clientSearches: number
    reviews: number
    AgencyView: number
    PropertyEngagement: number
    Proposal: number
    ProposalCollaboration: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientSubscription?: boolean | ClientCountOutputTypeCountClientSubscriptionArgs
    favorites?: boolean | ClientCountOutputTypeCountFavoritesArgs
    propertyViews?: boolean | ClientCountOutputTypeCountPropertyViewsArgs
    clientSearches?: boolean | ClientCountOutputTypeCountClientSearchesArgs
    reviews?: boolean | ClientCountOutputTypeCountReviewsArgs
    AgencyView?: boolean | ClientCountOutputTypeCountAgencyViewArgs
    PropertyEngagement?: boolean | ClientCountOutputTypeCountPropertyEngagementArgs
    Proposal?: boolean | ClientCountOutputTypeCountProposalArgs
    ProposalCollaboration?: boolean | ClientCountOutputTypeCountProposalCollaborationArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPropertySubscriptionWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFavoriteWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPropertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSearchWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyReviewWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAgencyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyViewWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPropertyEngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyEngagementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProposalCollaborationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalCollaborationWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    views: number
    PropertyFavorite: number
    PropertyEngagement: number
    propertyReview: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    views?: boolean | PropertyCountOutputTypeCountViewsArgs
    PropertyFavorite?: boolean | PropertyCountOutputTypeCountPropertyFavoriteArgs
    PropertyEngagement?: boolean | PropertyCountOutputTypeCountPropertyEngagementArgs
    propertyReview?: boolean | PropertyCountOutputTypeCountPropertyReviewArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFavoriteWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyEngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyEngagementWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySubmissionReviewWhereInput
  }


  /**
   * Count Type PropertyCategoryCountOutputType
   */

  export type PropertyCategoryCountOutputType = {
    properties: number
    subcategories: number
  }

  export type PropertyCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategoryCountOutputTypeCountPropertiesArgs
    subcategories?: boolean | PropertyCategoryCountOutputTypeCountSubcategoriesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCategoryCountOutputType without action
   */
  export type PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryCountOutputType
     */
    select?: PropertyCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCategoryCountOutputType without action
   */
  export type PropertyCategoryCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * PropertyCategoryCountOutputType without action
   */
  export type PropertyCategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySubcategoryWhereInput
  }


  /**
   * Count Type PropertySubcategoryCountOutputType
   */

  export type PropertySubcategoryCountOutputType = {
    properties: number
  }

  export type PropertySubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertySubcategoryCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertySubcategoryCountOutputType without action
   */
  export type PropertySubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategoryCountOutputType
     */
    select?: PropertySubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertySubcategoryCountOutputType without action
   */
  export type PropertySubcategoryCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type PropertyLocationCountOutputType
   */

  export type PropertyLocationCountOutputType = {
    children: number
    properties: number
  }

  export type PropertyLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PropertyLocationCountOutputTypeCountChildrenArgs
    properties?: boolean | PropertyLocationCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyLocationCountOutputType without action
   */
  export type PropertyLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocationCountOutputType
     */
    select?: PropertyLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyLocationCountOutputType without action
   */
  export type PropertyLocationCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyLocationWhereInput
  }

  /**
   * PropertyLocationCountOutputType without action
   */
  export type PropertyLocationCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type ProposalCountOutputType
   */

  export type ProposalCountOutputType = {
    offers: number
  }

  export type ProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | ProposalCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCountOutputType
     */
    select?: ProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalOfferWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    UserFeatureRequest: number
    agencyInvitationSender: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    UserFeatureRequest?: boolean | UserCountOutputTypeCountUserFeatureRequestArgs
    agencyInvitationSender?: boolean | UserCountOutputTypeCountAgencyInvitationSenderArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFeatureRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgencyInvitationSenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyInvitationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    credits: number | null
  }

  export type AgencySumAggregateOutputType = {
    credits: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    status: $Enums.AgencyApprovalStatus | null
    imotkoApproved: boolean | null
    plan: $Enums.AgencyPlan | null
    planUntil: Date | null
    email: string | null
    taxNumber: string | null
    name: string | null
    slug: string | null
    address: string | null
    phone: string | null
    location: string | null
    credits: number | null
    owner: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    status: $Enums.AgencyApprovalStatus | null
    imotkoApproved: boolean | null
    plan: $Enums.AgencyPlan | null
    planUntil: Date | null
    email: string | null
    taxNumber: string | null
    name: string | null
    slug: string | null
    address: string | null
    phone: string | null
    location: string | null
    credits: number | null
    owner: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    status: number
    imotkoApproved: number
    plan: number
    planUntil: number
    email: number
    taxNumber: number
    name: number
    description: number
    slug: number
    address: number
    phone: number
    location: number
    social: number
    logo: number
    credits: number
    owner: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    credits?: true
  }

  export type AgencySumAggregateInputType = {
    credits?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    status?: true
    imotkoApproved?: true
    plan?: true
    planUntil?: true
    email?: true
    taxNumber?: true
    name?: true
    slug?: true
    address?: true
    phone?: true
    location?: true
    credits?: true
    owner?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    status?: true
    imotkoApproved?: true
    plan?: true
    planUntil?: true
    email?: true
    taxNumber?: true
    name?: true
    slug?: true
    address?: true
    phone?: true
    location?: true
    credits?: true
    owner?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    status?: true
    imotkoApproved?: true
    plan?: true
    planUntil?: true
    email?: true
    taxNumber?: true
    name?: true
    description?: true
    slug?: true
    address?: true
    phone?: true
    location?: true
    social?: true
    logo?: true
    credits?: true
    owner?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    status: $Enums.AgencyApprovalStatus
    imotkoApproved: boolean
    plan: $Enums.AgencyPlan
    planUntil: Date | null
    email: string | null
    taxNumber: string | null
    name: string
    description: JsonValue | null
    slug: string | null
    address: string
    phone: string | null
    location: string | null
    social: JsonValue | null
    logo: JsonValue | null
    credits: number
    owner: string
    ownerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    imotkoApproved?: boolean
    plan?: boolean
    planUntil?: boolean
    email?: boolean
    taxNumber?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    location?: boolean
    social?: boolean
    logo?: boolean
    credits?: boolean
    owner?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Agency$usersArgs<ExtArgs>
    ratings?: boolean | Agency$ratingsArgs<ExtArgs>
    properties?: boolean | Agency$propertiesArgs<ExtArgs>
    propertySale?: boolean | Agency$propertySaleArgs<ExtArgs>
    agencyView?: boolean | Agency$agencyViewArgs<ExtArgs>
    proposalOffer?: boolean | Agency$proposalOfferArgs<ExtArgs>
    AgencySubmissionReview?: boolean | Agency$AgencySubmissionReviewArgs<ExtArgs>
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
    agencyMembers?: boolean | Agency$agencyMembersArgs<ExtArgs>
    agencyInvitation?: boolean | Agency$agencyInvitationArgs<ExtArgs>
    agencyClient?: boolean | Agency$agencyClientArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    imotkoApproved?: boolean
    plan?: boolean
    planUntil?: boolean
    email?: boolean
    taxNumber?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    location?: boolean
    social?: boolean
    logo?: boolean
    credits?: boolean
    owner?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    imotkoApproved?: boolean
    plan?: boolean
    planUntil?: boolean
    email?: boolean
    taxNumber?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    location?: boolean
    social?: boolean
    logo?: boolean
    credits?: boolean
    owner?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    status?: boolean
    imotkoApproved?: boolean
    plan?: boolean
    planUntil?: boolean
    email?: boolean
    taxNumber?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    location?: boolean
    social?: boolean
    logo?: boolean
    credits?: boolean
    owner?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "imotkoApproved" | "plan" | "planUntil" | "email" | "taxNumber" | "name" | "description" | "slug" | "address" | "phone" | "location" | "social" | "logo" | "credits" | "owner" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Agency$usersArgs<ExtArgs>
    ratings?: boolean | Agency$ratingsArgs<ExtArgs>
    properties?: boolean | Agency$propertiesArgs<ExtArgs>
    propertySale?: boolean | Agency$propertySaleArgs<ExtArgs>
    agencyView?: boolean | Agency$agencyViewArgs<ExtArgs>
    proposalOffer?: boolean | Agency$proposalOfferArgs<ExtArgs>
    AgencySubmissionReview?: boolean | Agency$AgencySubmissionReviewArgs<ExtArgs>
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
    agencyMembers?: boolean | Agency$agencyMembersArgs<ExtArgs>
    agencyInvitation?: boolean | Agency$agencyInvitationArgs<ExtArgs>
    agencyClient?: boolean | Agency$agencyClientArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
  }
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyOwner?: boolean | Agency$agencyOwnerArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      ratings: Prisma.$AgencyReviewPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      propertySale: Prisma.$PropertySalePayload<ExtArgs>[]
      agencyView: Prisma.$AgencyViewPayload<ExtArgs>[]
      proposalOffer: Prisma.$ProposalOfferPayload<ExtArgs>[]
      AgencySubmissionReview: Prisma.$AgencySubmissionReviewPayload<ExtArgs> | null
      agencyOwner: Prisma.$UserPayload<ExtArgs> | null
      agencyMembers: Prisma.$AgencyMemberPayload<ExtArgs>[]
      agencyInvitation: Prisma.$AgencyInvitationPayload<ExtArgs>[]
      agencyClient: Prisma.$AgencyClientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.AgencyApprovalStatus
      imotkoApproved: boolean
      plan: $Enums.AgencyPlan
      planUntil: Date | null
      email: string | null
      taxNumber: string | null
      name: string
      description: Prisma.JsonValue | null
      slug: string | null
      address: string
      phone: string | null
      location: string | null
      social: Prisma.JsonValue | null
      logo: Prisma.JsonValue | null
      credits: number
      owner: string
      ownerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Agency$usersArgs<ExtArgs> = {}>(args?: Subset<T, Agency$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Agency$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends Agency$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Agency$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertySale<T extends Agency$propertySaleArgs<ExtArgs> = {}>(args?: Subset<T, Agency$propertySaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyView<T extends Agency$agencyViewArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposalOffer<T extends Agency$proposalOfferArgs<ExtArgs> = {}>(args?: Subset<T, Agency$proposalOfferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgencySubmissionReview<T extends Agency$AgencySubmissionReviewArgs<ExtArgs> = {}>(args?: Subset<T, Agency$AgencySubmissionReviewArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyOwner<T extends Agency$agencyOwnerArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyOwnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyMembers<T extends Agency$agencyMembersArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyInvitation<T extends Agency$agencyInvitationArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyInvitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyClient<T extends Agency$agencyClientArgs<ExtArgs> = {}>(args?: Subset<T, Agency$agencyClientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly status: FieldRef<"Agency", 'AgencyApprovalStatus'>
    readonly imotkoApproved: FieldRef<"Agency", 'Boolean'>
    readonly plan: FieldRef<"Agency", 'AgencyPlan'>
    readonly planUntil: FieldRef<"Agency", 'DateTime'>
    readonly email: FieldRef<"Agency", 'String'>
    readonly taxNumber: FieldRef<"Agency", 'String'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly description: FieldRef<"Agency", 'Json'>
    readonly slug: FieldRef<"Agency", 'String'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly phone: FieldRef<"Agency", 'String'>
    readonly location: FieldRef<"Agency", 'String'>
    readonly social: FieldRef<"Agency", 'Json'>
    readonly logo: FieldRef<"Agency", 'Json'>
    readonly credits: FieldRef<"Agency", 'Int'>
    readonly owner: FieldRef<"Agency", 'String'>
    readonly ownerId: FieldRef<"Agency", 'String'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.users
   */
  export type Agency$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Agency.ratings
   */
  export type Agency$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    where?: AgencyReviewWhereInput
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    cursor?: AgencyReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyReviewScalarFieldEnum | AgencyReviewScalarFieldEnum[]
  }

  /**
   * Agency.properties
   */
  export type Agency$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Agency.propertySale
   */
  export type Agency$propertySaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    where?: PropertySaleWhereInput
    orderBy?: PropertySaleOrderByWithRelationInput | PropertySaleOrderByWithRelationInput[]
    cursor?: PropertySaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertySaleScalarFieldEnum | PropertySaleScalarFieldEnum[]
  }

  /**
   * Agency.agencyView
   */
  export type Agency$agencyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    where?: AgencyViewWhereInput
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    cursor?: AgencyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyViewScalarFieldEnum | AgencyViewScalarFieldEnum[]
  }

  /**
   * Agency.proposalOffer
   */
  export type Agency$proposalOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    where?: ProposalOfferWhereInput
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    cursor?: ProposalOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalOfferScalarFieldEnum | ProposalOfferScalarFieldEnum[]
  }

  /**
   * Agency.AgencySubmissionReview
   */
  export type Agency$AgencySubmissionReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    where?: AgencySubmissionReviewWhereInput
  }

  /**
   * Agency.agencyOwner
   */
  export type Agency$agencyOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Agency.agencyMembers
   */
  export type Agency$agencyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    where?: AgencyMemberWhereInput
    orderBy?: AgencyMemberOrderByWithRelationInput | AgencyMemberOrderByWithRelationInput[]
    cursor?: AgencyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyMemberScalarFieldEnum | AgencyMemberScalarFieldEnum[]
  }

  /**
   * Agency.agencyInvitation
   */
  export type Agency$agencyInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    where?: AgencyInvitationWhereInput
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    cursor?: AgencyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyInvitationScalarFieldEnum | AgencyInvitationScalarFieldEnum[]
  }

  /**
   * Agency.agencyClient
   */
  export type Agency$agencyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    where?: AgencyClientWhereInput
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    cursor?: AgencyClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientScalarFieldEnum | AgencyClientScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model AgencyClientNotes
   */

  export type AggregateAgencyClientNotes = {
    _count: AgencyClientNotesCountAggregateOutputType | null
    _min: AgencyClientNotesMinAggregateOutputType | null
    _max: AgencyClientNotesMaxAggregateOutputType | null
  }

  export type AgencyClientNotesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    agencyClientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyClientNotesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    agencyClientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyClientNotesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    agencyClientId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyClientNotesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    agencyClientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyClientNotesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    agencyClientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyClientNotesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    agencyClientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyClientNotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClientNotes to aggregate.
     */
    where?: AgencyClientNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientNotes to fetch.
     */
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyClientNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyClientNotes
    **/
    _count?: true | AgencyClientNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyClientNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyClientNotesMaxAggregateInputType
  }

  export type GetAgencyClientNotesAggregateType<T extends AgencyClientNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyClientNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyClientNotes[P]>
      : GetScalarType<T[P], AggregateAgencyClientNotes[P]>
  }




  export type AgencyClientNotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientNotesWhereInput
    orderBy?: AgencyClientNotesOrderByWithAggregationInput | AgencyClientNotesOrderByWithAggregationInput[]
    by: AgencyClientNotesScalarFieldEnum[] | AgencyClientNotesScalarFieldEnum
    having?: AgencyClientNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyClientNotesCountAggregateInputType | true
    _min?: AgencyClientNotesMinAggregateInputType
    _max?: AgencyClientNotesMaxAggregateInputType
  }

  export type AgencyClientNotesGroupByOutputType = {
    id: string
    title: string
    description: string
    agencyClientId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AgencyClientNotesCountAggregateOutputType | null
    _min: AgencyClientNotesMinAggregateOutputType | null
    _max: AgencyClientNotesMaxAggregateOutputType | null
  }

  type GetAgencyClientNotesGroupByPayload<T extends AgencyClientNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyClientNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyClientNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyClientNotesGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyClientNotesGroupByOutputType[P]>
        }
      >
    >


  export type AgencyClientNotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    agencyClientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientNotes"]>

  export type AgencyClientNotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    agencyClientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientNotes"]>

  export type AgencyClientNotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    agencyClientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientNotes"]>

  export type AgencyClientNotesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    agencyClientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyClientNotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "agencyClientId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["agencyClientNotes"]>
  export type AgencyClientNotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }
  export type AgencyClientNotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }
  export type AgencyClientNotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyClient?: boolean | AgencyClientDefaultArgs<ExtArgs>
    createdByMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }

  export type $AgencyClientNotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyClientNotes"
    objects: {
      agencyClient: Prisma.$AgencyClientPayload<ExtArgs>
      createdByMember: Prisma.$AgencyMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      agencyClientId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyClientNotes"]>
    composites: {}
  }

  type AgencyClientNotesGetPayload<S extends boolean | null | undefined | AgencyClientNotesDefaultArgs> = $Result.GetResult<Prisma.$AgencyClientNotesPayload, S>

  type AgencyClientNotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyClientNotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyClientNotesCountAggregateInputType | true
    }

  export interface AgencyClientNotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyClientNotes'], meta: { name: 'AgencyClientNotes' } }
    /**
     * Find zero or one AgencyClientNotes that matches the filter.
     * @param {AgencyClientNotesFindUniqueArgs} args - Arguments to find a AgencyClientNotes
     * @example
     * // Get one AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyClientNotesFindUniqueArgs>(args: SelectSubset<T, AgencyClientNotesFindUniqueArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyClientNotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyClientNotesFindUniqueOrThrowArgs} args - Arguments to find a AgencyClientNotes
     * @example
     * // Get one AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyClientNotesFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyClientNotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClientNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesFindFirstArgs} args - Arguments to find a AgencyClientNotes
     * @example
     * // Get one AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyClientNotesFindFirstArgs>(args?: SelectSubset<T, AgencyClientNotesFindFirstArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClientNotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesFindFirstOrThrowArgs} args - Arguments to find a AgencyClientNotes
     * @example
     * // Get one AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyClientNotesFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyClientNotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyClientNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findMany()
     * 
     * // Get first 10 AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyClientNotesWithIdOnly = await prisma.agencyClientNotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyClientNotesFindManyArgs>(args?: SelectSubset<T, AgencyClientNotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyClientNotes.
     * @param {AgencyClientNotesCreateArgs} args - Arguments to create a AgencyClientNotes.
     * @example
     * // Create one AgencyClientNotes
     * const AgencyClientNotes = await prisma.agencyClientNotes.create({
     *   data: {
     *     // ... data to create a AgencyClientNotes
     *   }
     * })
     * 
     */
    create<T extends AgencyClientNotesCreateArgs>(args: SelectSubset<T, AgencyClientNotesCreateArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyClientNotes.
     * @param {AgencyClientNotesCreateManyArgs} args - Arguments to create many AgencyClientNotes.
     * @example
     * // Create many AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyClientNotesCreateManyArgs>(args?: SelectSubset<T, AgencyClientNotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyClientNotes and returns the data saved in the database.
     * @param {AgencyClientNotesCreateManyAndReturnArgs} args - Arguments to create many AgencyClientNotes.
     * @example
     * // Create many AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyClientNotes and only return the `id`
     * const agencyClientNotesWithIdOnly = await prisma.agencyClientNotes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyClientNotesCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyClientNotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyClientNotes.
     * @param {AgencyClientNotesDeleteArgs} args - Arguments to delete one AgencyClientNotes.
     * @example
     * // Delete one AgencyClientNotes
     * const AgencyClientNotes = await prisma.agencyClientNotes.delete({
     *   where: {
     *     // ... filter to delete one AgencyClientNotes
     *   }
     * })
     * 
     */
    delete<T extends AgencyClientNotesDeleteArgs>(args: SelectSubset<T, AgencyClientNotesDeleteArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyClientNotes.
     * @param {AgencyClientNotesUpdateArgs} args - Arguments to update one AgencyClientNotes.
     * @example
     * // Update one AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyClientNotesUpdateArgs>(args: SelectSubset<T, AgencyClientNotesUpdateArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyClientNotes.
     * @param {AgencyClientNotesDeleteManyArgs} args - Arguments to filter AgencyClientNotes to delete.
     * @example
     * // Delete a few AgencyClientNotes
     * const { count } = await prisma.agencyClientNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyClientNotesDeleteManyArgs>(args?: SelectSubset<T, AgencyClientNotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClientNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyClientNotesUpdateManyArgs>(args: SelectSubset<T, AgencyClientNotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClientNotes and returns the data updated in the database.
     * @param {AgencyClientNotesUpdateManyAndReturnArgs} args - Arguments to update many AgencyClientNotes.
     * @example
     * // Update many AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyClientNotes and only return the `id`
     * const agencyClientNotesWithIdOnly = await prisma.agencyClientNotes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyClientNotesUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyClientNotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyClientNotes.
     * @param {AgencyClientNotesUpsertArgs} args - Arguments to update or create a AgencyClientNotes.
     * @example
     * // Update or create a AgencyClientNotes
     * const agencyClientNotes = await prisma.agencyClientNotes.upsert({
     *   create: {
     *     // ... data to create a AgencyClientNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyClientNotes we want to update
     *   }
     * })
     */
    upsert<T extends AgencyClientNotesUpsertArgs>(args: SelectSubset<T, AgencyClientNotesUpsertArgs<ExtArgs>>): Prisma__AgencyClientNotesClient<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyClientNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesCountArgs} args - Arguments to filter AgencyClientNotes to count.
     * @example
     * // Count the number of AgencyClientNotes
     * const count = await prisma.agencyClientNotes.count({
     *   where: {
     *     // ... the filter for the AgencyClientNotes we want to count
     *   }
     * })
    **/
    count<T extends AgencyClientNotesCountArgs>(
      args?: Subset<T, AgencyClientNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyClientNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyClientNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyClientNotesAggregateArgs>(args: Subset<T, AgencyClientNotesAggregateArgs>): Prisma.PrismaPromise<GetAgencyClientNotesAggregateType<T>>

    /**
     * Group by AgencyClientNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyClientNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyClientNotesGroupByArgs['orderBy'] }
        : { orderBy?: AgencyClientNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyClientNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyClientNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyClientNotes model
   */
  readonly fields: AgencyClientNotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyClientNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClientNotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agencyClient<T extends AgencyClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClientDefaultArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByMember<T extends AgencyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMemberDefaultArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyClientNotes model
   */
  interface AgencyClientNotesFieldRefs {
    readonly id: FieldRef<"AgencyClientNotes", 'String'>
    readonly title: FieldRef<"AgencyClientNotes", 'String'>
    readonly description: FieldRef<"AgencyClientNotes", 'String'>
    readonly agencyClientId: FieldRef<"AgencyClientNotes", 'String'>
    readonly createdById: FieldRef<"AgencyClientNotes", 'String'>
    readonly createdAt: FieldRef<"AgencyClientNotes", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyClientNotes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyClientNotes findUnique
   */
  export type AgencyClientNotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientNotes to fetch.
     */
    where: AgencyClientNotesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes findUniqueOrThrow
   */
  export type AgencyClientNotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientNotes to fetch.
     */
    where: AgencyClientNotesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes findFirst
   */
  export type AgencyClientNotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientNotes to fetch.
     */
    where?: AgencyClientNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientNotes to fetch.
     */
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClientNotes.
     */
    cursor?: AgencyClientNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClientNotes.
     */
    distinct?: AgencyClientNotesScalarFieldEnum | AgencyClientNotesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes findFirstOrThrow
   */
  export type AgencyClientNotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientNotes to fetch.
     */
    where?: AgencyClientNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientNotes to fetch.
     */
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClientNotes.
     */
    cursor?: AgencyClientNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClientNotes.
     */
    distinct?: AgencyClientNotesScalarFieldEnum | AgencyClientNotesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes findMany
   */
  export type AgencyClientNotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientNotes to fetch.
     */
    where?: AgencyClientNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientNotes to fetch.
     */
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyClientNotes.
     */
    cursor?: AgencyClientNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientNotes.
     */
    skip?: number
    distinct?: AgencyClientNotesScalarFieldEnum | AgencyClientNotesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes create
   */
  export type AgencyClientNotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyClientNotes.
     */
    data: XOR<AgencyClientNotesCreateInput, AgencyClientNotesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes createMany
   */
  export type AgencyClientNotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyClientNotes.
     */
    data: AgencyClientNotesCreateManyInput | AgencyClientNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyClientNotes createManyAndReturn
   */
  export type AgencyClientNotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyClientNotes.
     */
    data: AgencyClientNotesCreateManyInput | AgencyClientNotesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClientNotes update
   */
  export type AgencyClientNotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyClientNotes.
     */
    data: XOR<AgencyClientNotesUpdateInput, AgencyClientNotesUncheckedUpdateInput>
    /**
     * Choose, which AgencyClientNotes to update.
     */
    where: AgencyClientNotesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes updateMany
   */
  export type AgencyClientNotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyClientNotes.
     */
    data: XOR<AgencyClientNotesUpdateManyMutationInput, AgencyClientNotesUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClientNotes to update
     */
    where?: AgencyClientNotesWhereInput
    /**
     * Limit how many AgencyClientNotes to update.
     */
    limit?: number
  }

  /**
   * AgencyClientNotes updateManyAndReturn
   */
  export type AgencyClientNotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * The data used to update AgencyClientNotes.
     */
    data: XOR<AgencyClientNotesUpdateManyMutationInput, AgencyClientNotesUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClientNotes to update
     */
    where?: AgencyClientNotesWhereInput
    /**
     * Limit how many AgencyClientNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClientNotes upsert
   */
  export type AgencyClientNotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyClientNotes to update in case it exists.
     */
    where: AgencyClientNotesWhereUniqueInput
    /**
     * In case the AgencyClientNotes found by the `where` argument doesn't exist, create a new AgencyClientNotes with this data.
     */
    create: XOR<AgencyClientNotesCreateInput, AgencyClientNotesUncheckedCreateInput>
    /**
     * In case the AgencyClientNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyClientNotesUpdateInput, AgencyClientNotesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes delete
   */
  export type AgencyClientNotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    /**
     * Filter which AgencyClientNotes to delete.
     */
    where: AgencyClientNotesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientNotes deleteMany
   */
  export type AgencyClientNotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClientNotes to delete
     */
    where?: AgencyClientNotesWhereInput
    /**
     * Limit how many AgencyClientNotes to delete.
     */
    limit?: number
  }

  /**
   * AgencyClientNotes without action
   */
  export type AgencyClientNotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
  }


  /**
   * Model AgencyClient
   */

  export type AggregateAgencyClient = {
    _count: AgencyClientCountAggregateOutputType | null
    _min: AgencyClientMinAggregateOutputType | null
    _max: AgencyClientMaxAggregateOutputType | null
  }

  export type AgencyClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    status: $Enums.AgencyClientStatus | null
    location: string | null
    agencyId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    status: $Enums.AgencyClientStatus | null
    location: string | null
    agencyId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyClientCountAggregateOutputType = {
    id: number
    name: number
    lastName: number
    email: number
    phone: number
    status: number
    location: number
    agencyId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyClientMinAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    location?: true
    agencyId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyClientMaxAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    location?: true
    agencyId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyClientCountAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    location?: true
    agencyId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClient to aggregate.
     */
    where?: AgencyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyClients
    **/
    _count?: true | AgencyClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyClientMaxAggregateInputType
  }

  export type GetAgencyClientAggregateType<T extends AgencyClientAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyClient[P]>
      : GetScalarType<T[P], AggregateAgencyClient[P]>
  }




  export type AgencyClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientWhereInput
    orderBy?: AgencyClientOrderByWithAggregationInput | AgencyClientOrderByWithAggregationInput[]
    by: AgencyClientScalarFieldEnum[] | AgencyClientScalarFieldEnum
    having?: AgencyClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyClientCountAggregateInputType | true
    _min?: AgencyClientMinAggregateInputType
    _max?: AgencyClientMaxAggregateInputType
  }

  export type AgencyClientGroupByOutputType = {
    id: string
    name: string
    lastName: string | null
    email: string | null
    phone: string | null
    status: $Enums.AgencyClientStatus | null
    location: string | null
    agencyId: string
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyClientCountAggregateOutputType | null
    _min: AgencyClientMinAggregateOutputType | null
    _max: AgencyClientMaxAggregateOutputType | null
  }

  type GetAgencyClientGroupByPayload<T extends AgencyClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyClientGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyClientGroupByOutputType[P]>
        }
      >
    >


  export type AgencyClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    location?: boolean
    agencyId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberNotes?: boolean | AgencyClient$memberNotesArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
    preferences?: boolean | AgencyClient$preferencesArgs<ExtArgs>
    ownedProperties?: boolean | AgencyClient$ownedPropertiesArgs<ExtArgs>
    rentedProperties?: boolean | AgencyClient$rentedPropertiesArgs<ExtArgs>
    _count?: boolean | AgencyClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClient"]>

  export type AgencyClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    location?: boolean
    agencyId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClient"]>

  export type AgencyClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    location?: boolean
    agencyId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClient"]>

  export type AgencyClientSelectScalar = {
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    location?: boolean
    agencyId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "lastName" | "email" | "phone" | "status" | "location" | "agencyId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["agencyClient"]>
  export type AgencyClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberNotes?: boolean | AgencyClient$memberNotesArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
    preferences?: boolean | AgencyClient$preferencesArgs<ExtArgs>
    ownedProperties?: boolean | AgencyClient$ownedPropertiesArgs<ExtArgs>
    rentedProperties?: boolean | AgencyClient$rentedPropertiesArgs<ExtArgs>
    _count?: boolean | AgencyClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
  }
  export type AgencyClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    createdBy?: boolean | AgencyClient$createdByArgs<ExtArgs>
  }

  export type $AgencyClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyClient"
    objects: {
      memberNotes: Prisma.$AgencyClientNotesPayload<ExtArgs>[]
      agency: Prisma.$AgencyPayload<ExtArgs>
      createdBy: Prisma.$AgencyMemberPayload<ExtArgs> | null
      preferences: Prisma.$AgencyClientPreferencePayload<ExtArgs>[]
      ownedProperties: Prisma.$PropertyPayload<ExtArgs>[]
      rentedProperties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      lastName: string | null
      email: string | null
      phone: string | null
      status: $Enums.AgencyClientStatus | null
      location: string | null
      agencyId: string
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyClient"]>
    composites: {}
  }

  type AgencyClientGetPayload<S extends boolean | null | undefined | AgencyClientDefaultArgs> = $Result.GetResult<Prisma.$AgencyClientPayload, S>

  type AgencyClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyClientCountAggregateInputType | true
    }

  export interface AgencyClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyClient'], meta: { name: 'AgencyClient' } }
    /**
     * Find zero or one AgencyClient that matches the filter.
     * @param {AgencyClientFindUniqueArgs} args - Arguments to find a AgencyClient
     * @example
     * // Get one AgencyClient
     * const agencyClient = await prisma.agencyClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyClientFindUniqueArgs>(args: SelectSubset<T, AgencyClientFindUniqueArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyClientFindUniqueOrThrowArgs} args - Arguments to find a AgencyClient
     * @example
     * // Get one AgencyClient
     * const agencyClient = await prisma.agencyClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyClientFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientFindFirstArgs} args - Arguments to find a AgencyClient
     * @example
     * // Get one AgencyClient
     * const agencyClient = await prisma.agencyClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyClientFindFirstArgs>(args?: SelectSubset<T, AgencyClientFindFirstArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientFindFirstOrThrowArgs} args - Arguments to find a AgencyClient
     * @example
     * // Get one AgencyClient
     * const agencyClient = await prisma.agencyClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyClientFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyClients
     * const agencyClients = await prisma.agencyClient.findMany()
     * 
     * // Get first 10 AgencyClients
     * const agencyClients = await prisma.agencyClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyClientWithIdOnly = await prisma.agencyClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyClientFindManyArgs>(args?: SelectSubset<T, AgencyClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyClient.
     * @param {AgencyClientCreateArgs} args - Arguments to create a AgencyClient.
     * @example
     * // Create one AgencyClient
     * const AgencyClient = await prisma.agencyClient.create({
     *   data: {
     *     // ... data to create a AgencyClient
     *   }
     * })
     * 
     */
    create<T extends AgencyClientCreateArgs>(args: SelectSubset<T, AgencyClientCreateArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyClients.
     * @param {AgencyClientCreateManyArgs} args - Arguments to create many AgencyClients.
     * @example
     * // Create many AgencyClients
     * const agencyClient = await prisma.agencyClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyClientCreateManyArgs>(args?: SelectSubset<T, AgencyClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyClients and returns the data saved in the database.
     * @param {AgencyClientCreateManyAndReturnArgs} args - Arguments to create many AgencyClients.
     * @example
     * // Create many AgencyClients
     * const agencyClient = await prisma.agencyClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyClients and only return the `id`
     * const agencyClientWithIdOnly = await prisma.agencyClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyClientCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyClient.
     * @param {AgencyClientDeleteArgs} args - Arguments to delete one AgencyClient.
     * @example
     * // Delete one AgencyClient
     * const AgencyClient = await prisma.agencyClient.delete({
     *   where: {
     *     // ... filter to delete one AgencyClient
     *   }
     * })
     * 
     */
    delete<T extends AgencyClientDeleteArgs>(args: SelectSubset<T, AgencyClientDeleteArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyClient.
     * @param {AgencyClientUpdateArgs} args - Arguments to update one AgencyClient.
     * @example
     * // Update one AgencyClient
     * const agencyClient = await prisma.agencyClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyClientUpdateArgs>(args: SelectSubset<T, AgencyClientUpdateArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyClients.
     * @param {AgencyClientDeleteManyArgs} args - Arguments to filter AgencyClients to delete.
     * @example
     * // Delete a few AgencyClients
     * const { count } = await prisma.agencyClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyClientDeleteManyArgs>(args?: SelectSubset<T, AgencyClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyClients
     * const agencyClient = await prisma.agencyClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyClientUpdateManyArgs>(args: SelectSubset<T, AgencyClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClients and returns the data updated in the database.
     * @param {AgencyClientUpdateManyAndReturnArgs} args - Arguments to update many AgencyClients.
     * @example
     * // Update many AgencyClients
     * const agencyClient = await prisma.agencyClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyClients and only return the `id`
     * const agencyClientWithIdOnly = await prisma.agencyClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyClientUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyClient.
     * @param {AgencyClientUpsertArgs} args - Arguments to update or create a AgencyClient.
     * @example
     * // Update or create a AgencyClient
     * const agencyClient = await prisma.agencyClient.upsert({
     *   create: {
     *     // ... data to create a AgencyClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyClient we want to update
     *   }
     * })
     */
    upsert<T extends AgencyClientUpsertArgs>(args: SelectSubset<T, AgencyClientUpsertArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientCountArgs} args - Arguments to filter AgencyClients to count.
     * @example
     * // Count the number of AgencyClients
     * const count = await prisma.agencyClient.count({
     *   where: {
     *     // ... the filter for the AgencyClients we want to count
     *   }
     * })
    **/
    count<T extends AgencyClientCountArgs>(
      args?: Subset<T, AgencyClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyClientAggregateArgs>(args: Subset<T, AgencyClientAggregateArgs>): Prisma.PrismaPromise<GetAgencyClientAggregateType<T>>

    /**
     * Group by AgencyClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyClientGroupByArgs['orderBy'] }
        : { orderBy?: AgencyClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyClient model
   */
  readonly fields: AgencyClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberNotes<T extends AgencyClient$memberNotesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClient$memberNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends AgencyClient$createdByArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClient$createdByArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preferences<T extends AgencyClient$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClient$preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedProperties<T extends AgencyClient$ownedPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClient$ownedPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentedProperties<T extends AgencyClient$rentedPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClient$rentedPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyClient model
   */
  interface AgencyClientFieldRefs {
    readonly id: FieldRef<"AgencyClient", 'String'>
    readonly name: FieldRef<"AgencyClient", 'String'>
    readonly lastName: FieldRef<"AgencyClient", 'String'>
    readonly email: FieldRef<"AgencyClient", 'String'>
    readonly phone: FieldRef<"AgencyClient", 'String'>
    readonly status: FieldRef<"AgencyClient", 'AgencyClientStatus'>
    readonly location: FieldRef<"AgencyClient", 'String'>
    readonly agencyId: FieldRef<"AgencyClient", 'String'>
    readonly createdById: FieldRef<"AgencyClient", 'String'>
    readonly createdAt: FieldRef<"AgencyClient", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyClient findUnique
   */
  export type AgencyClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClient to fetch.
     */
    where: AgencyClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient findUniqueOrThrow
   */
  export type AgencyClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClient to fetch.
     */
    where: AgencyClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient findFirst
   */
  export type AgencyClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClient to fetch.
     */
    where?: AgencyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClients.
     */
    cursor?: AgencyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClients.
     */
    distinct?: AgencyClientScalarFieldEnum | AgencyClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient findFirstOrThrow
   */
  export type AgencyClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClient to fetch.
     */
    where?: AgencyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClients.
     */
    cursor?: AgencyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClients.
     */
    distinct?: AgencyClientScalarFieldEnum | AgencyClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient findMany
   */
  export type AgencyClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClients to fetch.
     */
    where?: AgencyClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClients to fetch.
     */
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyClients.
     */
    cursor?: AgencyClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClients.
     */
    skip?: number
    distinct?: AgencyClientScalarFieldEnum | AgencyClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient create
   */
  export type AgencyClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyClient.
     */
    data: XOR<AgencyClientCreateInput, AgencyClientUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient createMany
   */
  export type AgencyClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyClients.
     */
    data: AgencyClientCreateManyInput | AgencyClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyClient createManyAndReturn
   */
  export type AgencyClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyClients.
     */
    data: AgencyClientCreateManyInput | AgencyClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClient update
   */
  export type AgencyClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyClient.
     */
    data: XOR<AgencyClientUpdateInput, AgencyClientUncheckedUpdateInput>
    /**
     * Choose, which AgencyClient to update.
     */
    where: AgencyClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient updateMany
   */
  export type AgencyClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyClients.
     */
    data: XOR<AgencyClientUpdateManyMutationInput, AgencyClientUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClients to update
     */
    where?: AgencyClientWhereInput
    /**
     * Limit how many AgencyClients to update.
     */
    limit?: number
  }

  /**
   * AgencyClient updateManyAndReturn
   */
  export type AgencyClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * The data used to update AgencyClients.
     */
    data: XOR<AgencyClientUpdateManyMutationInput, AgencyClientUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClients to update
     */
    where?: AgencyClientWhereInput
    /**
     * Limit how many AgencyClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClient upsert
   */
  export type AgencyClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyClient to update in case it exists.
     */
    where: AgencyClientWhereUniqueInput
    /**
     * In case the AgencyClient found by the `where` argument doesn't exist, create a new AgencyClient with this data.
     */
    create: XOR<AgencyClientCreateInput, AgencyClientUncheckedCreateInput>
    /**
     * In case the AgencyClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyClientUpdateInput, AgencyClientUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient delete
   */
  export type AgencyClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    /**
     * Filter which AgencyClient to delete.
     */
    where: AgencyClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClient deleteMany
   */
  export type AgencyClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClients to delete
     */
    where?: AgencyClientWhereInput
    /**
     * Limit how many AgencyClients to delete.
     */
    limit?: number
  }

  /**
   * AgencyClient.memberNotes
   */
  export type AgencyClient$memberNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    where?: AgencyClientNotesWhereInput
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    cursor?: AgencyClientNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientNotesScalarFieldEnum | AgencyClientNotesScalarFieldEnum[]
  }

  /**
   * AgencyClient.createdBy
   */
  export type AgencyClient$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    where?: AgencyMemberWhereInput
  }

  /**
   * AgencyClient.preferences
   */
  export type AgencyClient$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    where?: AgencyClientPreferenceWhereInput
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    cursor?: AgencyClientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientPreferenceScalarFieldEnum | AgencyClientPreferenceScalarFieldEnum[]
  }

  /**
   * AgencyClient.ownedProperties
   */
  export type AgencyClient$ownedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * AgencyClient.rentedProperties
   */
  export type AgencyClient$rentedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * AgencyClient without action
   */
  export type AgencyClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
  }


  /**
   * Model AgencyClientPreference
   */

  export type AggregateAgencyClientPreference = {
    _count: AgencyClientPreferenceCountAggregateOutputType | null
    _avg: AgencyClientPreferenceAvgAggregateOutputType | null
    _sum: AgencyClientPreferenceSumAggregateOutputType | null
    _min: AgencyClientPreferenceMinAggregateOutputType | null
    _max: AgencyClientPreferenceMaxAggregateOutputType | null
  }

  export type AgencyClientPreferenceAvgAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    minSize: number | null
    maxSize: number | null
  }

  export type AgencyClientPreferenceSumAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    minSize: number | null
    maxSize: number | null
  }

  export type AgencyClientPreferenceMinAggregateOutputType = {
    id: string | null
    propertyType: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    minPrice: number | null
    maxPrice: number | null
    minSize: number | null
    maxSize: number | null
    categoryId: string | null
    subcategoryId: string | null
    locationId: string | null
    location: string | null
    createdById: string | null
    agencyClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.AgencyClientPreferenceStatus | null
    lastOfferSentAt: Date | null
  }

  export type AgencyClientPreferenceMaxAggregateOutputType = {
    id: string | null
    propertyType: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    minPrice: number | null
    maxPrice: number | null
    minSize: number | null
    maxSize: number | null
    categoryId: string | null
    subcategoryId: string | null
    locationId: string | null
    location: string | null
    createdById: string | null
    agencyClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.AgencyClientPreferenceStatus | null
    lastOfferSentAt: Date | null
  }

  export type AgencyClientPreferenceCountAggregateOutputType = {
    id: number
    propertyType: number
    listingType: number
    minPrice: number
    maxPrice: number
    minSize: number
    maxSize: number
    categoryId: number
    subcategoryId: number
    locationId: number
    location: number
    createdById: number
    agencyClientId: number
    offeredPropertyIds: number
    createdAt: number
    updatedAt: number
    status: number
    lastOfferSentAt: number
    _all: number
  }


  export type AgencyClientPreferenceAvgAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    minSize?: true
    maxSize?: true
  }

  export type AgencyClientPreferenceSumAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    minSize?: true
    maxSize?: true
  }

  export type AgencyClientPreferenceMinAggregateInputType = {
    id?: true
    propertyType?: true
    listingType?: true
    minPrice?: true
    maxPrice?: true
    minSize?: true
    maxSize?: true
    categoryId?: true
    subcategoryId?: true
    locationId?: true
    location?: true
    createdById?: true
    agencyClientId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    lastOfferSentAt?: true
  }

  export type AgencyClientPreferenceMaxAggregateInputType = {
    id?: true
    propertyType?: true
    listingType?: true
    minPrice?: true
    maxPrice?: true
    minSize?: true
    maxSize?: true
    categoryId?: true
    subcategoryId?: true
    locationId?: true
    location?: true
    createdById?: true
    agencyClientId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    lastOfferSentAt?: true
  }

  export type AgencyClientPreferenceCountAggregateInputType = {
    id?: true
    propertyType?: true
    listingType?: true
    minPrice?: true
    maxPrice?: true
    minSize?: true
    maxSize?: true
    categoryId?: true
    subcategoryId?: true
    locationId?: true
    location?: true
    createdById?: true
    agencyClientId?: true
    offeredPropertyIds?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    lastOfferSentAt?: true
    _all?: true
  }

  export type AgencyClientPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClientPreference to aggregate.
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientPreferences to fetch.
     */
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyClientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyClientPreferences
    **/
    _count?: true | AgencyClientPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyClientPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyClientPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyClientPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyClientPreferenceMaxAggregateInputType
  }

  export type GetAgencyClientPreferenceAggregateType<T extends AgencyClientPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyClientPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyClientPreference[P]>
      : GetScalarType<T[P], AggregateAgencyClientPreference[P]>
  }




  export type AgencyClientPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyClientPreferenceWhereInput
    orderBy?: AgencyClientPreferenceOrderByWithAggregationInput | AgencyClientPreferenceOrderByWithAggregationInput[]
    by: AgencyClientPreferenceScalarFieldEnum[] | AgencyClientPreferenceScalarFieldEnum
    having?: AgencyClientPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyClientPreferenceCountAggregateInputType | true
    _avg?: AgencyClientPreferenceAvgAggregateInputType
    _sum?: AgencyClientPreferenceSumAggregateInputType
    _min?: AgencyClientPreferenceMinAggregateInputType
    _max?: AgencyClientPreferenceMaxAggregateInputType
  }

  export type AgencyClientPreferenceGroupByOutputType = {
    id: string
    propertyType: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    minPrice: number | null
    maxPrice: number | null
    minSize: number | null
    maxSize: number | null
    categoryId: string | null
    subcategoryId: string | null
    locationId: string | null
    location: string | null
    createdById: string | null
    agencyClientId: string | null
    offeredPropertyIds: string[]
    createdAt: Date
    updatedAt: Date
    status: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt: Date | null
    _count: AgencyClientPreferenceCountAggregateOutputType | null
    _avg: AgencyClientPreferenceAvgAggregateOutputType | null
    _sum: AgencyClientPreferenceSumAggregateOutputType | null
    _min: AgencyClientPreferenceMinAggregateOutputType | null
    _max: AgencyClientPreferenceMaxAggregateOutputType | null
  }

  type GetAgencyClientPreferenceGroupByPayload<T extends AgencyClientPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyClientPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyClientPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyClientPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyClientPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type AgencyClientPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyType?: boolean
    listingType?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minSize?: boolean
    maxSize?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    locationId?: boolean
    location?: boolean
    createdById?: boolean
    agencyClientId?: boolean
    offeredPropertyIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastOfferSentAt?: boolean
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientPreference"]>

  export type AgencyClientPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyType?: boolean
    listingType?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minSize?: boolean
    maxSize?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    locationId?: boolean
    location?: boolean
    createdById?: boolean
    agencyClientId?: boolean
    offeredPropertyIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastOfferSentAt?: boolean
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientPreference"]>

  export type AgencyClientPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyType?: boolean
    listingType?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minSize?: boolean
    maxSize?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    locationId?: boolean
    location?: boolean
    createdById?: boolean
    agencyClientId?: boolean
    offeredPropertyIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastOfferSentAt?: boolean
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyClientPreference"]>

  export type AgencyClientPreferenceSelectScalar = {
    id?: boolean
    propertyType?: boolean
    listingType?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minSize?: boolean
    maxSize?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    locationId?: boolean
    location?: boolean
    createdById?: boolean
    agencyClientId?: boolean
    offeredPropertyIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastOfferSentAt?: boolean
  }

  export type AgencyClientPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyType" | "listingType" | "minPrice" | "maxPrice" | "minSize" | "maxSize" | "categoryId" | "subcategoryId" | "locationId" | "location" | "createdById" | "agencyClientId" | "offeredPropertyIds" | "createdAt" | "updatedAt" | "status" | "lastOfferSentAt", ExtArgs["result"]["agencyClientPreference"]>
  export type AgencyClientPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }
  export type AgencyClientPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }
  export type AgencyClientPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AgencyClientPreference$createdByArgs<ExtArgs>
    agencyClient?: boolean | AgencyClientPreference$agencyClientArgs<ExtArgs>
  }

  export type $AgencyClientPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyClientPreference"
    objects: {
      createdBy: Prisma.$AgencyMemberPayload<ExtArgs> | null
      agencyClient: Prisma.$AgencyClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyType: $Enums.PropertyType | null
      listingType: $Enums.PropertyListingType | null
      minPrice: number | null
      maxPrice: number | null
      minSize: number | null
      maxSize: number | null
      categoryId: string | null
      subcategoryId: string | null
      locationId: string | null
      location: string | null
      createdById: string | null
      agencyClientId: string | null
      offeredPropertyIds: string[]
      createdAt: Date
      updatedAt: Date
      status: $Enums.AgencyClientPreferenceStatus
      lastOfferSentAt: Date | null
    }, ExtArgs["result"]["agencyClientPreference"]>
    composites: {}
  }

  type AgencyClientPreferenceGetPayload<S extends boolean | null | undefined | AgencyClientPreferenceDefaultArgs> = $Result.GetResult<Prisma.$AgencyClientPreferencePayload, S>

  type AgencyClientPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyClientPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyClientPreferenceCountAggregateInputType | true
    }

  export interface AgencyClientPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyClientPreference'], meta: { name: 'AgencyClientPreference' } }
    /**
     * Find zero or one AgencyClientPreference that matches the filter.
     * @param {AgencyClientPreferenceFindUniqueArgs} args - Arguments to find a AgencyClientPreference
     * @example
     * // Get one AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyClientPreferenceFindUniqueArgs>(args: SelectSubset<T, AgencyClientPreferenceFindUniqueArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyClientPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyClientPreferenceFindUniqueOrThrowArgs} args - Arguments to find a AgencyClientPreference
     * @example
     * // Get one AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyClientPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyClientPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClientPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceFindFirstArgs} args - Arguments to find a AgencyClientPreference
     * @example
     * // Get one AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyClientPreferenceFindFirstArgs>(args?: SelectSubset<T, AgencyClientPreferenceFindFirstArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyClientPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceFindFirstOrThrowArgs} args - Arguments to find a AgencyClientPreference
     * @example
     * // Get one AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyClientPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyClientPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyClientPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyClientPreferences
     * const agencyClientPreferences = await prisma.agencyClientPreference.findMany()
     * 
     * // Get first 10 AgencyClientPreferences
     * const agencyClientPreferences = await prisma.agencyClientPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyClientPreferenceWithIdOnly = await prisma.agencyClientPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyClientPreferenceFindManyArgs>(args?: SelectSubset<T, AgencyClientPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyClientPreference.
     * @param {AgencyClientPreferenceCreateArgs} args - Arguments to create a AgencyClientPreference.
     * @example
     * // Create one AgencyClientPreference
     * const AgencyClientPreference = await prisma.agencyClientPreference.create({
     *   data: {
     *     // ... data to create a AgencyClientPreference
     *   }
     * })
     * 
     */
    create<T extends AgencyClientPreferenceCreateArgs>(args: SelectSubset<T, AgencyClientPreferenceCreateArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyClientPreferences.
     * @param {AgencyClientPreferenceCreateManyArgs} args - Arguments to create many AgencyClientPreferences.
     * @example
     * // Create many AgencyClientPreferences
     * const agencyClientPreference = await prisma.agencyClientPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyClientPreferenceCreateManyArgs>(args?: SelectSubset<T, AgencyClientPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyClientPreferences and returns the data saved in the database.
     * @param {AgencyClientPreferenceCreateManyAndReturnArgs} args - Arguments to create many AgencyClientPreferences.
     * @example
     * // Create many AgencyClientPreferences
     * const agencyClientPreference = await prisma.agencyClientPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyClientPreferences and only return the `id`
     * const agencyClientPreferenceWithIdOnly = await prisma.agencyClientPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyClientPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyClientPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyClientPreference.
     * @param {AgencyClientPreferenceDeleteArgs} args - Arguments to delete one AgencyClientPreference.
     * @example
     * // Delete one AgencyClientPreference
     * const AgencyClientPreference = await prisma.agencyClientPreference.delete({
     *   where: {
     *     // ... filter to delete one AgencyClientPreference
     *   }
     * })
     * 
     */
    delete<T extends AgencyClientPreferenceDeleteArgs>(args: SelectSubset<T, AgencyClientPreferenceDeleteArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyClientPreference.
     * @param {AgencyClientPreferenceUpdateArgs} args - Arguments to update one AgencyClientPreference.
     * @example
     * // Update one AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyClientPreferenceUpdateArgs>(args: SelectSubset<T, AgencyClientPreferenceUpdateArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyClientPreferences.
     * @param {AgencyClientPreferenceDeleteManyArgs} args - Arguments to filter AgencyClientPreferences to delete.
     * @example
     * // Delete a few AgencyClientPreferences
     * const { count } = await prisma.agencyClientPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyClientPreferenceDeleteManyArgs>(args?: SelectSubset<T, AgencyClientPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyClientPreferences
     * const agencyClientPreference = await prisma.agencyClientPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyClientPreferenceUpdateManyArgs>(args: SelectSubset<T, AgencyClientPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyClientPreferences and returns the data updated in the database.
     * @param {AgencyClientPreferenceUpdateManyAndReturnArgs} args - Arguments to update many AgencyClientPreferences.
     * @example
     * // Update many AgencyClientPreferences
     * const agencyClientPreference = await prisma.agencyClientPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyClientPreferences and only return the `id`
     * const agencyClientPreferenceWithIdOnly = await prisma.agencyClientPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyClientPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyClientPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyClientPreference.
     * @param {AgencyClientPreferenceUpsertArgs} args - Arguments to update or create a AgencyClientPreference.
     * @example
     * // Update or create a AgencyClientPreference
     * const agencyClientPreference = await prisma.agencyClientPreference.upsert({
     *   create: {
     *     // ... data to create a AgencyClientPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyClientPreference we want to update
     *   }
     * })
     */
    upsert<T extends AgencyClientPreferenceUpsertArgs>(args: SelectSubset<T, AgencyClientPreferenceUpsertArgs<ExtArgs>>): Prisma__AgencyClientPreferenceClient<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyClientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceCountArgs} args - Arguments to filter AgencyClientPreferences to count.
     * @example
     * // Count the number of AgencyClientPreferences
     * const count = await prisma.agencyClientPreference.count({
     *   where: {
     *     // ... the filter for the AgencyClientPreferences we want to count
     *   }
     * })
    **/
    count<T extends AgencyClientPreferenceCountArgs>(
      args?: Subset<T, AgencyClientPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyClientPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyClientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyClientPreferenceAggregateArgs>(args: Subset<T, AgencyClientPreferenceAggregateArgs>): Prisma.PrismaPromise<GetAgencyClientPreferenceAggregateType<T>>

    /**
     * Group by AgencyClientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyClientPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyClientPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyClientPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: AgencyClientPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyClientPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyClientPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyClientPreference model
   */
  readonly fields: AgencyClientPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyClientPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClientPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends AgencyClientPreference$createdByArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClientPreference$createdByArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyClient<T extends AgencyClientPreference$agencyClientArgs<ExtArgs> = {}>(args?: Subset<T, AgencyClientPreference$agencyClientArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyClientPreference model
   */
  interface AgencyClientPreferenceFieldRefs {
    readonly id: FieldRef<"AgencyClientPreference", 'String'>
    readonly propertyType: FieldRef<"AgencyClientPreference", 'PropertyType'>
    readonly listingType: FieldRef<"AgencyClientPreference", 'PropertyListingType'>
    readonly minPrice: FieldRef<"AgencyClientPreference", 'Int'>
    readonly maxPrice: FieldRef<"AgencyClientPreference", 'Int'>
    readonly minSize: FieldRef<"AgencyClientPreference", 'Int'>
    readonly maxSize: FieldRef<"AgencyClientPreference", 'Int'>
    readonly categoryId: FieldRef<"AgencyClientPreference", 'String'>
    readonly subcategoryId: FieldRef<"AgencyClientPreference", 'String'>
    readonly locationId: FieldRef<"AgencyClientPreference", 'String'>
    readonly location: FieldRef<"AgencyClientPreference", 'String'>
    readonly createdById: FieldRef<"AgencyClientPreference", 'String'>
    readonly agencyClientId: FieldRef<"AgencyClientPreference", 'String'>
    readonly offeredPropertyIds: FieldRef<"AgencyClientPreference", 'String[]'>
    readonly createdAt: FieldRef<"AgencyClientPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyClientPreference", 'DateTime'>
    readonly status: FieldRef<"AgencyClientPreference", 'AgencyClientPreferenceStatus'>
    readonly lastOfferSentAt: FieldRef<"AgencyClientPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyClientPreference findUnique
   */
  export type AgencyClientPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientPreference to fetch.
     */
    where: AgencyClientPreferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference findUniqueOrThrow
   */
  export type AgencyClientPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientPreference to fetch.
     */
    where: AgencyClientPreferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference findFirst
   */
  export type AgencyClientPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientPreference to fetch.
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientPreferences to fetch.
     */
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClientPreferences.
     */
    cursor?: AgencyClientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClientPreferences.
     */
    distinct?: AgencyClientPreferenceScalarFieldEnum | AgencyClientPreferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference findFirstOrThrow
   */
  export type AgencyClientPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientPreference to fetch.
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientPreferences to fetch.
     */
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyClientPreferences.
     */
    cursor?: AgencyClientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyClientPreferences.
     */
    distinct?: AgencyClientPreferenceScalarFieldEnum | AgencyClientPreferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference findMany
   */
  export type AgencyClientPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AgencyClientPreferences to fetch.
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyClientPreferences to fetch.
     */
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyClientPreferences.
     */
    cursor?: AgencyClientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyClientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyClientPreferences.
     */
    skip?: number
    distinct?: AgencyClientPreferenceScalarFieldEnum | AgencyClientPreferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference create
   */
  export type AgencyClientPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyClientPreference.
     */
    data: XOR<AgencyClientPreferenceCreateInput, AgencyClientPreferenceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference createMany
   */
  export type AgencyClientPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyClientPreferences.
     */
    data: AgencyClientPreferenceCreateManyInput | AgencyClientPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyClientPreference createManyAndReturn
   */
  export type AgencyClientPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyClientPreferences.
     */
    data: AgencyClientPreferenceCreateManyInput | AgencyClientPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClientPreference update
   */
  export type AgencyClientPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyClientPreference.
     */
    data: XOR<AgencyClientPreferenceUpdateInput, AgencyClientPreferenceUncheckedUpdateInput>
    /**
     * Choose, which AgencyClientPreference to update.
     */
    where: AgencyClientPreferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference updateMany
   */
  export type AgencyClientPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyClientPreferences.
     */
    data: XOR<AgencyClientPreferenceUpdateManyMutationInput, AgencyClientPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClientPreferences to update
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * Limit how many AgencyClientPreferences to update.
     */
    limit?: number
  }

  /**
   * AgencyClientPreference updateManyAndReturn
   */
  export type AgencyClientPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update AgencyClientPreferences.
     */
    data: XOR<AgencyClientPreferenceUpdateManyMutationInput, AgencyClientPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which AgencyClientPreferences to update
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * Limit how many AgencyClientPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyClientPreference upsert
   */
  export type AgencyClientPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyClientPreference to update in case it exists.
     */
    where: AgencyClientPreferenceWhereUniqueInput
    /**
     * In case the AgencyClientPreference found by the `where` argument doesn't exist, create a new AgencyClientPreference with this data.
     */
    create: XOR<AgencyClientPreferenceCreateInput, AgencyClientPreferenceUncheckedCreateInput>
    /**
     * In case the AgencyClientPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyClientPreferenceUpdateInput, AgencyClientPreferenceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference delete
   */
  export type AgencyClientPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    /**
     * Filter which AgencyClientPreference to delete.
     */
    where: AgencyClientPreferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyClientPreference deleteMany
   */
  export type AgencyClientPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyClientPreferences to delete
     */
    where?: AgencyClientPreferenceWhereInput
    /**
     * Limit how many AgencyClientPreferences to delete.
     */
    limit?: number
  }

  /**
   * AgencyClientPreference.createdBy
   */
  export type AgencyClientPreference$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    where?: AgencyMemberWhereInput
  }

  /**
   * AgencyClientPreference.agencyClient
   */
  export type AgencyClientPreference$agencyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    where?: AgencyClientWhereInput
  }

  /**
   * AgencyClientPreference without action
   */
  export type AgencyClientPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model AgencyMember
   */

  export type AggregateAgencyMember = {
    _count: AgencyMemberCountAggregateOutputType | null
    _min: AgencyMemberMinAggregateOutputType | null
    _max: AgencyMemberMaxAggregateOutputType | null
  }

  export type AgencyMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyId: string | null
    status: $Enums.AgencyMemberStatus | null
    role: $Enums.AgencyMemberRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyId: string | null
    status: $Enums.AgencyMemberStatus | null
    role: $Enums.AgencyMemberRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMemberCountAggregateOutputType = {
    id: number
    userId: number
    agencyId: number
    status: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyMemberMinAggregateInputType = {
    id?: true
    userId?: true
    agencyId?: true
    status?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    agencyId?: true
    status?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMemberCountAggregateInputType = {
    id?: true
    userId?: true
    agencyId?: true
    status?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyMember to aggregate.
     */
    where?: AgencyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyMembers to fetch.
     */
    orderBy?: AgencyMemberOrderByWithRelationInput | AgencyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyMembers
    **/
    _count?: true | AgencyMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMemberMaxAggregateInputType
  }

  export type GetAgencyMemberAggregateType<T extends AgencyMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyMember[P]>
      : GetScalarType<T[P], AggregateAgencyMember[P]>
  }




  export type AgencyMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyMemberWhereInput
    orderBy?: AgencyMemberOrderByWithAggregationInput | AgencyMemberOrderByWithAggregationInput[]
    by: AgencyMemberScalarFieldEnum[] | AgencyMemberScalarFieldEnum
    having?: AgencyMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyMemberCountAggregateInputType | true
    _min?: AgencyMemberMinAggregateInputType
    _max?: AgencyMemberMaxAggregateInputType
  }

  export type AgencyMemberGroupByOutputType = {
    id: string
    userId: string
    agencyId: string | null
    status: $Enums.AgencyMemberStatus | null
    role: $Enums.AgencyMemberRole
    createdAt: Date | null
    updatedAt: Date | null
    _count: AgencyMemberCountAggregateOutputType | null
    _min: AgencyMemberMinAggregateOutputType | null
    _max: AgencyMemberMaxAggregateOutputType | null
  }

  type GetAgencyMemberGroupByPayload<T extends AgencyMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyMemberGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyMemberGroupByOutputType[P]>
        }
      >
    >


  export type AgencyMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
    createdProperties?: boolean | AgencyMember$createdPropertiesArgs<ExtArgs>
    agencyClientNotes?: boolean | AgencyMember$agencyClientNotesArgs<ExtArgs>
    agencyClient?: boolean | AgencyMember$agencyClientArgs<ExtArgs>
    AgencyClientPreference?: boolean | AgencyMember$AgencyClientPreferenceArgs<ExtArgs>
    reminders?: boolean | AgencyMember$remindersArgs<ExtArgs>
    _count?: boolean | AgencyMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyMember"]>

  export type AgencyMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencyMember"]>

  export type AgencyMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencyMember"]>

  export type AgencyMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agencyId" | "status" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["agencyMember"]>
  export type AgencyMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
    createdProperties?: boolean | AgencyMember$createdPropertiesArgs<ExtArgs>
    agencyClientNotes?: boolean | AgencyMember$agencyClientNotesArgs<ExtArgs>
    agencyClient?: boolean | AgencyMember$agencyClientArgs<ExtArgs>
    AgencyClientPreference?: boolean | AgencyMember$AgencyClientPreferenceArgs<ExtArgs>
    reminders?: boolean | AgencyMember$remindersArgs<ExtArgs>
    _count?: boolean | AgencyMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
  }
  export type AgencyMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyMember$agencyArgs<ExtArgs>
  }

  export type $AgencyMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      createdProperties: Prisma.$PropertyPayload<ExtArgs>[]
      agencyClientNotes: Prisma.$AgencyClientNotesPayload<ExtArgs>[]
      agencyClient: Prisma.$AgencyClientPayload<ExtArgs>[]
      AgencyClientPreference: Prisma.$AgencyClientPreferencePayload<ExtArgs>[]
      reminders: Prisma.$AgentReminderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agencyId: string | null
      status: $Enums.AgencyMemberStatus | null
      role: $Enums.AgencyMemberRole
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["agencyMember"]>
    composites: {}
  }

  type AgencyMemberGetPayload<S extends boolean | null | undefined | AgencyMemberDefaultArgs> = $Result.GetResult<Prisma.$AgencyMemberPayload, S>

  type AgencyMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyMemberCountAggregateInputType | true
    }

  export interface AgencyMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyMember'], meta: { name: 'AgencyMember' } }
    /**
     * Find zero or one AgencyMember that matches the filter.
     * @param {AgencyMemberFindUniqueArgs} args - Arguments to find a AgencyMember
     * @example
     * // Get one AgencyMember
     * const agencyMember = await prisma.agencyMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyMemberFindUniqueArgs>(args: SelectSubset<T, AgencyMemberFindUniqueArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyMemberFindUniqueOrThrowArgs} args - Arguments to find a AgencyMember
     * @example
     * // Get one AgencyMember
     * const agencyMember = await prisma.agencyMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberFindFirstArgs} args - Arguments to find a AgencyMember
     * @example
     * // Get one AgencyMember
     * const agencyMember = await prisma.agencyMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyMemberFindFirstArgs>(args?: SelectSubset<T, AgencyMemberFindFirstArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberFindFirstOrThrowArgs} args - Arguments to find a AgencyMember
     * @example
     * // Get one AgencyMember
     * const agencyMember = await prisma.agencyMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyMembers
     * const agencyMembers = await prisma.agencyMember.findMany()
     * 
     * // Get first 10 AgencyMembers
     * const agencyMembers = await prisma.agencyMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyMemberWithIdOnly = await prisma.agencyMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyMemberFindManyArgs>(args?: SelectSubset<T, AgencyMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyMember.
     * @param {AgencyMemberCreateArgs} args - Arguments to create a AgencyMember.
     * @example
     * // Create one AgencyMember
     * const AgencyMember = await prisma.agencyMember.create({
     *   data: {
     *     // ... data to create a AgencyMember
     *   }
     * })
     * 
     */
    create<T extends AgencyMemberCreateArgs>(args: SelectSubset<T, AgencyMemberCreateArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyMembers.
     * @param {AgencyMemberCreateManyArgs} args - Arguments to create many AgencyMembers.
     * @example
     * // Create many AgencyMembers
     * const agencyMember = await prisma.agencyMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyMemberCreateManyArgs>(args?: SelectSubset<T, AgencyMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyMembers and returns the data saved in the database.
     * @param {AgencyMemberCreateManyAndReturnArgs} args - Arguments to create many AgencyMembers.
     * @example
     * // Create many AgencyMembers
     * const agencyMember = await prisma.agencyMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyMembers and only return the `id`
     * const agencyMemberWithIdOnly = await prisma.agencyMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyMember.
     * @param {AgencyMemberDeleteArgs} args - Arguments to delete one AgencyMember.
     * @example
     * // Delete one AgencyMember
     * const AgencyMember = await prisma.agencyMember.delete({
     *   where: {
     *     // ... filter to delete one AgencyMember
     *   }
     * })
     * 
     */
    delete<T extends AgencyMemberDeleteArgs>(args: SelectSubset<T, AgencyMemberDeleteArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyMember.
     * @param {AgencyMemberUpdateArgs} args - Arguments to update one AgencyMember.
     * @example
     * // Update one AgencyMember
     * const agencyMember = await prisma.agencyMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyMemberUpdateArgs>(args: SelectSubset<T, AgencyMemberUpdateArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyMembers.
     * @param {AgencyMemberDeleteManyArgs} args - Arguments to filter AgencyMembers to delete.
     * @example
     * // Delete a few AgencyMembers
     * const { count } = await prisma.agencyMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyMemberDeleteManyArgs>(args?: SelectSubset<T, AgencyMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyMembers
     * const agencyMember = await prisma.agencyMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyMemberUpdateManyArgs>(args: SelectSubset<T, AgencyMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyMembers and returns the data updated in the database.
     * @param {AgencyMemberUpdateManyAndReturnArgs} args - Arguments to update many AgencyMembers.
     * @example
     * // Update many AgencyMembers
     * const agencyMember = await prisma.agencyMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyMembers and only return the `id`
     * const agencyMemberWithIdOnly = await prisma.agencyMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyMember.
     * @param {AgencyMemberUpsertArgs} args - Arguments to update or create a AgencyMember.
     * @example
     * // Update or create a AgencyMember
     * const agencyMember = await prisma.agencyMember.upsert({
     *   create: {
     *     // ... data to create a AgencyMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyMember we want to update
     *   }
     * })
     */
    upsert<T extends AgencyMemberUpsertArgs>(args: SelectSubset<T, AgencyMemberUpsertArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberCountArgs} args - Arguments to filter AgencyMembers to count.
     * @example
     * // Count the number of AgencyMembers
     * const count = await prisma.agencyMember.count({
     *   where: {
     *     // ... the filter for the AgencyMembers we want to count
     *   }
     * })
    **/
    count<T extends AgencyMemberCountArgs>(
      args?: Subset<T, AgencyMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyMemberAggregateArgs>(args: Subset<T, AgencyMemberAggregateArgs>): Prisma.PrismaPromise<GetAgencyMemberAggregateType<T>>

    /**
     * Group by AgencyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyMemberGroupByArgs['orderBy'] }
        : { orderBy?: AgencyMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyMember model
   */
  readonly fields: AgencyMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyMember$agencyArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdProperties<T extends AgencyMember$createdPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$createdPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyClientNotes<T extends AgencyMember$agencyClientNotesArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$agencyClientNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientNotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyClient<T extends AgencyMember$agencyClientArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$agencyClientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgencyClientPreference<T extends AgencyMember$AgencyClientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$AgencyClientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyClientPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends AgencyMember$remindersArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMember$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyMember model
   */
  interface AgencyMemberFieldRefs {
    readonly id: FieldRef<"AgencyMember", 'String'>
    readonly userId: FieldRef<"AgencyMember", 'String'>
    readonly agencyId: FieldRef<"AgencyMember", 'String'>
    readonly status: FieldRef<"AgencyMember", 'AgencyMemberStatus'>
    readonly role: FieldRef<"AgencyMember", 'AgencyMemberRole'>
    readonly createdAt: FieldRef<"AgencyMember", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyMember findUnique
   */
  export type AgencyMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter, which AgencyMember to fetch.
     */
    where: AgencyMemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember findUniqueOrThrow
   */
  export type AgencyMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter, which AgencyMember to fetch.
     */
    where: AgencyMemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember findFirst
   */
  export type AgencyMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter, which AgencyMember to fetch.
     */
    where?: AgencyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyMembers to fetch.
     */
    orderBy?: AgencyMemberOrderByWithRelationInput | AgencyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyMembers.
     */
    cursor?: AgencyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyMembers.
     */
    distinct?: AgencyMemberScalarFieldEnum | AgencyMemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember findFirstOrThrow
   */
  export type AgencyMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter, which AgencyMember to fetch.
     */
    where?: AgencyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyMembers to fetch.
     */
    orderBy?: AgencyMemberOrderByWithRelationInput | AgencyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyMembers.
     */
    cursor?: AgencyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyMembers.
     */
    distinct?: AgencyMemberScalarFieldEnum | AgencyMemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember findMany
   */
  export type AgencyMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter, which AgencyMembers to fetch.
     */
    where?: AgencyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyMembers to fetch.
     */
    orderBy?: AgencyMemberOrderByWithRelationInput | AgencyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyMembers.
     */
    cursor?: AgencyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyMembers.
     */
    skip?: number
    distinct?: AgencyMemberScalarFieldEnum | AgencyMemberScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember create
   */
  export type AgencyMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyMember.
     */
    data: XOR<AgencyMemberCreateInput, AgencyMemberUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember createMany
   */
  export type AgencyMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyMembers.
     */
    data: AgencyMemberCreateManyInput | AgencyMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyMember createManyAndReturn
   */
  export type AgencyMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyMembers.
     */
    data: AgencyMemberCreateManyInput | AgencyMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyMember update
   */
  export type AgencyMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyMember.
     */
    data: XOR<AgencyMemberUpdateInput, AgencyMemberUncheckedUpdateInput>
    /**
     * Choose, which AgencyMember to update.
     */
    where: AgencyMemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember updateMany
   */
  export type AgencyMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyMembers.
     */
    data: XOR<AgencyMemberUpdateManyMutationInput, AgencyMemberUncheckedUpdateManyInput>
    /**
     * Filter which AgencyMembers to update
     */
    where?: AgencyMemberWhereInput
    /**
     * Limit how many AgencyMembers to update.
     */
    limit?: number
  }

  /**
   * AgencyMember updateManyAndReturn
   */
  export type AgencyMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * The data used to update AgencyMembers.
     */
    data: XOR<AgencyMemberUpdateManyMutationInput, AgencyMemberUncheckedUpdateManyInput>
    /**
     * Filter which AgencyMembers to update
     */
    where?: AgencyMemberWhereInput
    /**
     * Limit how many AgencyMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyMember upsert
   */
  export type AgencyMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyMember to update in case it exists.
     */
    where: AgencyMemberWhereUniqueInput
    /**
     * In case the AgencyMember found by the `where` argument doesn't exist, create a new AgencyMember with this data.
     */
    create: XOR<AgencyMemberCreateInput, AgencyMemberUncheckedCreateInput>
    /**
     * In case the AgencyMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyMemberUpdateInput, AgencyMemberUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember delete
   */
  export type AgencyMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    /**
     * Filter which AgencyMember to delete.
     */
    where: AgencyMemberWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyMember deleteMany
   */
  export type AgencyMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyMembers to delete
     */
    where?: AgencyMemberWhereInput
    /**
     * Limit how many AgencyMembers to delete.
     */
    limit?: number
  }

  /**
   * AgencyMember.agency
   */
  export type AgencyMember$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AgencyMember.createdProperties
   */
  export type AgencyMember$createdPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * AgencyMember.agencyClientNotes
   */
  export type AgencyMember$agencyClientNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientNotes
     */
    select?: AgencyClientNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientNotes
     */
    omit?: AgencyClientNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientNotesInclude<ExtArgs> | null
    where?: AgencyClientNotesWhereInput
    orderBy?: AgencyClientNotesOrderByWithRelationInput | AgencyClientNotesOrderByWithRelationInput[]
    cursor?: AgencyClientNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientNotesScalarFieldEnum | AgencyClientNotesScalarFieldEnum[]
  }

  /**
   * AgencyMember.agencyClient
   */
  export type AgencyMember$agencyClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    where?: AgencyClientWhereInput
    orderBy?: AgencyClientOrderByWithRelationInput | AgencyClientOrderByWithRelationInput[]
    cursor?: AgencyClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientScalarFieldEnum | AgencyClientScalarFieldEnum[]
  }

  /**
   * AgencyMember.AgencyClientPreference
   */
  export type AgencyMember$AgencyClientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClientPreference
     */
    select?: AgencyClientPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClientPreference
     */
    omit?: AgencyClientPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientPreferenceInclude<ExtArgs> | null
    where?: AgencyClientPreferenceWhereInput
    orderBy?: AgencyClientPreferenceOrderByWithRelationInput | AgencyClientPreferenceOrderByWithRelationInput[]
    cursor?: AgencyClientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyClientPreferenceScalarFieldEnum | AgencyClientPreferenceScalarFieldEnum[]
  }

  /**
   * AgencyMember.reminders
   */
  export type AgencyMember$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    where?: AgentReminderWhereInput
    orderBy?: AgentReminderOrderByWithRelationInput | AgentReminderOrderByWithRelationInput[]
    cursor?: AgentReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentReminderScalarFieldEnum | AgentReminderScalarFieldEnum[]
  }

  /**
   * AgencyMember without action
   */
  export type AgencyMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
  }


  /**
   * Model AgencyInvitation
   */

  export type AggregateAgencyInvitation = {
    _count: AgencyInvitationCountAggregateOutputType | null
    _min: AgencyInvitationMinAggregateOutputType | null
    _max: AgencyInvitationMaxAggregateOutputType | null
  }

  export type AgencyInvitationMinAggregateOutputType = {
    id: string | null
    token: string | null
    agencyId: string | null
    email: string | null
    senderId: string | null
    status: $Enums.AgencyInvitationStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyInvitationMaxAggregateOutputType = {
    id: string | null
    token: string | null
    agencyId: string | null
    email: string | null
    senderId: string | null
    status: $Enums.AgencyInvitationStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyInvitationCountAggregateOutputType = {
    id: number
    token: number
    agencyId: number
    email: number
    senderId: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyInvitationMinAggregateInputType = {
    id?: true
    token?: true
    agencyId?: true
    email?: true
    senderId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyInvitationMaxAggregateInputType = {
    id?: true
    token?: true
    agencyId?: true
    email?: true
    senderId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyInvitationCountAggregateInputType = {
    id?: true
    token?: true
    agencyId?: true
    email?: true
    senderId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyInvitation to aggregate.
     */
    where?: AgencyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyInvitations to fetch.
     */
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyInvitations
    **/
    _count?: true | AgencyInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyInvitationMaxAggregateInputType
  }

  export type GetAgencyInvitationAggregateType<T extends AgencyInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyInvitation[P]>
      : GetScalarType<T[P], AggregateAgencyInvitation[P]>
  }




  export type AgencyInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyInvitationWhereInput
    orderBy?: AgencyInvitationOrderByWithAggregationInput | AgencyInvitationOrderByWithAggregationInput[]
    by: AgencyInvitationScalarFieldEnum[] | AgencyInvitationScalarFieldEnum
    having?: AgencyInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyInvitationCountAggregateInputType | true
    _min?: AgencyInvitationMinAggregateInputType
    _max?: AgencyInvitationMaxAggregateInputType
  }

  export type AgencyInvitationGroupByOutputType = {
    id: string
    token: string
    agencyId: string
    email: string
    senderId: string
    status: $Enums.AgencyInvitationStatus
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AgencyInvitationCountAggregateOutputType | null
    _min: AgencyInvitationMinAggregateOutputType | null
    _max: AgencyInvitationMaxAggregateOutputType | null
  }

  type GetAgencyInvitationGroupByPayload<T extends AgencyInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyInvitationGroupByOutputType[P]>
        }
      >
    >


  export type AgencyInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    agencyId?: boolean
    email?: boolean
    senderId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyInvitation"]>

  export type AgencyInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    agencyId?: boolean
    email?: boolean
    senderId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyInvitation"]>

  export type AgencyInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    agencyId?: boolean
    email?: boolean
    senderId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyInvitation"]>

  export type AgencyInvitationSelectScalar = {
    id?: boolean
    token?: boolean
    agencyId?: boolean
    email?: boolean
    senderId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "agencyId" | "email" | "senderId" | "status" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["agencyInvitation"]>
  export type AgencyInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgencyInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgencyInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgencyInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyInvitation"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      agencyId: string
      email: string
      senderId: string
      status: $Enums.AgencyInvitationStatus
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyInvitation"]>
    composites: {}
  }

  type AgencyInvitationGetPayload<S extends boolean | null | undefined | AgencyInvitationDefaultArgs> = $Result.GetResult<Prisma.$AgencyInvitationPayload, S>

  type AgencyInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyInvitationCountAggregateInputType | true
    }

  export interface AgencyInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyInvitation'], meta: { name: 'AgencyInvitation' } }
    /**
     * Find zero or one AgencyInvitation that matches the filter.
     * @param {AgencyInvitationFindUniqueArgs} args - Arguments to find a AgencyInvitation
     * @example
     * // Get one AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyInvitationFindUniqueArgs>(args: SelectSubset<T, AgencyInvitationFindUniqueArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyInvitationFindUniqueOrThrowArgs} args - Arguments to find a AgencyInvitation
     * @example
     * // Get one AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationFindFirstArgs} args - Arguments to find a AgencyInvitation
     * @example
     * // Get one AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyInvitationFindFirstArgs>(args?: SelectSubset<T, AgencyInvitationFindFirstArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationFindFirstOrThrowArgs} args - Arguments to find a AgencyInvitation
     * @example
     * // Get one AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyInvitations
     * const agencyInvitations = await prisma.agencyInvitation.findMany()
     * 
     * // Get first 10 AgencyInvitations
     * const agencyInvitations = await prisma.agencyInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyInvitationWithIdOnly = await prisma.agencyInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyInvitationFindManyArgs>(args?: SelectSubset<T, AgencyInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyInvitation.
     * @param {AgencyInvitationCreateArgs} args - Arguments to create a AgencyInvitation.
     * @example
     * // Create one AgencyInvitation
     * const AgencyInvitation = await prisma.agencyInvitation.create({
     *   data: {
     *     // ... data to create a AgencyInvitation
     *   }
     * })
     * 
     */
    create<T extends AgencyInvitationCreateArgs>(args: SelectSubset<T, AgencyInvitationCreateArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyInvitations.
     * @param {AgencyInvitationCreateManyArgs} args - Arguments to create many AgencyInvitations.
     * @example
     * // Create many AgencyInvitations
     * const agencyInvitation = await prisma.agencyInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyInvitationCreateManyArgs>(args?: SelectSubset<T, AgencyInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyInvitations and returns the data saved in the database.
     * @param {AgencyInvitationCreateManyAndReturnArgs} args - Arguments to create many AgencyInvitations.
     * @example
     * // Create many AgencyInvitations
     * const agencyInvitation = await prisma.agencyInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyInvitations and only return the `id`
     * const agencyInvitationWithIdOnly = await prisma.agencyInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyInvitation.
     * @param {AgencyInvitationDeleteArgs} args - Arguments to delete one AgencyInvitation.
     * @example
     * // Delete one AgencyInvitation
     * const AgencyInvitation = await prisma.agencyInvitation.delete({
     *   where: {
     *     // ... filter to delete one AgencyInvitation
     *   }
     * })
     * 
     */
    delete<T extends AgencyInvitationDeleteArgs>(args: SelectSubset<T, AgencyInvitationDeleteArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyInvitation.
     * @param {AgencyInvitationUpdateArgs} args - Arguments to update one AgencyInvitation.
     * @example
     * // Update one AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyInvitationUpdateArgs>(args: SelectSubset<T, AgencyInvitationUpdateArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyInvitations.
     * @param {AgencyInvitationDeleteManyArgs} args - Arguments to filter AgencyInvitations to delete.
     * @example
     * // Delete a few AgencyInvitations
     * const { count } = await prisma.agencyInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyInvitationDeleteManyArgs>(args?: SelectSubset<T, AgencyInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyInvitations
     * const agencyInvitation = await prisma.agencyInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyInvitationUpdateManyArgs>(args: SelectSubset<T, AgencyInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyInvitations and returns the data updated in the database.
     * @param {AgencyInvitationUpdateManyAndReturnArgs} args - Arguments to update many AgencyInvitations.
     * @example
     * // Update many AgencyInvitations
     * const agencyInvitation = await prisma.agencyInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyInvitations and only return the `id`
     * const agencyInvitationWithIdOnly = await prisma.agencyInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyInvitation.
     * @param {AgencyInvitationUpsertArgs} args - Arguments to update or create a AgencyInvitation.
     * @example
     * // Update or create a AgencyInvitation
     * const agencyInvitation = await prisma.agencyInvitation.upsert({
     *   create: {
     *     // ... data to create a AgencyInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyInvitation we want to update
     *   }
     * })
     */
    upsert<T extends AgencyInvitationUpsertArgs>(args: SelectSubset<T, AgencyInvitationUpsertArgs<ExtArgs>>): Prisma__AgencyInvitationClient<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationCountArgs} args - Arguments to filter AgencyInvitations to count.
     * @example
     * // Count the number of AgencyInvitations
     * const count = await prisma.agencyInvitation.count({
     *   where: {
     *     // ... the filter for the AgencyInvitations we want to count
     *   }
     * })
    **/
    count<T extends AgencyInvitationCountArgs>(
      args?: Subset<T, AgencyInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyInvitationAggregateArgs>(args: Subset<T, AgencyInvitationAggregateArgs>): Prisma.PrismaPromise<GetAgencyInvitationAggregateType<T>>

    /**
     * Group by AgencyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyInvitationGroupByArgs['orderBy'] }
        : { orderBy?: AgencyInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyInvitation model
   */
  readonly fields: AgencyInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyInvitation model
   */
  interface AgencyInvitationFieldRefs {
    readonly id: FieldRef<"AgencyInvitation", 'String'>
    readonly token: FieldRef<"AgencyInvitation", 'String'>
    readonly agencyId: FieldRef<"AgencyInvitation", 'String'>
    readonly email: FieldRef<"AgencyInvitation", 'String'>
    readonly senderId: FieldRef<"AgencyInvitation", 'String'>
    readonly status: FieldRef<"AgencyInvitation", 'AgencyInvitationStatus'>
    readonly expiresAt: FieldRef<"AgencyInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"AgencyInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyInvitation findUnique
   */
  export type AgencyInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AgencyInvitation to fetch.
     */
    where: AgencyInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation findUniqueOrThrow
   */
  export type AgencyInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AgencyInvitation to fetch.
     */
    where: AgencyInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation findFirst
   */
  export type AgencyInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AgencyInvitation to fetch.
     */
    where?: AgencyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyInvitations to fetch.
     */
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyInvitations.
     */
    cursor?: AgencyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyInvitations.
     */
    distinct?: AgencyInvitationScalarFieldEnum | AgencyInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation findFirstOrThrow
   */
  export type AgencyInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AgencyInvitation to fetch.
     */
    where?: AgencyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyInvitations to fetch.
     */
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyInvitations.
     */
    cursor?: AgencyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyInvitations.
     */
    distinct?: AgencyInvitationScalarFieldEnum | AgencyInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation findMany
   */
  export type AgencyInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which AgencyInvitations to fetch.
     */
    where?: AgencyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyInvitations to fetch.
     */
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyInvitations.
     */
    cursor?: AgencyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyInvitations.
     */
    skip?: number
    distinct?: AgencyInvitationScalarFieldEnum | AgencyInvitationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation create
   */
  export type AgencyInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyInvitation.
     */
    data: XOR<AgencyInvitationCreateInput, AgencyInvitationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation createMany
   */
  export type AgencyInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyInvitations.
     */
    data: AgencyInvitationCreateManyInput | AgencyInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyInvitation createManyAndReturn
   */
  export type AgencyInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyInvitations.
     */
    data: AgencyInvitationCreateManyInput | AgencyInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyInvitation update
   */
  export type AgencyInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyInvitation.
     */
    data: XOR<AgencyInvitationUpdateInput, AgencyInvitationUncheckedUpdateInput>
    /**
     * Choose, which AgencyInvitation to update.
     */
    where: AgencyInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation updateMany
   */
  export type AgencyInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyInvitations.
     */
    data: XOR<AgencyInvitationUpdateManyMutationInput, AgencyInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AgencyInvitations to update
     */
    where?: AgencyInvitationWhereInput
    /**
     * Limit how many AgencyInvitations to update.
     */
    limit?: number
  }

  /**
   * AgencyInvitation updateManyAndReturn
   */
  export type AgencyInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * The data used to update AgencyInvitations.
     */
    data: XOR<AgencyInvitationUpdateManyMutationInput, AgencyInvitationUncheckedUpdateManyInput>
    /**
     * Filter which AgencyInvitations to update
     */
    where?: AgencyInvitationWhereInput
    /**
     * Limit how many AgencyInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyInvitation upsert
   */
  export type AgencyInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyInvitation to update in case it exists.
     */
    where: AgencyInvitationWhereUniqueInput
    /**
     * In case the AgencyInvitation found by the `where` argument doesn't exist, create a new AgencyInvitation with this data.
     */
    create: XOR<AgencyInvitationCreateInput, AgencyInvitationUncheckedCreateInput>
    /**
     * In case the AgencyInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyInvitationUpdateInput, AgencyInvitationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation delete
   */
  export type AgencyInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    /**
     * Filter which AgencyInvitation to delete.
     */
    where: AgencyInvitationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyInvitation deleteMany
   */
  export type AgencyInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyInvitations to delete
     */
    where?: AgencyInvitationWhereInput
    /**
     * Limit how many AgencyInvitations to delete.
     */
    limit?: number
  }

  /**
   * AgencyInvitation without action
   */
  export type AgencyInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
  }


  /**
   * Model AgencySubmissionReview
   */

  export type AggregateAgencySubmissionReview = {
    _count: AgencySubmissionReviewCountAggregateOutputType | null
    _min: AgencySubmissionReviewMinAggregateOutputType | null
    _max: AgencySubmissionReviewMaxAggregateOutputType | null
  }

  export type AgencySubmissionReviewMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencySubmissionReviewMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencySubmissionReviewCountAggregateOutputType = {
    id: number
    agencyId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencySubmissionReviewMinAggregateInputType = {
    id?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencySubmissionReviewMaxAggregateInputType = {
    id?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencySubmissionReviewCountAggregateInputType = {
    id?: true
    agencyId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencySubmissionReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySubmissionReview to aggregate.
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySubmissionReviews to fetch.
     */
    orderBy?: AgencySubmissionReviewOrderByWithRelationInput | AgencySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencySubmissionReviews
    **/
    _count?: true | AgencySubmissionReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencySubmissionReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencySubmissionReviewMaxAggregateInputType
  }

  export type GetAgencySubmissionReviewAggregateType<T extends AgencySubmissionReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencySubmissionReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencySubmissionReview[P]>
      : GetScalarType<T[P], AggregateAgencySubmissionReview[P]>
  }




  export type AgencySubmissionReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySubmissionReviewWhereInput
    orderBy?: AgencySubmissionReviewOrderByWithAggregationInput | AgencySubmissionReviewOrderByWithAggregationInput[]
    by: AgencySubmissionReviewScalarFieldEnum[] | AgencySubmissionReviewScalarFieldEnum
    having?: AgencySubmissionReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencySubmissionReviewCountAggregateInputType | true
    _min?: AgencySubmissionReviewMinAggregateInputType
    _max?: AgencySubmissionReviewMaxAggregateInputType
  }

  export type AgencySubmissionReviewGroupByOutputType = {
    id: string
    agencyId: string
    title: JsonValue
    description: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AgencySubmissionReviewCountAggregateOutputType | null
    _min: AgencySubmissionReviewMinAggregateOutputType | null
    _max: AgencySubmissionReviewMaxAggregateOutputType | null
  }

  type GetAgencySubmissionReviewGroupByPayload<T extends AgencySubmissionReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencySubmissionReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencySubmissionReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencySubmissionReviewGroupByOutputType[P]>
            : GetScalarType<T[P], AgencySubmissionReviewGroupByOutputType[P]>
        }
      >
    >


  export type AgencySubmissionReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencySubmissionReview"]>

  export type AgencySubmissionReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencySubmissionReview"]>

  export type AgencySubmissionReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencySubmissionReview"]>

  export type AgencySubmissionReviewSelectScalar = {
    id?: boolean
    agencyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencySubmissionReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agencyId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["agencySubmissionReview"]>
  export type AgencySubmissionReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencySubmissionReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type AgencySubmissionReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $AgencySubmissionReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencySubmissionReview"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string
      title: Prisma.JsonValue
      description: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencySubmissionReview"]>
    composites: {}
  }

  type AgencySubmissionReviewGetPayload<S extends boolean | null | undefined | AgencySubmissionReviewDefaultArgs> = $Result.GetResult<Prisma.$AgencySubmissionReviewPayload, S>

  type AgencySubmissionReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencySubmissionReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencySubmissionReviewCountAggregateInputType | true
    }

  export interface AgencySubmissionReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencySubmissionReview'], meta: { name: 'AgencySubmissionReview' } }
    /**
     * Find zero or one AgencySubmissionReview that matches the filter.
     * @param {AgencySubmissionReviewFindUniqueArgs} args - Arguments to find a AgencySubmissionReview
     * @example
     * // Get one AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencySubmissionReviewFindUniqueArgs>(args: SelectSubset<T, AgencySubmissionReviewFindUniqueArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencySubmissionReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencySubmissionReviewFindUniqueOrThrowArgs} args - Arguments to find a AgencySubmissionReview
     * @example
     * // Get one AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencySubmissionReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencySubmissionReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySubmissionReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewFindFirstArgs} args - Arguments to find a AgencySubmissionReview
     * @example
     * // Get one AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencySubmissionReviewFindFirstArgs>(args?: SelectSubset<T, AgencySubmissionReviewFindFirstArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySubmissionReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewFindFirstOrThrowArgs} args - Arguments to find a AgencySubmissionReview
     * @example
     * // Get one AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencySubmissionReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencySubmissionReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencySubmissionReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencySubmissionReviews
     * const agencySubmissionReviews = await prisma.agencySubmissionReview.findMany()
     * 
     * // Get first 10 AgencySubmissionReviews
     * const agencySubmissionReviews = await prisma.agencySubmissionReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencySubmissionReviewWithIdOnly = await prisma.agencySubmissionReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencySubmissionReviewFindManyArgs>(args?: SelectSubset<T, AgencySubmissionReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencySubmissionReview.
     * @param {AgencySubmissionReviewCreateArgs} args - Arguments to create a AgencySubmissionReview.
     * @example
     * // Create one AgencySubmissionReview
     * const AgencySubmissionReview = await prisma.agencySubmissionReview.create({
     *   data: {
     *     // ... data to create a AgencySubmissionReview
     *   }
     * })
     * 
     */
    create<T extends AgencySubmissionReviewCreateArgs>(args: SelectSubset<T, AgencySubmissionReviewCreateArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencySubmissionReviews.
     * @param {AgencySubmissionReviewCreateManyArgs} args - Arguments to create many AgencySubmissionReviews.
     * @example
     * // Create many AgencySubmissionReviews
     * const agencySubmissionReview = await prisma.agencySubmissionReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencySubmissionReviewCreateManyArgs>(args?: SelectSubset<T, AgencySubmissionReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencySubmissionReviews and returns the data saved in the database.
     * @param {AgencySubmissionReviewCreateManyAndReturnArgs} args - Arguments to create many AgencySubmissionReviews.
     * @example
     * // Create many AgencySubmissionReviews
     * const agencySubmissionReview = await prisma.agencySubmissionReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencySubmissionReviews and only return the `id`
     * const agencySubmissionReviewWithIdOnly = await prisma.agencySubmissionReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencySubmissionReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencySubmissionReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencySubmissionReview.
     * @param {AgencySubmissionReviewDeleteArgs} args - Arguments to delete one AgencySubmissionReview.
     * @example
     * // Delete one AgencySubmissionReview
     * const AgencySubmissionReview = await prisma.agencySubmissionReview.delete({
     *   where: {
     *     // ... filter to delete one AgencySubmissionReview
     *   }
     * })
     * 
     */
    delete<T extends AgencySubmissionReviewDeleteArgs>(args: SelectSubset<T, AgencySubmissionReviewDeleteArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencySubmissionReview.
     * @param {AgencySubmissionReviewUpdateArgs} args - Arguments to update one AgencySubmissionReview.
     * @example
     * // Update one AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencySubmissionReviewUpdateArgs>(args: SelectSubset<T, AgencySubmissionReviewUpdateArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencySubmissionReviews.
     * @param {AgencySubmissionReviewDeleteManyArgs} args - Arguments to filter AgencySubmissionReviews to delete.
     * @example
     * // Delete a few AgencySubmissionReviews
     * const { count } = await prisma.agencySubmissionReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencySubmissionReviewDeleteManyArgs>(args?: SelectSubset<T, AgencySubmissionReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySubmissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencySubmissionReviews
     * const agencySubmissionReview = await prisma.agencySubmissionReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencySubmissionReviewUpdateManyArgs>(args: SelectSubset<T, AgencySubmissionReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySubmissionReviews and returns the data updated in the database.
     * @param {AgencySubmissionReviewUpdateManyAndReturnArgs} args - Arguments to update many AgencySubmissionReviews.
     * @example
     * // Update many AgencySubmissionReviews
     * const agencySubmissionReview = await prisma.agencySubmissionReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencySubmissionReviews and only return the `id`
     * const agencySubmissionReviewWithIdOnly = await prisma.agencySubmissionReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencySubmissionReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencySubmissionReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencySubmissionReview.
     * @param {AgencySubmissionReviewUpsertArgs} args - Arguments to update or create a AgencySubmissionReview.
     * @example
     * // Update or create a AgencySubmissionReview
     * const agencySubmissionReview = await prisma.agencySubmissionReview.upsert({
     *   create: {
     *     // ... data to create a AgencySubmissionReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencySubmissionReview we want to update
     *   }
     * })
     */
    upsert<T extends AgencySubmissionReviewUpsertArgs>(args: SelectSubset<T, AgencySubmissionReviewUpsertArgs<ExtArgs>>): Prisma__AgencySubmissionReviewClient<$Result.GetResult<Prisma.$AgencySubmissionReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencySubmissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewCountArgs} args - Arguments to filter AgencySubmissionReviews to count.
     * @example
     * // Count the number of AgencySubmissionReviews
     * const count = await prisma.agencySubmissionReview.count({
     *   where: {
     *     // ... the filter for the AgencySubmissionReviews we want to count
     *   }
     * })
    **/
    count<T extends AgencySubmissionReviewCountArgs>(
      args?: Subset<T, AgencySubmissionReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencySubmissionReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencySubmissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencySubmissionReviewAggregateArgs>(args: Subset<T, AgencySubmissionReviewAggregateArgs>): Prisma.PrismaPromise<GetAgencySubmissionReviewAggregateType<T>>

    /**
     * Group by AgencySubmissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySubmissionReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencySubmissionReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencySubmissionReviewGroupByArgs['orderBy'] }
        : { orderBy?: AgencySubmissionReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencySubmissionReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencySubmissionReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencySubmissionReview model
   */
  readonly fields: AgencySubmissionReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencySubmissionReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencySubmissionReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencySubmissionReview model
   */
  interface AgencySubmissionReviewFieldRefs {
    readonly id: FieldRef<"AgencySubmissionReview", 'String'>
    readonly agencyId: FieldRef<"AgencySubmissionReview", 'String'>
    readonly title: FieldRef<"AgencySubmissionReview", 'Json'>
    readonly description: FieldRef<"AgencySubmissionReview", 'Json'>
    readonly createdAt: FieldRef<"AgencySubmissionReview", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencySubmissionReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencySubmissionReview findUnique
   */
  export type AgencySubmissionReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencySubmissionReview to fetch.
     */
    where: AgencySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview findUniqueOrThrow
   */
  export type AgencySubmissionReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencySubmissionReview to fetch.
     */
    where: AgencySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview findFirst
   */
  export type AgencySubmissionReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencySubmissionReview to fetch.
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySubmissionReviews to fetch.
     */
    orderBy?: AgencySubmissionReviewOrderByWithRelationInput | AgencySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySubmissionReviews.
     */
    cursor?: AgencySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySubmissionReviews.
     */
    distinct?: AgencySubmissionReviewScalarFieldEnum | AgencySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview findFirstOrThrow
   */
  export type AgencySubmissionReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencySubmissionReview to fetch.
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySubmissionReviews to fetch.
     */
    orderBy?: AgencySubmissionReviewOrderByWithRelationInput | AgencySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySubmissionReviews.
     */
    cursor?: AgencySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySubmissionReviews.
     */
    distinct?: AgencySubmissionReviewScalarFieldEnum | AgencySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview findMany
   */
  export type AgencySubmissionReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencySubmissionReviews to fetch.
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySubmissionReviews to fetch.
     */
    orderBy?: AgencySubmissionReviewOrderByWithRelationInput | AgencySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencySubmissionReviews.
     */
    cursor?: AgencySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySubmissionReviews.
     */
    skip?: number
    distinct?: AgencySubmissionReviewScalarFieldEnum | AgencySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview create
   */
  export type AgencySubmissionReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencySubmissionReview.
     */
    data: XOR<AgencySubmissionReviewCreateInput, AgencySubmissionReviewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview createMany
   */
  export type AgencySubmissionReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencySubmissionReviews.
     */
    data: AgencySubmissionReviewCreateManyInput | AgencySubmissionReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencySubmissionReview createManyAndReturn
   */
  export type AgencySubmissionReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * The data used to create many AgencySubmissionReviews.
     */
    data: AgencySubmissionReviewCreateManyInput | AgencySubmissionReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySubmissionReview update
   */
  export type AgencySubmissionReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencySubmissionReview.
     */
    data: XOR<AgencySubmissionReviewUpdateInput, AgencySubmissionReviewUncheckedUpdateInput>
    /**
     * Choose, which AgencySubmissionReview to update.
     */
    where: AgencySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview updateMany
   */
  export type AgencySubmissionReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencySubmissionReviews.
     */
    data: XOR<AgencySubmissionReviewUpdateManyMutationInput, AgencySubmissionReviewUncheckedUpdateManyInput>
    /**
     * Filter which AgencySubmissionReviews to update
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * Limit how many AgencySubmissionReviews to update.
     */
    limit?: number
  }

  /**
   * AgencySubmissionReview updateManyAndReturn
   */
  export type AgencySubmissionReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * The data used to update AgencySubmissionReviews.
     */
    data: XOR<AgencySubmissionReviewUpdateManyMutationInput, AgencySubmissionReviewUncheckedUpdateManyInput>
    /**
     * Filter which AgencySubmissionReviews to update
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * Limit how many AgencySubmissionReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySubmissionReview upsert
   */
  export type AgencySubmissionReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencySubmissionReview to update in case it exists.
     */
    where: AgencySubmissionReviewWhereUniqueInput
    /**
     * In case the AgencySubmissionReview found by the `where` argument doesn't exist, create a new AgencySubmissionReview with this data.
     */
    create: XOR<AgencySubmissionReviewCreateInput, AgencySubmissionReviewUncheckedCreateInput>
    /**
     * In case the AgencySubmissionReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencySubmissionReviewUpdateInput, AgencySubmissionReviewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview delete
   */
  export type AgencySubmissionReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter which AgencySubmissionReview to delete.
     */
    where: AgencySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencySubmissionReview deleteMany
   */
  export type AgencySubmissionReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySubmissionReviews to delete
     */
    where?: AgencySubmissionReviewWhereInput
    /**
     * Limit how many AgencySubmissionReviews to delete.
     */
    limit?: number
  }

  /**
   * AgencySubmissionReview without action
   */
  export type AgencySubmissionReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySubmissionReview
     */
    select?: AgencySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySubmissionReview
     */
    omit?: AgencySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySubmissionReviewInclude<ExtArgs> | null
  }


  /**
   * Model AgencyView
   */

  export type AggregateAgencyView = {
    _count: AgencyViewCountAggregateOutputType | null
    _min: AgencyViewMinAggregateOutputType | null
    _max: AgencyViewMaxAggregateOutputType | null
  }

  export type AgencyViewMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    clientId: string | null
    viewDate: Date | null
    updatedAt: Date | null
  }

  export type AgencyViewMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    clientId: string | null
    viewDate: Date | null
    updatedAt: Date | null
  }

  export type AgencyViewCountAggregateOutputType = {
    id: number
    agencyId: number
    clientId: number
    additionalInfo: number
    viewDate: number
    updatedAt: number
    _all: number
  }


  export type AgencyViewMinAggregateInputType = {
    id?: true
    agencyId?: true
    clientId?: true
    viewDate?: true
    updatedAt?: true
  }

  export type AgencyViewMaxAggregateInputType = {
    id?: true
    agencyId?: true
    clientId?: true
    viewDate?: true
    updatedAt?: true
  }

  export type AgencyViewCountAggregateInputType = {
    id?: true
    agencyId?: true
    clientId?: true
    additionalInfo?: true
    viewDate?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyView to aggregate.
     */
    where?: AgencyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyViews to fetch.
     */
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyViews
    **/
    _count?: true | AgencyViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyViewMaxAggregateInputType
  }

  export type GetAgencyViewAggregateType<T extends AgencyViewAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyView[P]>
      : GetScalarType<T[P], AggregateAgencyView[P]>
  }




  export type AgencyViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyViewWhereInput
    orderBy?: AgencyViewOrderByWithAggregationInput | AgencyViewOrderByWithAggregationInput[]
    by: AgencyViewScalarFieldEnum[] | AgencyViewScalarFieldEnum
    having?: AgencyViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyViewCountAggregateInputType | true
    _min?: AgencyViewMinAggregateInputType
    _max?: AgencyViewMaxAggregateInputType
  }

  export type AgencyViewGroupByOutputType = {
    id: string
    agencyId: string
    clientId: string | null
    additionalInfo: JsonValue | null
    viewDate: Date
    updatedAt: Date
    _count: AgencyViewCountAggregateOutputType | null
    _min: AgencyViewMinAggregateOutputType | null
    _max: AgencyViewMaxAggregateOutputType | null
  }

  type GetAgencyViewGroupByPayload<T extends AgencyViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyViewGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyViewGroupByOutputType[P]>
        }
      >
    >


  export type AgencyViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    viewDate?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyView"]>

  export type AgencyViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    viewDate?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyView"]>

  export type AgencyViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    viewDate?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["agencyView"]>

  export type AgencyViewSelectScalar = {
    id?: boolean
    agencyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    viewDate?: boolean
    updatedAt?: boolean
  }

  export type AgencyViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agencyId" | "clientId" | "additionalInfo" | "viewDate" | "updatedAt", ExtArgs["result"]["agencyView"]>
  export type AgencyViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }
  export type AgencyViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }
  export type AgencyViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | AgencyView$clientArgs<ExtArgs>
  }

  export type $AgencyViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyView"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string
      clientId: string | null
      additionalInfo: Prisma.JsonValue | null
      viewDate: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyView"]>
    composites: {}
  }

  type AgencyViewGetPayload<S extends boolean | null | undefined | AgencyViewDefaultArgs> = $Result.GetResult<Prisma.$AgencyViewPayload, S>

  type AgencyViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyViewCountAggregateInputType | true
    }

  export interface AgencyViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyView'], meta: { name: 'AgencyView' } }
    /**
     * Find zero or one AgencyView that matches the filter.
     * @param {AgencyViewFindUniqueArgs} args - Arguments to find a AgencyView
     * @example
     * // Get one AgencyView
     * const agencyView = await prisma.agencyView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyViewFindUniqueArgs>(args: SelectSubset<T, AgencyViewFindUniqueArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyViewFindUniqueOrThrowArgs} args - Arguments to find a AgencyView
     * @example
     * // Get one AgencyView
     * const agencyView = await prisma.agencyView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyViewFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewFindFirstArgs} args - Arguments to find a AgencyView
     * @example
     * // Get one AgencyView
     * const agencyView = await prisma.agencyView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyViewFindFirstArgs>(args?: SelectSubset<T, AgencyViewFindFirstArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewFindFirstOrThrowArgs} args - Arguments to find a AgencyView
     * @example
     * // Get one AgencyView
     * const agencyView = await prisma.agencyView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyViewFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyViews
     * const agencyViews = await prisma.agencyView.findMany()
     * 
     * // Get first 10 AgencyViews
     * const agencyViews = await prisma.agencyView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyViewWithIdOnly = await prisma.agencyView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyViewFindManyArgs>(args?: SelectSubset<T, AgencyViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyView.
     * @param {AgencyViewCreateArgs} args - Arguments to create a AgencyView.
     * @example
     * // Create one AgencyView
     * const AgencyView = await prisma.agencyView.create({
     *   data: {
     *     // ... data to create a AgencyView
     *   }
     * })
     * 
     */
    create<T extends AgencyViewCreateArgs>(args: SelectSubset<T, AgencyViewCreateArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyViews.
     * @param {AgencyViewCreateManyArgs} args - Arguments to create many AgencyViews.
     * @example
     * // Create many AgencyViews
     * const agencyView = await prisma.agencyView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyViewCreateManyArgs>(args?: SelectSubset<T, AgencyViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyViews and returns the data saved in the database.
     * @param {AgencyViewCreateManyAndReturnArgs} args - Arguments to create many AgencyViews.
     * @example
     * // Create many AgencyViews
     * const agencyView = await prisma.agencyView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyViews and only return the `id`
     * const agencyViewWithIdOnly = await prisma.agencyView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyViewCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyView.
     * @param {AgencyViewDeleteArgs} args - Arguments to delete one AgencyView.
     * @example
     * // Delete one AgencyView
     * const AgencyView = await prisma.agencyView.delete({
     *   where: {
     *     // ... filter to delete one AgencyView
     *   }
     * })
     * 
     */
    delete<T extends AgencyViewDeleteArgs>(args: SelectSubset<T, AgencyViewDeleteArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyView.
     * @param {AgencyViewUpdateArgs} args - Arguments to update one AgencyView.
     * @example
     * // Update one AgencyView
     * const agencyView = await prisma.agencyView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyViewUpdateArgs>(args: SelectSubset<T, AgencyViewUpdateArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyViews.
     * @param {AgencyViewDeleteManyArgs} args - Arguments to filter AgencyViews to delete.
     * @example
     * // Delete a few AgencyViews
     * const { count } = await prisma.agencyView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyViewDeleteManyArgs>(args?: SelectSubset<T, AgencyViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyViews
     * const agencyView = await prisma.agencyView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyViewUpdateManyArgs>(args: SelectSubset<T, AgencyViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyViews and returns the data updated in the database.
     * @param {AgencyViewUpdateManyAndReturnArgs} args - Arguments to update many AgencyViews.
     * @example
     * // Update many AgencyViews
     * const agencyView = await prisma.agencyView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyViews and only return the `id`
     * const agencyViewWithIdOnly = await prisma.agencyView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyViewUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyView.
     * @param {AgencyViewUpsertArgs} args - Arguments to update or create a AgencyView.
     * @example
     * // Update or create a AgencyView
     * const agencyView = await prisma.agencyView.upsert({
     *   create: {
     *     // ... data to create a AgencyView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyView we want to update
     *   }
     * })
     */
    upsert<T extends AgencyViewUpsertArgs>(args: SelectSubset<T, AgencyViewUpsertArgs<ExtArgs>>): Prisma__AgencyViewClient<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewCountArgs} args - Arguments to filter AgencyViews to count.
     * @example
     * // Count the number of AgencyViews
     * const count = await prisma.agencyView.count({
     *   where: {
     *     // ... the filter for the AgencyViews we want to count
     *   }
     * })
    **/
    count<T extends AgencyViewCountArgs>(
      args?: Subset<T, AgencyViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyViewAggregateArgs>(args: Subset<T, AgencyViewAggregateArgs>): Prisma.PrismaPromise<GetAgencyViewAggregateType<T>>

    /**
     * Group by AgencyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyViewGroupByArgs['orderBy'] }
        : { orderBy?: AgencyViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyView model
   */
  readonly fields: AgencyViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends AgencyView$clientArgs<ExtArgs> = {}>(args?: Subset<T, AgencyView$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyView model
   */
  interface AgencyViewFieldRefs {
    readonly id: FieldRef<"AgencyView", 'String'>
    readonly agencyId: FieldRef<"AgencyView", 'String'>
    readonly clientId: FieldRef<"AgencyView", 'String'>
    readonly additionalInfo: FieldRef<"AgencyView", 'Json'>
    readonly viewDate: FieldRef<"AgencyView", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyView findUnique
   */
  export type AgencyViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyView to fetch.
     */
    where: AgencyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView findUniqueOrThrow
   */
  export type AgencyViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyView to fetch.
     */
    where: AgencyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView findFirst
   */
  export type AgencyViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyView to fetch.
     */
    where?: AgencyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyViews to fetch.
     */
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyViews.
     */
    cursor?: AgencyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyViews.
     */
    distinct?: AgencyViewScalarFieldEnum | AgencyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView findFirstOrThrow
   */
  export type AgencyViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyView to fetch.
     */
    where?: AgencyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyViews to fetch.
     */
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyViews.
     */
    cursor?: AgencyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyViews.
     */
    distinct?: AgencyViewScalarFieldEnum | AgencyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView findMany
   */
  export type AgencyViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyViews to fetch.
     */
    where?: AgencyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyViews to fetch.
     */
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyViews.
     */
    cursor?: AgencyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyViews.
     */
    skip?: number
    distinct?: AgencyViewScalarFieldEnum | AgencyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView create
   */
  export type AgencyViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyView.
     */
    data: XOR<AgencyViewCreateInput, AgencyViewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView createMany
   */
  export type AgencyViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyViews.
     */
    data: AgencyViewCreateManyInput | AgencyViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyView createManyAndReturn
   */
  export type AgencyViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyViews.
     */
    data: AgencyViewCreateManyInput | AgencyViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyView update
   */
  export type AgencyViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyView.
     */
    data: XOR<AgencyViewUpdateInput, AgencyViewUncheckedUpdateInput>
    /**
     * Choose, which AgencyView to update.
     */
    where: AgencyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView updateMany
   */
  export type AgencyViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyViews.
     */
    data: XOR<AgencyViewUpdateManyMutationInput, AgencyViewUncheckedUpdateManyInput>
    /**
     * Filter which AgencyViews to update
     */
    where?: AgencyViewWhereInput
    /**
     * Limit how many AgencyViews to update.
     */
    limit?: number
  }

  /**
   * AgencyView updateManyAndReturn
   */
  export type AgencyViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * The data used to update AgencyViews.
     */
    data: XOR<AgencyViewUpdateManyMutationInput, AgencyViewUncheckedUpdateManyInput>
    /**
     * Filter which AgencyViews to update
     */
    where?: AgencyViewWhereInput
    /**
     * Limit how many AgencyViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyView upsert
   */
  export type AgencyViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyView to update in case it exists.
     */
    where: AgencyViewWhereUniqueInput
    /**
     * In case the AgencyView found by the `where` argument doesn't exist, create a new AgencyView with this data.
     */
    create: XOR<AgencyViewCreateInput, AgencyViewUncheckedCreateInput>
    /**
     * In case the AgencyView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyViewUpdateInput, AgencyViewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView delete
   */
  export type AgencyViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    /**
     * Filter which AgencyView to delete.
     */
    where: AgencyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyView deleteMany
   */
  export type AgencyViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyViews to delete
     */
    where?: AgencyViewWhereInput
    /**
     * Limit how many AgencyViews to delete.
     */
    limit?: number
  }

  /**
   * AgencyView.client
   */
  export type AgencyView$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * AgencyView without action
   */
  export type AgencyViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
  }


  /**
   * Model AgencyReview
   */

  export type AggregateAgencyReview = {
    _count: AgencyReviewCountAggregateOutputType | null
    _avg: AgencyReviewAvgAggregateOutputType | null
    _sum: AgencyReviewSumAggregateOutputType | null
    _min: AgencyReviewMinAggregateOutputType | null
    _max: AgencyReviewMaxAggregateOutputType | null
  }

  export type AgencyReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type AgencyReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type AgencyReviewMinAggregateOutputType = {
    id: string | null
    approved: boolean | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    agencyId: string | null
    clientId: string | null
  }

  export type AgencyReviewMaxAggregateOutputType = {
    id: string | null
    approved: boolean | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    agencyId: string | null
    clientId: string | null
  }

  export type AgencyReviewCountAggregateOutputType = {
    id: number
    approved: number
    rating: number
    comment: number
    createdAt: number
    attributes: number
    agencyId: number
    clientId: number
    _all: number
  }


  export type AgencyReviewAvgAggregateInputType = {
    rating?: true
  }

  export type AgencyReviewSumAggregateInputType = {
    rating?: true
  }

  export type AgencyReviewMinAggregateInputType = {
    id?: true
    approved?: true
    rating?: true
    comment?: true
    createdAt?: true
    agencyId?: true
    clientId?: true
  }

  export type AgencyReviewMaxAggregateInputType = {
    id?: true
    approved?: true
    rating?: true
    comment?: true
    createdAt?: true
    agencyId?: true
    clientId?: true
  }

  export type AgencyReviewCountAggregateInputType = {
    id?: true
    approved?: true
    rating?: true
    comment?: true
    createdAt?: true
    attributes?: true
    agencyId?: true
    clientId?: true
    _all?: true
  }

  export type AgencyReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyReview to aggregate.
     */
    where?: AgencyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyReviews to fetch.
     */
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyReviews
    **/
    _count?: true | AgencyReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencyReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyReviewMaxAggregateInputType
  }

  export type GetAgencyReviewAggregateType<T extends AgencyReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyReview[P]>
      : GetScalarType<T[P], AggregateAgencyReview[P]>
  }




  export type AgencyReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyReviewWhereInput
    orderBy?: AgencyReviewOrderByWithAggregationInput | AgencyReviewOrderByWithAggregationInput[]
    by: AgencyReviewScalarFieldEnum[] | AgencyReviewScalarFieldEnum
    having?: AgencyReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyReviewCountAggregateInputType | true
    _avg?: AgencyReviewAvgAggregateInputType
    _sum?: AgencyReviewSumAggregateInputType
    _min?: AgencyReviewMinAggregateInputType
    _max?: AgencyReviewMaxAggregateInputType
  }

  export type AgencyReviewGroupByOutputType = {
    id: string
    approved: boolean
    rating: number
    comment: string | null
    createdAt: Date
    attributes: JsonValue | null
    agencyId: string
    clientId: string
    _count: AgencyReviewCountAggregateOutputType | null
    _avg: AgencyReviewAvgAggregateOutputType | null
    _sum: AgencyReviewSumAggregateOutputType | null
    _min: AgencyReviewMinAggregateOutputType | null
    _max: AgencyReviewMaxAggregateOutputType | null
  }

  type GetAgencyReviewGroupByPayload<T extends AgencyReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyReviewGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyReviewGroupByOutputType[P]>
        }
      >
    >


  export type AgencyReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approved?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    attributes?: boolean
    agencyId?: boolean
    clientId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyReview"]>

  export type AgencyReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approved?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    attributes?: boolean
    agencyId?: boolean
    clientId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyReview"]>

  export type AgencyReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approved?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    attributes?: boolean
    agencyId?: boolean
    clientId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyReview"]>

  export type AgencyReviewSelectScalar = {
    id?: boolean
    approved?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    attributes?: boolean
    agencyId?: boolean
    clientId?: boolean
  }

  export type AgencyReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "approved" | "rating" | "comment" | "createdAt" | "attributes" | "agencyId" | "clientId", ExtArgs["result"]["agencyReview"]>
  export type AgencyReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type AgencyReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type AgencyReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $AgencyReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyReview"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      approved: boolean
      rating: number
      comment: string | null
      createdAt: Date
      attributes: Prisma.JsonValue | null
      agencyId: string
      clientId: string
    }, ExtArgs["result"]["agencyReview"]>
    composites: {}
  }

  type AgencyReviewGetPayload<S extends boolean | null | undefined | AgencyReviewDefaultArgs> = $Result.GetResult<Prisma.$AgencyReviewPayload, S>

  type AgencyReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgencyReviewCountAggregateInputType | true
    }

  export interface AgencyReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyReview'], meta: { name: 'AgencyReview' } }
    /**
     * Find zero or one AgencyReview that matches the filter.
     * @param {AgencyReviewFindUniqueArgs} args - Arguments to find a AgencyReview
     * @example
     * // Get one AgencyReview
     * const agencyReview = await prisma.agencyReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyReviewFindUniqueArgs>(args: SelectSubset<T, AgencyReviewFindUniqueArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyReviewFindUniqueOrThrowArgs} args - Arguments to find a AgencyReview
     * @example
     * // Get one AgencyReview
     * const agencyReview = await prisma.agencyReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewFindFirstArgs} args - Arguments to find a AgencyReview
     * @example
     * // Get one AgencyReview
     * const agencyReview = await prisma.agencyReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyReviewFindFirstArgs>(args?: SelectSubset<T, AgencyReviewFindFirstArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewFindFirstOrThrowArgs} args - Arguments to find a AgencyReview
     * @example
     * // Get one AgencyReview
     * const agencyReview = await prisma.agencyReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyReviews
     * const agencyReviews = await prisma.agencyReview.findMany()
     * 
     * // Get first 10 AgencyReviews
     * const agencyReviews = await prisma.agencyReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyReviewWithIdOnly = await prisma.agencyReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyReviewFindManyArgs>(args?: SelectSubset<T, AgencyReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyReview.
     * @param {AgencyReviewCreateArgs} args - Arguments to create a AgencyReview.
     * @example
     * // Create one AgencyReview
     * const AgencyReview = await prisma.agencyReview.create({
     *   data: {
     *     // ... data to create a AgencyReview
     *   }
     * })
     * 
     */
    create<T extends AgencyReviewCreateArgs>(args: SelectSubset<T, AgencyReviewCreateArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyReviews.
     * @param {AgencyReviewCreateManyArgs} args - Arguments to create many AgencyReviews.
     * @example
     * // Create many AgencyReviews
     * const agencyReview = await prisma.agencyReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyReviewCreateManyArgs>(args?: SelectSubset<T, AgencyReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyReviews and returns the data saved in the database.
     * @param {AgencyReviewCreateManyAndReturnArgs} args - Arguments to create many AgencyReviews.
     * @example
     * // Create many AgencyReviews
     * const agencyReview = await prisma.agencyReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyReviews and only return the `id`
     * const agencyReviewWithIdOnly = await prisma.agencyReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyReview.
     * @param {AgencyReviewDeleteArgs} args - Arguments to delete one AgencyReview.
     * @example
     * // Delete one AgencyReview
     * const AgencyReview = await prisma.agencyReview.delete({
     *   where: {
     *     // ... filter to delete one AgencyReview
     *   }
     * })
     * 
     */
    delete<T extends AgencyReviewDeleteArgs>(args: SelectSubset<T, AgencyReviewDeleteArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyReview.
     * @param {AgencyReviewUpdateArgs} args - Arguments to update one AgencyReview.
     * @example
     * // Update one AgencyReview
     * const agencyReview = await prisma.agencyReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyReviewUpdateArgs>(args: SelectSubset<T, AgencyReviewUpdateArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyReviews.
     * @param {AgencyReviewDeleteManyArgs} args - Arguments to filter AgencyReviews to delete.
     * @example
     * // Delete a few AgencyReviews
     * const { count } = await prisma.agencyReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyReviewDeleteManyArgs>(args?: SelectSubset<T, AgencyReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyReviews
     * const agencyReview = await prisma.agencyReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyReviewUpdateManyArgs>(args: SelectSubset<T, AgencyReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyReviews and returns the data updated in the database.
     * @param {AgencyReviewUpdateManyAndReturnArgs} args - Arguments to update many AgencyReviews.
     * @example
     * // Update many AgencyReviews
     * const agencyReview = await prisma.agencyReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyReviews and only return the `id`
     * const agencyReviewWithIdOnly = await prisma.agencyReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyReview.
     * @param {AgencyReviewUpsertArgs} args - Arguments to update or create a AgencyReview.
     * @example
     * // Update or create a AgencyReview
     * const agencyReview = await prisma.agencyReview.upsert({
     *   create: {
     *     // ... data to create a AgencyReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyReview we want to update
     *   }
     * })
     */
    upsert<T extends AgencyReviewUpsertArgs>(args: SelectSubset<T, AgencyReviewUpsertArgs<ExtArgs>>): Prisma__AgencyReviewClient<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewCountArgs} args - Arguments to filter AgencyReviews to count.
     * @example
     * // Count the number of AgencyReviews
     * const count = await prisma.agencyReview.count({
     *   where: {
     *     // ... the filter for the AgencyReviews we want to count
     *   }
     * })
    **/
    count<T extends AgencyReviewCountArgs>(
      args?: Subset<T, AgencyReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyReviewAggregateArgs>(args: Subset<T, AgencyReviewAggregateArgs>): Prisma.PrismaPromise<GetAgencyReviewAggregateType<T>>

    /**
     * Group by AgencyReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyReviewGroupByArgs['orderBy'] }
        : { orderBy?: AgencyReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyReview model
   */
  readonly fields: AgencyReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyReview model
   */
  interface AgencyReviewFieldRefs {
    readonly id: FieldRef<"AgencyReview", 'String'>
    readonly approved: FieldRef<"AgencyReview", 'Boolean'>
    readonly rating: FieldRef<"AgencyReview", 'Float'>
    readonly comment: FieldRef<"AgencyReview", 'String'>
    readonly createdAt: FieldRef<"AgencyReview", 'DateTime'>
    readonly attributes: FieldRef<"AgencyReview", 'Json'>
    readonly agencyId: FieldRef<"AgencyReview", 'String'>
    readonly clientId: FieldRef<"AgencyReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgencyReview findUnique
   */
  export type AgencyReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyReview to fetch.
     */
    where: AgencyReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview findUniqueOrThrow
   */
  export type AgencyReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyReview to fetch.
     */
    where: AgencyReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview findFirst
   */
  export type AgencyReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyReview to fetch.
     */
    where?: AgencyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyReviews to fetch.
     */
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyReviews.
     */
    cursor?: AgencyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyReviews.
     */
    distinct?: AgencyReviewScalarFieldEnum | AgencyReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview findFirstOrThrow
   */
  export type AgencyReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyReview to fetch.
     */
    where?: AgencyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyReviews to fetch.
     */
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyReviews.
     */
    cursor?: AgencyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyReviews.
     */
    distinct?: AgencyReviewScalarFieldEnum | AgencyReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview findMany
   */
  export type AgencyReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter, which AgencyReviews to fetch.
     */
    where?: AgencyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyReviews to fetch.
     */
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyReviews.
     */
    cursor?: AgencyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyReviews.
     */
    skip?: number
    distinct?: AgencyReviewScalarFieldEnum | AgencyReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview create
   */
  export type AgencyReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyReview.
     */
    data: XOR<AgencyReviewCreateInput, AgencyReviewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview createMany
   */
  export type AgencyReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyReviews.
     */
    data: AgencyReviewCreateManyInput | AgencyReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyReview createManyAndReturn
   */
  export type AgencyReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyReviews.
     */
    data: AgencyReviewCreateManyInput | AgencyReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyReview update
   */
  export type AgencyReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyReview.
     */
    data: XOR<AgencyReviewUpdateInput, AgencyReviewUncheckedUpdateInput>
    /**
     * Choose, which AgencyReview to update.
     */
    where: AgencyReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview updateMany
   */
  export type AgencyReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyReviews.
     */
    data: XOR<AgencyReviewUpdateManyMutationInput, AgencyReviewUncheckedUpdateManyInput>
    /**
     * Filter which AgencyReviews to update
     */
    where?: AgencyReviewWhereInput
    /**
     * Limit how many AgencyReviews to update.
     */
    limit?: number
  }

  /**
   * AgencyReview updateManyAndReturn
   */
  export type AgencyReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * The data used to update AgencyReviews.
     */
    data: XOR<AgencyReviewUpdateManyMutationInput, AgencyReviewUncheckedUpdateManyInput>
    /**
     * Filter which AgencyReviews to update
     */
    where?: AgencyReviewWhereInput
    /**
     * Limit how many AgencyReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyReview upsert
   */
  export type AgencyReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyReview to update in case it exists.
     */
    where: AgencyReviewWhereUniqueInput
    /**
     * In case the AgencyReview found by the `where` argument doesn't exist, create a new AgencyReview with this data.
     */
    create: XOR<AgencyReviewCreateInput, AgencyReviewUncheckedCreateInput>
    /**
     * In case the AgencyReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyReviewUpdateInput, AgencyReviewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview delete
   */
  export type AgencyReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    /**
     * Filter which AgencyReview to delete.
     */
    where: AgencyReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgencyReview deleteMany
   */
  export type AgencyReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyReviews to delete
     */
    where?: AgencyReviewWhereInput
    /**
     * Limit how many AgencyReviews to delete.
     */
    limit?: number
  }

  /**
   * AgencyReview without action
   */
  export type AgencyReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
  }


  /**
   * Model AgentReminder
   */

  export type AggregateAgentReminder = {
    _count: AgentReminderCountAggregateOutputType | null
    _min: AgentReminderMinAggregateOutputType | null
    _max: AgentReminderMaxAggregateOutputType | null
  }

  export type AgentReminderMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ReminderStatus | null
    agencyMemberId: string | null
    startDate: Date | null
    isRecurring: boolean | null
    endDate: Date | null
    lastSentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentReminderMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ReminderStatus | null
    agencyMemberId: string | null
    startDate: Date | null
    isRecurring: boolean | null
    endDate: Date | null
    lastSentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentReminderCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    agencyMemberId: number
    startDate: number
    isRecurring: number
    endDate: number
    lastSentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentReminderMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    agencyMemberId?: true
    startDate?: true
    isRecurring?: true
    endDate?: true
    lastSentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentReminderMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    agencyMemberId?: true
    startDate?: true
    isRecurring?: true
    endDate?: true
    lastSentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentReminderCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    agencyMemberId?: true
    startDate?: true
    isRecurring?: true
    endDate?: true
    lastSentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentReminder to aggregate.
     */
    where?: AgentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentReminders to fetch.
     */
    orderBy?: AgentReminderOrderByWithRelationInput | AgentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentReminders
    **/
    _count?: true | AgentReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentReminderMaxAggregateInputType
  }

  export type GetAgentReminderAggregateType<T extends AgentReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentReminder[P]>
      : GetScalarType<T[P], AggregateAgentReminder[P]>
  }




  export type AgentReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentReminderWhereInput
    orderBy?: AgentReminderOrderByWithAggregationInput | AgentReminderOrderByWithAggregationInput[]
    by: AgentReminderScalarFieldEnum[] | AgentReminderScalarFieldEnum
    having?: AgentReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentReminderCountAggregateInputType | true
    _min?: AgentReminderMinAggregateInputType
    _max?: AgentReminderMaxAggregateInputType
  }

  export type AgentReminderGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.ReminderStatus
    agencyMemberId: string
    startDate: Date
    isRecurring: boolean
    endDate: Date | null
    lastSentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AgentReminderCountAggregateOutputType | null
    _min: AgentReminderMinAggregateOutputType | null
    _max: AgentReminderMaxAggregateOutputType | null
  }

  type GetAgentReminderGroupByPayload<T extends AgentReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentReminderGroupByOutputType[P]>
            : GetScalarType<T[P], AgentReminderGroupByOutputType[P]>
        }
      >
    >


  export type AgentReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    agencyMemberId?: boolean
    startDate?: boolean
    isRecurring?: boolean
    endDate?: boolean
    lastSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentReminder"]>

  export type AgentReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    agencyMemberId?: boolean
    startDate?: boolean
    isRecurring?: boolean
    endDate?: boolean
    lastSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentReminder"]>

  export type AgentReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    agencyMemberId?: boolean
    startDate?: boolean
    isRecurring?: boolean
    endDate?: boolean
    lastSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentReminder"]>

  export type AgentReminderSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    agencyMemberId?: boolean
    startDate?: boolean
    isRecurring?: boolean
    endDate?: boolean
    lastSentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "agencyMemberId" | "startDate" | "isRecurring" | "endDate" | "lastSentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["agentReminder"]>
  export type AgentReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }
  export type AgentReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }
  export type AgentReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyMember?: boolean | AgencyMemberDefaultArgs<ExtArgs>
  }

  export type $AgentReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentReminder"
    objects: {
      agencyMember: Prisma.$AgencyMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.ReminderStatus
      agencyMemberId: string
      startDate: Date
      isRecurring: boolean
      endDate: Date | null
      lastSentAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["agentReminder"]>
    composites: {}
  }

  type AgentReminderGetPayload<S extends boolean | null | undefined | AgentReminderDefaultArgs> = $Result.GetResult<Prisma.$AgentReminderPayload, S>

  type AgentReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AgentReminderCountAggregateInputType | true
    }

  export interface AgentReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentReminder'], meta: { name: 'AgentReminder' } }
    /**
     * Find zero or one AgentReminder that matches the filter.
     * @param {AgentReminderFindUniqueArgs} args - Arguments to find a AgentReminder
     * @example
     * // Get one AgentReminder
     * const agentReminder = await prisma.agentReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentReminderFindUniqueArgs>(args: SelectSubset<T, AgentReminderFindUniqueArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentReminderFindUniqueOrThrowArgs} args - Arguments to find a AgentReminder
     * @example
     * // Get one AgentReminder
     * const agentReminder = await prisma.agentReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderFindFirstArgs} args - Arguments to find a AgentReminder
     * @example
     * // Get one AgentReminder
     * const agentReminder = await prisma.agentReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentReminderFindFirstArgs>(args?: SelectSubset<T, AgentReminderFindFirstArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderFindFirstOrThrowArgs} args - Arguments to find a AgentReminder
     * @example
     * // Get one AgentReminder
     * const agentReminder = await prisma.agentReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentReminders
     * const agentReminders = await prisma.agentReminder.findMany()
     * 
     * // Get first 10 AgentReminders
     * const agentReminders = await prisma.agentReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentReminderWithIdOnly = await prisma.agentReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentReminderFindManyArgs>(args?: SelectSubset<T, AgentReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentReminder.
     * @param {AgentReminderCreateArgs} args - Arguments to create a AgentReminder.
     * @example
     * // Create one AgentReminder
     * const AgentReminder = await prisma.agentReminder.create({
     *   data: {
     *     // ... data to create a AgentReminder
     *   }
     * })
     * 
     */
    create<T extends AgentReminderCreateArgs>(args: SelectSubset<T, AgentReminderCreateArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentReminders.
     * @param {AgentReminderCreateManyArgs} args - Arguments to create many AgentReminders.
     * @example
     * // Create many AgentReminders
     * const agentReminder = await prisma.agentReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentReminderCreateManyArgs>(args?: SelectSubset<T, AgentReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentReminders and returns the data saved in the database.
     * @param {AgentReminderCreateManyAndReturnArgs} args - Arguments to create many AgentReminders.
     * @example
     * // Create many AgentReminders
     * const agentReminder = await prisma.agentReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentReminders and only return the `id`
     * const agentReminderWithIdOnly = await prisma.agentReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentReminder.
     * @param {AgentReminderDeleteArgs} args - Arguments to delete one AgentReminder.
     * @example
     * // Delete one AgentReminder
     * const AgentReminder = await prisma.agentReminder.delete({
     *   where: {
     *     // ... filter to delete one AgentReminder
     *   }
     * })
     * 
     */
    delete<T extends AgentReminderDeleteArgs>(args: SelectSubset<T, AgentReminderDeleteArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentReminder.
     * @param {AgentReminderUpdateArgs} args - Arguments to update one AgentReminder.
     * @example
     * // Update one AgentReminder
     * const agentReminder = await prisma.agentReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentReminderUpdateArgs>(args: SelectSubset<T, AgentReminderUpdateArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentReminders.
     * @param {AgentReminderDeleteManyArgs} args - Arguments to filter AgentReminders to delete.
     * @example
     * // Delete a few AgentReminders
     * const { count } = await prisma.agentReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentReminderDeleteManyArgs>(args?: SelectSubset<T, AgentReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentReminders
     * const agentReminder = await prisma.agentReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentReminderUpdateManyArgs>(args: SelectSubset<T, AgentReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentReminders and returns the data updated in the database.
     * @param {AgentReminderUpdateManyAndReturnArgs} args - Arguments to update many AgentReminders.
     * @example
     * // Update many AgentReminders
     * const agentReminder = await prisma.agentReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentReminders and only return the `id`
     * const agentReminderWithIdOnly = await prisma.agentReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentReminder.
     * @param {AgentReminderUpsertArgs} args - Arguments to update or create a AgentReminder.
     * @example
     * // Update or create a AgentReminder
     * const agentReminder = await prisma.agentReminder.upsert({
     *   create: {
     *     // ... data to create a AgentReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentReminder we want to update
     *   }
     * })
     */
    upsert<T extends AgentReminderUpsertArgs>(args: SelectSubset<T, AgentReminderUpsertArgs<ExtArgs>>): Prisma__AgentReminderClient<$Result.GetResult<Prisma.$AgentReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderCountArgs} args - Arguments to filter AgentReminders to count.
     * @example
     * // Count the number of AgentReminders
     * const count = await prisma.agentReminder.count({
     *   where: {
     *     // ... the filter for the AgentReminders we want to count
     *   }
     * })
    **/
    count<T extends AgentReminderCountArgs>(
      args?: Subset<T, AgentReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentReminderAggregateArgs>(args: Subset<T, AgentReminderAggregateArgs>): Prisma.PrismaPromise<GetAgentReminderAggregateType<T>>

    /**
     * Group by AgentReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentReminderGroupByArgs['orderBy'] }
        : { orderBy?: AgentReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentReminder model
   */
  readonly fields: AgentReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agencyMember<T extends AgencyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyMemberDefaultArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentReminder model
   */
  interface AgentReminderFieldRefs {
    readonly id: FieldRef<"AgentReminder", 'String'>
    readonly title: FieldRef<"AgentReminder", 'String'>
    readonly description: FieldRef<"AgentReminder", 'String'>
    readonly status: FieldRef<"AgentReminder", 'ReminderStatus'>
    readonly agencyMemberId: FieldRef<"AgentReminder", 'String'>
    readonly startDate: FieldRef<"AgentReminder", 'DateTime'>
    readonly isRecurring: FieldRef<"AgentReminder", 'Boolean'>
    readonly endDate: FieldRef<"AgentReminder", 'DateTime'>
    readonly lastSentAt: FieldRef<"AgentReminder", 'DateTime'>
    readonly createdAt: FieldRef<"AgentReminder", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentReminder findUnique
   */
  export type AgentReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AgentReminder to fetch.
     */
    where: AgentReminderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder findUniqueOrThrow
   */
  export type AgentReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AgentReminder to fetch.
     */
    where: AgentReminderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder findFirst
   */
  export type AgentReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AgentReminder to fetch.
     */
    where?: AgentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentReminders to fetch.
     */
    orderBy?: AgentReminderOrderByWithRelationInput | AgentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentReminders.
     */
    cursor?: AgentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentReminders.
     */
    distinct?: AgentReminderScalarFieldEnum | AgentReminderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder findFirstOrThrow
   */
  export type AgentReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AgentReminder to fetch.
     */
    where?: AgentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentReminders to fetch.
     */
    orderBy?: AgentReminderOrderByWithRelationInput | AgentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentReminders.
     */
    cursor?: AgentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentReminders.
     */
    distinct?: AgentReminderScalarFieldEnum | AgentReminderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder findMany
   */
  export type AgentReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AgentReminders to fetch.
     */
    where?: AgentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentReminders to fetch.
     */
    orderBy?: AgentReminderOrderByWithRelationInput | AgentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentReminders.
     */
    cursor?: AgentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentReminders.
     */
    skip?: number
    distinct?: AgentReminderScalarFieldEnum | AgentReminderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder create
   */
  export type AgentReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentReminder.
     */
    data: XOR<AgentReminderCreateInput, AgentReminderUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder createMany
   */
  export type AgentReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentReminders.
     */
    data: AgentReminderCreateManyInput | AgentReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentReminder createManyAndReturn
   */
  export type AgentReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * The data used to create many AgentReminders.
     */
    data: AgentReminderCreateManyInput | AgentReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentReminder update
   */
  export type AgentReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentReminder.
     */
    data: XOR<AgentReminderUpdateInput, AgentReminderUncheckedUpdateInput>
    /**
     * Choose, which AgentReminder to update.
     */
    where: AgentReminderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder updateMany
   */
  export type AgentReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentReminders.
     */
    data: XOR<AgentReminderUpdateManyMutationInput, AgentReminderUncheckedUpdateManyInput>
    /**
     * Filter which AgentReminders to update
     */
    where?: AgentReminderWhereInput
    /**
     * Limit how many AgentReminders to update.
     */
    limit?: number
  }

  /**
   * AgentReminder updateManyAndReturn
   */
  export type AgentReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * The data used to update AgentReminders.
     */
    data: XOR<AgentReminderUpdateManyMutationInput, AgentReminderUncheckedUpdateManyInput>
    /**
     * Filter which AgentReminders to update
     */
    where?: AgentReminderWhereInput
    /**
     * Limit how many AgentReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentReminder upsert
   */
  export type AgentReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentReminder to update in case it exists.
     */
    where: AgentReminderWhereUniqueInput
    /**
     * In case the AgentReminder found by the `where` argument doesn't exist, create a new AgentReminder with this data.
     */
    create: XOR<AgentReminderCreateInput, AgentReminderUncheckedCreateInput>
    /**
     * In case the AgentReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentReminderUpdateInput, AgentReminderUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder delete
   */
  export type AgentReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
    /**
     * Filter which AgentReminder to delete.
     */
    where: AgentReminderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AgentReminder deleteMany
   */
  export type AgentReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentReminders to delete
     */
    where?: AgentReminderWhereInput
    /**
     * Limit how many AgentReminders to delete.
     */
    limit?: number
  }

  /**
   * AgentReminder without action
   */
  export type AgentReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentReminder
     */
    select?: AgentReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentReminder
     */
    omit?: AgentReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentReminderInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    receiveCompanyEmail: boolean | null
    receiveCompanySMS: boolean | null
    receiveAgentEmail: boolean | null
    receiveAgentSMS: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    receiveCompanyEmail: boolean | null
    receiveCompanySMS: boolean | null
    receiveAgentEmail: boolean | null
    receiveAgentSMS: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    receiveCompanyEmail: number
    receiveCompanySMS: number
    receiveAgentEmail: number
    receiveAgentSMS: number
    userId: number
    createdAt: number
    updatedAt: number
    preferences: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    receiveCompanyEmail?: true
    receiveCompanySMS?: true
    receiveAgentEmail?: true
    receiveAgentSMS?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    receiveCompanyEmail?: true
    receiveCompanySMS?: true
    receiveAgentEmail?: true
    receiveAgentSMS?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    receiveCompanyEmail?: true
    receiveCompanySMS?: true
    receiveAgentEmail?: true
    receiveAgentSMS?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    preferences?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    receiveCompanyEmail: boolean | null
    receiveCompanySMS: boolean | null
    receiveAgentEmail: boolean | null
    receiveAgentSMS: boolean | null
    userId: string
    createdAt: Date
    updatedAt: Date
    preferences: JsonValue | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiveCompanyEmail?: boolean
    receiveCompanySMS?: boolean
    receiveAgentEmail?: boolean
    receiveAgentSMS?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean
    clientSubscription?: boolean | Client$clientSubscriptionArgs<ExtArgs>
    favorites?: boolean | Client$favoritesArgs<ExtArgs>
    propertyViews?: boolean | Client$propertyViewsArgs<ExtArgs>
    clientSearches?: boolean | Client$clientSearchesArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    AgencyView?: boolean | Client$AgencyViewArgs<ExtArgs>
    PropertyEngagement?: boolean | Client$PropertyEngagementArgs<ExtArgs>
    Proposal?: boolean | Client$ProposalArgs<ExtArgs>
    ProposalCollaboration?: boolean | Client$ProposalCollaborationArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiveCompanyEmail?: boolean
    receiveCompanySMS?: boolean
    receiveAgentEmail?: boolean
    receiveAgentSMS?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiveCompanyEmail?: boolean
    receiveCompanySMS?: boolean
    receiveAgentEmail?: boolean
    receiveAgentSMS?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    receiveCompanyEmail?: boolean
    receiveCompanySMS?: boolean
    receiveAgentEmail?: boolean
    receiveAgentSMS?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiveCompanyEmail" | "receiveCompanySMS" | "receiveAgentEmail" | "receiveAgentSMS" | "userId" | "createdAt" | "updatedAt" | "preferences", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientSubscription?: boolean | Client$clientSubscriptionArgs<ExtArgs>
    favorites?: boolean | Client$favoritesArgs<ExtArgs>
    propertyViews?: boolean | Client$propertyViewsArgs<ExtArgs>
    clientSearches?: boolean | Client$clientSearchesArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    AgencyView?: boolean | Client$AgencyViewArgs<ExtArgs>
    PropertyEngagement?: boolean | Client$PropertyEngagementArgs<ExtArgs>
    Proposal?: boolean | Client$ProposalArgs<ExtArgs>
    ProposalCollaboration?: boolean | Client$ProposalCollaborationArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      clientSubscription: Prisma.$ClientPropertySubscriptionPayload<ExtArgs>[]
      favorites: Prisma.$PropertyFavoritePayload<ExtArgs>[]
      propertyViews: Prisma.$PropertyViewPayload<ExtArgs>[]
      clientSearches: Prisma.$ClientSearchPayload<ExtArgs>[]
      reviews: Prisma.$AgencyReviewPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      AgencyView: Prisma.$AgencyViewPayload<ExtArgs>[]
      PropertyEngagement: Prisma.$PropertyEngagementPayload<ExtArgs>[]
      Proposal: Prisma.$ProposalPayload<ExtArgs>[]
      ProposalCollaboration: Prisma.$ProposalCollaborationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiveCompanyEmail: boolean | null
      receiveCompanySMS: boolean | null
      receiveAgentEmail: boolean | null
      receiveAgentSMS: boolean | null
      userId: string
      createdAt: Date
      updatedAt: Date
      preferences: Prisma.JsonValue | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientSubscription<T extends Client$clientSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Client$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Client$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyViews<T extends Client$propertyViewsArgs<ExtArgs> = {}>(args?: Subset<T, Client$propertyViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientSearches<T extends Client$clientSearchesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientSearchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Client$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Client$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AgencyView<T extends Client$AgencyViewArgs<ExtArgs> = {}>(args?: Subset<T, Client$AgencyViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyEngagement<T extends Client$PropertyEngagementArgs<ExtArgs> = {}>(args?: Subset<T, Client$PropertyEngagementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Proposal<T extends Client$ProposalArgs<ExtArgs> = {}>(args?: Subset<T, Client$ProposalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProposalCollaboration<T extends Client$ProposalCollaborationArgs<ExtArgs> = {}>(args?: Subset<T, Client$ProposalCollaborationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly receiveCompanyEmail: FieldRef<"Client", 'Boolean'>
    readonly receiveCompanySMS: FieldRef<"Client", 'Boolean'>
    readonly receiveAgentEmail: FieldRef<"Client", 'Boolean'>
    readonly receiveAgentSMS: FieldRef<"Client", 'Boolean'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly preferences: FieldRef<"Client", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.clientSubscription
   */
  export type Client$clientSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    where?: ClientPropertySubscriptionWhereInput
    orderBy?: ClientPropertySubscriptionOrderByWithRelationInput | ClientPropertySubscriptionOrderByWithRelationInput[]
    cursor?: ClientPropertySubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPropertySubscriptionScalarFieldEnum | ClientPropertySubscriptionScalarFieldEnum[]
  }

  /**
   * Client.favorites
   */
  export type Client$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    where?: PropertyFavoriteWhereInput
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    cursor?: PropertyFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyFavoriteScalarFieldEnum | PropertyFavoriteScalarFieldEnum[]
  }

  /**
   * Client.propertyViews
   */
  export type Client$propertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * Client.clientSearches
   */
  export type Client$clientSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    where?: ClientSearchWhereInput
    orderBy?: ClientSearchOrderByWithRelationInput | ClientSearchOrderByWithRelationInput[]
    cursor?: ClientSearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSearchScalarFieldEnum | ClientSearchScalarFieldEnum[]
  }

  /**
   * Client.reviews
   */
  export type Client$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyReview
     */
    select?: AgencyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyReview
     */
    omit?: AgencyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyReviewInclude<ExtArgs> | null
    where?: AgencyReviewWhereInput
    orderBy?: AgencyReviewOrderByWithRelationInput | AgencyReviewOrderByWithRelationInput[]
    cursor?: AgencyReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyReviewScalarFieldEnum | AgencyReviewScalarFieldEnum[]
  }

  /**
   * Client.AgencyView
   */
  export type Client$AgencyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyView
     */
    select?: AgencyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyView
     */
    omit?: AgencyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyViewInclude<ExtArgs> | null
    where?: AgencyViewWhereInput
    orderBy?: AgencyViewOrderByWithRelationInput | AgencyViewOrderByWithRelationInput[]
    cursor?: AgencyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyViewScalarFieldEnum | AgencyViewScalarFieldEnum[]
  }

  /**
   * Client.PropertyEngagement
   */
  export type Client$PropertyEngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    where?: PropertyEngagementWhereInput
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    cursor?: PropertyEngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyEngagementScalarFieldEnum | PropertyEngagementScalarFieldEnum[]
  }

  /**
   * Client.Proposal
   */
  export type Client$ProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Client.ProposalCollaboration
   */
  export type Client$ProposalCollaborationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    where?: ProposalCollaborationWhereInput
    orderBy?: ProposalCollaborationOrderByWithRelationInput | ProposalCollaborationOrderByWithRelationInput[]
    cursor?: ProposalCollaborationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalCollaborationScalarFieldEnum | ProposalCollaborationScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientSearch
   */

  export type AggregateClientSearch = {
    _count: ClientSearchCountAggregateOutputType | null
    _min: ClientSearchMinAggregateOutputType | null
    _max: ClientSearchMaxAggregateOutputType | null
  }

  export type ClientSearchMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    link: string | null
    receiveOffers: boolean | null
  }

  export type ClientSearchMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    link: string | null
    receiveOffers: boolean | null
  }

  export type ClientSearchCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientId: number
    title: number
    link: number
    filters: number
    receiveOffers: number
    agencyIdsJson: number
    _all: number
  }


  export type ClientSearchMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    link?: true
    receiveOffers?: true
  }

  export type ClientSearchMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    link?: true
    receiveOffers?: true
  }

  export type ClientSearchCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    title?: true
    link?: true
    filters?: true
    receiveOffers?: true
    agencyIdsJson?: true
    _all?: true
  }

  export type ClientSearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSearch to aggregate.
     */
    where?: ClientSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSearches to fetch.
     */
    orderBy?: ClientSearchOrderByWithRelationInput | ClientSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientSearches
    **/
    _count?: true | ClientSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientSearchMaxAggregateInputType
  }

  export type GetClientSearchAggregateType<T extends ClientSearchAggregateArgs> = {
        [P in keyof T & keyof AggregateClientSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientSearch[P]>
      : GetScalarType<T[P], AggregateClientSearch[P]>
  }




  export type ClientSearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSearchWhereInput
    orderBy?: ClientSearchOrderByWithAggregationInput | ClientSearchOrderByWithAggregationInput[]
    by: ClientSearchScalarFieldEnum[] | ClientSearchScalarFieldEnum
    having?: ClientSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientSearchCountAggregateInputType | true
    _min?: ClientSearchMinAggregateInputType
    _max?: ClientSearchMaxAggregateInputType
  }

  export type ClientSearchGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    clientId: string
    title: JsonValue
    link: string
    filters: JsonValue
    receiveOffers: boolean
    agencyIdsJson: JsonValue | null
    _count: ClientSearchCountAggregateOutputType | null
    _min: ClientSearchMinAggregateOutputType | null
    _max: ClientSearchMaxAggregateOutputType | null
  }

  type GetClientSearchGroupByPayload<T extends ClientSearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientSearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientSearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientSearchGroupByOutputType[P]>
            : GetScalarType<T[P], ClientSearchGroupByOutputType[P]>
        }
      >
    >


  export type ClientSearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    title?: boolean
    link?: boolean
    filters?: boolean
    receiveOffers?: boolean
    agencyIdsJson?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientPropertySubscription?: boolean | ClientSearch$clientPropertySubscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["clientSearch"]>

  export type ClientSearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    title?: boolean
    link?: boolean
    filters?: boolean
    receiveOffers?: boolean
    agencyIdsJson?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSearch"]>

  export type ClientSearchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    title?: boolean
    link?: boolean
    filters?: boolean
    receiveOffers?: boolean
    agencyIdsJson?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSearch"]>

  export type ClientSearchSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    title?: boolean
    link?: boolean
    filters?: boolean
    receiveOffers?: boolean
    agencyIdsJson?: boolean
  }

  export type ClientSearchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientId" | "title" | "link" | "filters" | "receiveOffers" | "agencyIdsJson", ExtArgs["result"]["clientSearch"]>
  export type ClientSearchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientPropertySubscription?: boolean | ClientSearch$clientPropertySubscriptionArgs<ExtArgs>
  }
  export type ClientSearchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientSearchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientSearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientSearch"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      clientPropertySubscription: Prisma.$ClientPropertySubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      clientId: string
      title: Prisma.JsonValue
      link: string
      filters: Prisma.JsonValue
      receiveOffers: boolean
      agencyIdsJson: Prisma.JsonValue | null
    }, ExtArgs["result"]["clientSearch"]>
    composites: {}
  }

  type ClientSearchGetPayload<S extends boolean | null | undefined | ClientSearchDefaultArgs> = $Result.GetResult<Prisma.$ClientSearchPayload, S>

  type ClientSearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientSearchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ClientSearchCountAggregateInputType | true
    }

  export interface ClientSearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientSearch'], meta: { name: 'ClientSearch' } }
    /**
     * Find zero or one ClientSearch that matches the filter.
     * @param {ClientSearchFindUniqueArgs} args - Arguments to find a ClientSearch
     * @example
     * // Get one ClientSearch
     * const clientSearch = await prisma.clientSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientSearchFindUniqueArgs>(args: SelectSubset<T, ClientSearchFindUniqueArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientSearch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientSearchFindUniqueOrThrowArgs} args - Arguments to find a ClientSearch
     * @example
     * // Get one ClientSearch
     * const clientSearch = await prisma.clientSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientSearchFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientSearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchFindFirstArgs} args - Arguments to find a ClientSearch
     * @example
     * // Get one ClientSearch
     * const clientSearch = await prisma.clientSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientSearchFindFirstArgs>(args?: SelectSubset<T, ClientSearchFindFirstArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchFindFirstOrThrowArgs} args - Arguments to find a ClientSearch
     * @example
     * // Get one ClientSearch
     * const clientSearch = await prisma.clientSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientSearchFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientSearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientSearches
     * const clientSearches = await prisma.clientSearch.findMany()
     * 
     * // Get first 10 ClientSearches
     * const clientSearches = await prisma.clientSearch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientSearchWithIdOnly = await prisma.clientSearch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientSearchFindManyArgs>(args?: SelectSubset<T, ClientSearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientSearch.
     * @param {ClientSearchCreateArgs} args - Arguments to create a ClientSearch.
     * @example
     * // Create one ClientSearch
     * const ClientSearch = await prisma.clientSearch.create({
     *   data: {
     *     // ... data to create a ClientSearch
     *   }
     * })
     * 
     */
    create<T extends ClientSearchCreateArgs>(args: SelectSubset<T, ClientSearchCreateArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientSearches.
     * @param {ClientSearchCreateManyArgs} args - Arguments to create many ClientSearches.
     * @example
     * // Create many ClientSearches
     * const clientSearch = await prisma.clientSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientSearchCreateManyArgs>(args?: SelectSubset<T, ClientSearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientSearches and returns the data saved in the database.
     * @param {ClientSearchCreateManyAndReturnArgs} args - Arguments to create many ClientSearches.
     * @example
     * // Create many ClientSearches
     * const clientSearch = await prisma.clientSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientSearches and only return the `id`
     * const clientSearchWithIdOnly = await prisma.clientSearch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientSearchCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientSearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientSearch.
     * @param {ClientSearchDeleteArgs} args - Arguments to delete one ClientSearch.
     * @example
     * // Delete one ClientSearch
     * const ClientSearch = await prisma.clientSearch.delete({
     *   where: {
     *     // ... filter to delete one ClientSearch
     *   }
     * })
     * 
     */
    delete<T extends ClientSearchDeleteArgs>(args: SelectSubset<T, ClientSearchDeleteArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientSearch.
     * @param {ClientSearchUpdateArgs} args - Arguments to update one ClientSearch.
     * @example
     * // Update one ClientSearch
     * const clientSearch = await prisma.clientSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientSearchUpdateArgs>(args: SelectSubset<T, ClientSearchUpdateArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientSearches.
     * @param {ClientSearchDeleteManyArgs} args - Arguments to filter ClientSearches to delete.
     * @example
     * // Delete a few ClientSearches
     * const { count } = await prisma.clientSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientSearchDeleteManyArgs>(args?: SelectSubset<T, ClientSearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientSearches
     * const clientSearch = await prisma.clientSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientSearchUpdateManyArgs>(args: SelectSubset<T, ClientSearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSearches and returns the data updated in the database.
     * @param {ClientSearchUpdateManyAndReturnArgs} args - Arguments to update many ClientSearches.
     * @example
     * // Update many ClientSearches
     * const clientSearch = await prisma.clientSearch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientSearches and only return the `id`
     * const clientSearchWithIdOnly = await prisma.clientSearch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientSearchUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientSearchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientSearch.
     * @param {ClientSearchUpsertArgs} args - Arguments to update or create a ClientSearch.
     * @example
     * // Update or create a ClientSearch
     * const clientSearch = await prisma.clientSearch.upsert({
     *   create: {
     *     // ... data to create a ClientSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientSearch we want to update
     *   }
     * })
     */
    upsert<T extends ClientSearchUpsertArgs>(args: SelectSubset<T, ClientSearchUpsertArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchCountArgs} args - Arguments to filter ClientSearches to count.
     * @example
     * // Count the number of ClientSearches
     * const count = await prisma.clientSearch.count({
     *   where: {
     *     // ... the filter for the ClientSearches we want to count
     *   }
     * })
    **/
    count<T extends ClientSearchCountArgs>(
      args?: Subset<T, ClientSearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientSearchAggregateArgs>(args: Subset<T, ClientSearchAggregateArgs>): Prisma.PrismaPromise<GetClientSearchAggregateType<T>>

    /**
     * Group by ClientSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientSearchGroupByArgs['orderBy'] }
        : { orderBy?: ClientSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientSearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientSearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientSearch model
   */
  readonly fields: ClientSearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientSearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientPropertySubscription<T extends ClientSearch$clientPropertySubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, ClientSearch$clientPropertySubscriptionArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientSearch model
   */
  interface ClientSearchFieldRefs {
    readonly id: FieldRef<"ClientSearch", 'String'>
    readonly createdAt: FieldRef<"ClientSearch", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientSearch", 'DateTime'>
    readonly clientId: FieldRef<"ClientSearch", 'String'>
    readonly title: FieldRef<"ClientSearch", 'Json'>
    readonly link: FieldRef<"ClientSearch", 'String'>
    readonly filters: FieldRef<"ClientSearch", 'Json'>
    readonly receiveOffers: FieldRef<"ClientSearch", 'Boolean'>
    readonly agencyIdsJson: FieldRef<"ClientSearch", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ClientSearch findUnique
   */
  export type ClientSearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter, which ClientSearch to fetch.
     */
    where: ClientSearchWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch findUniqueOrThrow
   */
  export type ClientSearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter, which ClientSearch to fetch.
     */
    where: ClientSearchWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch findFirst
   */
  export type ClientSearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter, which ClientSearch to fetch.
     */
    where?: ClientSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSearches to fetch.
     */
    orderBy?: ClientSearchOrderByWithRelationInput | ClientSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSearches.
     */
    cursor?: ClientSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSearches.
     */
    distinct?: ClientSearchScalarFieldEnum | ClientSearchScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch findFirstOrThrow
   */
  export type ClientSearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter, which ClientSearch to fetch.
     */
    where?: ClientSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSearches to fetch.
     */
    orderBy?: ClientSearchOrderByWithRelationInput | ClientSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSearches.
     */
    cursor?: ClientSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSearches.
     */
    distinct?: ClientSearchScalarFieldEnum | ClientSearchScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch findMany
   */
  export type ClientSearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter, which ClientSearches to fetch.
     */
    where?: ClientSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSearches to fetch.
     */
    orderBy?: ClientSearchOrderByWithRelationInput | ClientSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientSearches.
     */
    cursor?: ClientSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSearches.
     */
    skip?: number
    distinct?: ClientSearchScalarFieldEnum | ClientSearchScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch create
   */
  export type ClientSearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientSearch.
     */
    data: XOR<ClientSearchCreateInput, ClientSearchUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch createMany
   */
  export type ClientSearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientSearches.
     */
    data: ClientSearchCreateManyInput | ClientSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientSearch createManyAndReturn
   */
  export type ClientSearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * The data used to create many ClientSearches.
     */
    data: ClientSearchCreateManyInput | ClientSearchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSearch update
   */
  export type ClientSearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientSearch.
     */
    data: XOR<ClientSearchUpdateInput, ClientSearchUncheckedUpdateInput>
    /**
     * Choose, which ClientSearch to update.
     */
    where: ClientSearchWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch updateMany
   */
  export type ClientSearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientSearches.
     */
    data: XOR<ClientSearchUpdateManyMutationInput, ClientSearchUncheckedUpdateManyInput>
    /**
     * Filter which ClientSearches to update
     */
    where?: ClientSearchWhereInput
    /**
     * Limit how many ClientSearches to update.
     */
    limit?: number
  }

  /**
   * ClientSearch updateManyAndReturn
   */
  export type ClientSearchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * The data used to update ClientSearches.
     */
    data: XOR<ClientSearchUpdateManyMutationInput, ClientSearchUncheckedUpdateManyInput>
    /**
     * Filter which ClientSearches to update
     */
    where?: ClientSearchWhereInput
    /**
     * Limit how many ClientSearches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSearch upsert
   */
  export type ClientSearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientSearch to update in case it exists.
     */
    where: ClientSearchWhereUniqueInput
    /**
     * In case the ClientSearch found by the `where` argument doesn't exist, create a new ClientSearch with this data.
     */
    create: XOR<ClientSearchCreateInput, ClientSearchUncheckedCreateInput>
    /**
     * In case the ClientSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientSearchUpdateInput, ClientSearchUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch delete
   */
  export type ClientSearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    /**
     * Filter which ClientSearch to delete.
     */
    where: ClientSearchWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientSearch deleteMany
   */
  export type ClientSearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSearches to delete
     */
    where?: ClientSearchWhereInput
    /**
     * Limit how many ClientSearches to delete.
     */
    limit?: number
  }

  /**
   * ClientSearch.clientPropertySubscription
   */
  export type ClientSearch$clientPropertySubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    where?: ClientPropertySubscriptionWhereInput
  }

  /**
   * ClientSearch without action
   */
  export type ClientSearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
  }


  /**
   * Model ClientPropertySubscription
   */

  export type AggregateClientPropertySubscription = {
    _count: ClientPropertySubscriptionCountAggregateOutputType | null
    _avg: ClientPropertySubscriptionAvgAggregateOutputType | null
    _sum: ClientPropertySubscriptionSumAggregateOutputType | null
    _min: ClientPropertySubscriptionMinAggregateOutputType | null
    _max: ClientPropertySubscriptionMaxAggregateOutputType | null
  }

  export type ClientPropertySubscriptionAvgAggregateOutputType = {
    minSize: number | null
    maxSize: number | null
    minPrice: number | null
    maxPrice: number | null
  }

  export type ClientPropertySubscriptionSumAggregateOutputType = {
    minSize: number | null
    maxSize: number | null
    minPrice: number | null
    maxPrice: number | null
  }

  export type ClientPropertySubscriptionMinAggregateOutputType = {
    id: string | null
    minSize: number | null
    maxSize: number | null
    minPrice: number | null
    maxPrice: number | null
    location: string | null
    listingType: $Enums.PropertyListingType | null
    category: string | null
    subCategory: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    clientSearchId: string | null
  }

  export type ClientPropertySubscriptionMaxAggregateOutputType = {
    id: string | null
    minSize: number | null
    maxSize: number | null
    minPrice: number | null
    maxPrice: number | null
    location: string | null
    listingType: $Enums.PropertyListingType | null
    category: string | null
    subCategory: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    clientSearchId: string | null
  }

  export type ClientPropertySubscriptionCountAggregateOutputType = {
    id: number
    minSize: number
    maxSize: number
    minPrice: number
    maxPrice: number
    location: number
    listingType: number
    category: number
    subCategory: number
    createdAt: number
    updatedAt: number
    clientId: number
    clientSearchId: number
    _all: number
  }


  export type ClientPropertySubscriptionAvgAggregateInputType = {
    minSize?: true
    maxSize?: true
    minPrice?: true
    maxPrice?: true
  }

  export type ClientPropertySubscriptionSumAggregateInputType = {
    minSize?: true
    maxSize?: true
    minPrice?: true
    maxPrice?: true
  }

  export type ClientPropertySubscriptionMinAggregateInputType = {
    id?: true
    minSize?: true
    maxSize?: true
    minPrice?: true
    maxPrice?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    clientSearchId?: true
  }

  export type ClientPropertySubscriptionMaxAggregateInputType = {
    id?: true
    minSize?: true
    maxSize?: true
    minPrice?: true
    maxPrice?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    clientSearchId?: true
  }

  export type ClientPropertySubscriptionCountAggregateInputType = {
    id?: true
    minSize?: true
    maxSize?: true
    minPrice?: true
    maxPrice?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    clientSearchId?: true
    _all?: true
  }

  export type ClientPropertySubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPropertySubscription to aggregate.
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPropertySubscriptions to fetch.
     */
    orderBy?: ClientPropertySubscriptionOrderByWithRelationInput | ClientPropertySubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPropertySubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPropertySubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPropertySubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPropertySubscriptions
    **/
    _count?: true | ClientPropertySubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPropertySubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPropertySubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPropertySubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPropertySubscriptionMaxAggregateInputType
  }

  export type GetClientPropertySubscriptionAggregateType<T extends ClientPropertySubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPropertySubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPropertySubscription[P]>
      : GetScalarType<T[P], AggregateClientPropertySubscription[P]>
  }




  export type ClientPropertySubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPropertySubscriptionWhereInput
    orderBy?: ClientPropertySubscriptionOrderByWithAggregationInput | ClientPropertySubscriptionOrderByWithAggregationInput[]
    by: ClientPropertySubscriptionScalarFieldEnum[] | ClientPropertySubscriptionScalarFieldEnum
    having?: ClientPropertySubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPropertySubscriptionCountAggregateInputType | true
    _avg?: ClientPropertySubscriptionAvgAggregateInputType
    _sum?: ClientPropertySubscriptionSumAggregateInputType
    _min?: ClientPropertySubscriptionMinAggregateInputType
    _max?: ClientPropertySubscriptionMaxAggregateInputType
  }

  export type ClientPropertySubscriptionGroupByOutputType = {
    id: string
    minSize: number | null
    maxSize: number | null
    minPrice: number | null
    maxPrice: number | null
    location: string | null
    listingType: $Enums.PropertyListingType | null
    category: string
    subCategory: string | null
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    clientSearchId: string | null
    _count: ClientPropertySubscriptionCountAggregateOutputType | null
    _avg: ClientPropertySubscriptionAvgAggregateOutputType | null
    _sum: ClientPropertySubscriptionSumAggregateOutputType | null
    _min: ClientPropertySubscriptionMinAggregateOutputType | null
    _max: ClientPropertySubscriptionMaxAggregateOutputType | null
  }

  type GetClientPropertySubscriptionGroupByPayload<T extends ClientPropertySubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPropertySubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPropertySubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPropertySubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPropertySubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ClientPropertySubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minSize?: boolean
    maxSize?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    clientSearchId?: boolean
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }, ExtArgs["result"]["clientPropertySubscription"]>

  export type ClientPropertySubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minSize?: boolean
    maxSize?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    clientSearchId?: boolean
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }, ExtArgs["result"]["clientPropertySubscription"]>

  export type ClientPropertySubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minSize?: boolean
    maxSize?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    clientSearchId?: boolean
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }, ExtArgs["result"]["clientPropertySubscription"]>

  export type ClientPropertySubscriptionSelectScalar = {
    id?: boolean
    minSize?: boolean
    maxSize?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    clientSearchId?: boolean
  }

  export type ClientPropertySubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "minSize" | "maxSize" | "minPrice" | "maxPrice" | "location" | "listingType" | "category" | "subCategory" | "createdAt" | "updatedAt" | "clientId" | "clientSearchId", ExtArgs["result"]["clientPropertySubscription"]>
  export type ClientPropertySubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }
  export type ClientPropertySubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }
  export type ClientPropertySubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientPropertySubscription$clientArgs<ExtArgs>
    clientSearch?: boolean | ClientPropertySubscription$clientSearchArgs<ExtArgs>
  }

  export type $ClientPropertySubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPropertySubscription"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      clientSearch: Prisma.$ClientSearchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      minSize: number | null
      maxSize: number | null
      minPrice: number | null
      maxPrice: number | null
      location: string | null
      listingType: $Enums.PropertyListingType | null
      category: string
      subCategory: string | null
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      clientSearchId: string | null
    }, ExtArgs["result"]["clientPropertySubscription"]>
    composites: {}
  }

  type ClientPropertySubscriptionGetPayload<S extends boolean | null | undefined | ClientPropertySubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ClientPropertySubscriptionPayload, S>

  type ClientPropertySubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientPropertySubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ClientPropertySubscriptionCountAggregateInputType | true
    }

  export interface ClientPropertySubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPropertySubscription'], meta: { name: 'ClientPropertySubscription' } }
    /**
     * Find zero or one ClientPropertySubscription that matches the filter.
     * @param {ClientPropertySubscriptionFindUniqueArgs} args - Arguments to find a ClientPropertySubscription
     * @example
     * // Get one ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPropertySubscriptionFindUniqueArgs>(args: SelectSubset<T, ClientPropertySubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientPropertySubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPropertySubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ClientPropertySubscription
     * @example
     * // Get one ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPropertySubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientPropertySubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPropertySubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionFindFirstArgs} args - Arguments to find a ClientPropertySubscription
     * @example
     * // Get one ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPropertySubscriptionFindFirstArgs>(args?: SelectSubset<T, ClientPropertySubscriptionFindFirstArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPropertySubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionFindFirstOrThrowArgs} args - Arguments to find a ClientPropertySubscription
     * @example
     * // Get one ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPropertySubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientPropertySubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientPropertySubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPropertySubscriptions
     * const clientPropertySubscriptions = await prisma.clientPropertySubscription.findMany()
     * 
     * // Get first 10 ClientPropertySubscriptions
     * const clientPropertySubscriptions = await prisma.clientPropertySubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPropertySubscriptionWithIdOnly = await prisma.clientPropertySubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientPropertySubscriptionFindManyArgs>(args?: SelectSubset<T, ClientPropertySubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientPropertySubscription.
     * @param {ClientPropertySubscriptionCreateArgs} args - Arguments to create a ClientPropertySubscription.
     * @example
     * // Create one ClientPropertySubscription
     * const ClientPropertySubscription = await prisma.clientPropertySubscription.create({
     *   data: {
     *     // ... data to create a ClientPropertySubscription
     *   }
     * })
     * 
     */
    create<T extends ClientPropertySubscriptionCreateArgs>(args: SelectSubset<T, ClientPropertySubscriptionCreateArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientPropertySubscriptions.
     * @param {ClientPropertySubscriptionCreateManyArgs} args - Arguments to create many ClientPropertySubscriptions.
     * @example
     * // Create many ClientPropertySubscriptions
     * const clientPropertySubscription = await prisma.clientPropertySubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientPropertySubscriptionCreateManyArgs>(args?: SelectSubset<T, ClientPropertySubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientPropertySubscriptions and returns the data saved in the database.
     * @param {ClientPropertySubscriptionCreateManyAndReturnArgs} args - Arguments to create many ClientPropertySubscriptions.
     * @example
     * // Create many ClientPropertySubscriptions
     * const clientPropertySubscription = await prisma.clientPropertySubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientPropertySubscriptions and only return the `id`
     * const clientPropertySubscriptionWithIdOnly = await prisma.clientPropertySubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientPropertySubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientPropertySubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientPropertySubscription.
     * @param {ClientPropertySubscriptionDeleteArgs} args - Arguments to delete one ClientPropertySubscription.
     * @example
     * // Delete one ClientPropertySubscription
     * const ClientPropertySubscription = await prisma.clientPropertySubscription.delete({
     *   where: {
     *     // ... filter to delete one ClientPropertySubscription
     *   }
     * })
     * 
     */
    delete<T extends ClientPropertySubscriptionDeleteArgs>(args: SelectSubset<T, ClientPropertySubscriptionDeleteArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientPropertySubscription.
     * @param {ClientPropertySubscriptionUpdateArgs} args - Arguments to update one ClientPropertySubscription.
     * @example
     * // Update one ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientPropertySubscriptionUpdateArgs>(args: SelectSubset<T, ClientPropertySubscriptionUpdateArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientPropertySubscriptions.
     * @param {ClientPropertySubscriptionDeleteManyArgs} args - Arguments to filter ClientPropertySubscriptions to delete.
     * @example
     * // Delete a few ClientPropertySubscriptions
     * const { count } = await prisma.clientPropertySubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientPropertySubscriptionDeleteManyArgs>(args?: SelectSubset<T, ClientPropertySubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPropertySubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPropertySubscriptions
     * const clientPropertySubscription = await prisma.clientPropertySubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientPropertySubscriptionUpdateManyArgs>(args: SelectSubset<T, ClientPropertySubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPropertySubscriptions and returns the data updated in the database.
     * @param {ClientPropertySubscriptionUpdateManyAndReturnArgs} args - Arguments to update many ClientPropertySubscriptions.
     * @example
     * // Update many ClientPropertySubscriptions
     * const clientPropertySubscription = await prisma.clientPropertySubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientPropertySubscriptions and only return the `id`
     * const clientPropertySubscriptionWithIdOnly = await prisma.clientPropertySubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientPropertySubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientPropertySubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientPropertySubscription.
     * @param {ClientPropertySubscriptionUpsertArgs} args - Arguments to update or create a ClientPropertySubscription.
     * @example
     * // Update or create a ClientPropertySubscription
     * const clientPropertySubscription = await prisma.clientPropertySubscription.upsert({
     *   create: {
     *     // ... data to create a ClientPropertySubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPropertySubscription we want to update
     *   }
     * })
     */
    upsert<T extends ClientPropertySubscriptionUpsertArgs>(args: SelectSubset<T, ClientPropertySubscriptionUpsertArgs<ExtArgs>>): Prisma__ClientPropertySubscriptionClient<$Result.GetResult<Prisma.$ClientPropertySubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientPropertySubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionCountArgs} args - Arguments to filter ClientPropertySubscriptions to count.
     * @example
     * // Count the number of ClientPropertySubscriptions
     * const count = await prisma.clientPropertySubscription.count({
     *   where: {
     *     // ... the filter for the ClientPropertySubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ClientPropertySubscriptionCountArgs>(
      args?: Subset<T, ClientPropertySubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPropertySubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPropertySubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPropertySubscriptionAggregateArgs>(args: Subset<T, ClientPropertySubscriptionAggregateArgs>): Prisma.PrismaPromise<GetClientPropertySubscriptionAggregateType<T>>

    /**
     * Group by ClientPropertySubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPropertySubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPropertySubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPropertySubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ClientPropertySubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPropertySubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPropertySubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPropertySubscription model
   */
  readonly fields: ClientPropertySubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPropertySubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPropertySubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientPropertySubscription$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientPropertySubscription$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientSearch<T extends ClientPropertySubscription$clientSearchArgs<ExtArgs> = {}>(args?: Subset<T, ClientPropertySubscription$clientSearchArgs<ExtArgs>>): Prisma__ClientSearchClient<$Result.GetResult<Prisma.$ClientSearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientPropertySubscription model
   */
  interface ClientPropertySubscriptionFieldRefs {
    readonly id: FieldRef<"ClientPropertySubscription", 'String'>
    readonly minSize: FieldRef<"ClientPropertySubscription", 'Int'>
    readonly maxSize: FieldRef<"ClientPropertySubscription", 'Int'>
    readonly minPrice: FieldRef<"ClientPropertySubscription", 'Int'>
    readonly maxPrice: FieldRef<"ClientPropertySubscription", 'Int'>
    readonly location: FieldRef<"ClientPropertySubscription", 'String'>
    readonly listingType: FieldRef<"ClientPropertySubscription", 'PropertyListingType'>
    readonly category: FieldRef<"ClientPropertySubscription", 'String'>
    readonly subCategory: FieldRef<"ClientPropertySubscription", 'String'>
    readonly createdAt: FieldRef<"ClientPropertySubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientPropertySubscription", 'DateTime'>
    readonly clientId: FieldRef<"ClientPropertySubscription", 'String'>
    readonly clientSearchId: FieldRef<"ClientPropertySubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientPropertySubscription findUnique
   */
  export type ClientPropertySubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClientPropertySubscription to fetch.
     */
    where: ClientPropertySubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription findUniqueOrThrow
   */
  export type ClientPropertySubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClientPropertySubscription to fetch.
     */
    where: ClientPropertySubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription findFirst
   */
  export type ClientPropertySubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClientPropertySubscription to fetch.
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPropertySubscriptions to fetch.
     */
    orderBy?: ClientPropertySubscriptionOrderByWithRelationInput | ClientPropertySubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPropertySubscriptions.
     */
    cursor?: ClientPropertySubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPropertySubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPropertySubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPropertySubscriptions.
     */
    distinct?: ClientPropertySubscriptionScalarFieldEnum | ClientPropertySubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription findFirstOrThrow
   */
  export type ClientPropertySubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClientPropertySubscription to fetch.
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPropertySubscriptions to fetch.
     */
    orderBy?: ClientPropertySubscriptionOrderByWithRelationInput | ClientPropertySubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPropertySubscriptions.
     */
    cursor?: ClientPropertySubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPropertySubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPropertySubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPropertySubscriptions.
     */
    distinct?: ClientPropertySubscriptionScalarFieldEnum | ClientPropertySubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription findMany
   */
  export type ClientPropertySubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ClientPropertySubscriptions to fetch.
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPropertySubscriptions to fetch.
     */
    orderBy?: ClientPropertySubscriptionOrderByWithRelationInput | ClientPropertySubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPropertySubscriptions.
     */
    cursor?: ClientPropertySubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPropertySubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPropertySubscriptions.
     */
    skip?: number
    distinct?: ClientPropertySubscriptionScalarFieldEnum | ClientPropertySubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription create
   */
  export type ClientPropertySubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPropertySubscription.
     */
    data: XOR<ClientPropertySubscriptionCreateInput, ClientPropertySubscriptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription createMany
   */
  export type ClientPropertySubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPropertySubscriptions.
     */
    data: ClientPropertySubscriptionCreateManyInput | ClientPropertySubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPropertySubscription createManyAndReturn
   */
  export type ClientPropertySubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ClientPropertySubscriptions.
     */
    data: ClientPropertySubscriptionCreateManyInput | ClientPropertySubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPropertySubscription update
   */
  export type ClientPropertySubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPropertySubscription.
     */
    data: XOR<ClientPropertySubscriptionUpdateInput, ClientPropertySubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ClientPropertySubscription to update.
     */
    where: ClientPropertySubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription updateMany
   */
  export type ClientPropertySubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPropertySubscriptions.
     */
    data: XOR<ClientPropertySubscriptionUpdateManyMutationInput, ClientPropertySubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClientPropertySubscriptions to update
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * Limit how many ClientPropertySubscriptions to update.
     */
    limit?: number
  }

  /**
   * ClientPropertySubscription updateManyAndReturn
   */
  export type ClientPropertySubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update ClientPropertySubscriptions.
     */
    data: XOR<ClientPropertySubscriptionUpdateManyMutationInput, ClientPropertySubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ClientPropertySubscriptions to update
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * Limit how many ClientPropertySubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPropertySubscription upsert
   */
  export type ClientPropertySubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPropertySubscription to update in case it exists.
     */
    where: ClientPropertySubscriptionWhereUniqueInput
    /**
     * In case the ClientPropertySubscription found by the `where` argument doesn't exist, create a new ClientPropertySubscription with this data.
     */
    create: XOR<ClientPropertySubscriptionCreateInput, ClientPropertySubscriptionUncheckedCreateInput>
    /**
     * In case the ClientPropertySubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPropertySubscriptionUpdateInput, ClientPropertySubscriptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription delete
   */
  export type ClientPropertySubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ClientPropertySubscription to delete.
     */
    where: ClientPropertySubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ClientPropertySubscription deleteMany
   */
  export type ClientPropertySubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPropertySubscriptions to delete
     */
    where?: ClientPropertySubscriptionWhereInput
    /**
     * Limit how many ClientPropertySubscriptions to delete.
     */
    limit?: number
  }

  /**
   * ClientPropertySubscription.client
   */
  export type ClientPropertySubscription$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientPropertySubscription.clientSearch
   */
  export type ClientPropertySubscription$clientSearchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSearch
     */
    select?: ClientSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSearch
     */
    omit?: ClientSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSearchInclude<ExtArgs> | null
    where?: ClientSearchWhereInput
  }

  /**
   * ClientPropertySubscription without action
   */
  export type ClientPropertySubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPropertySubscription
     */
    select?: ClientPropertySubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPropertySubscription
     */
    omit?: ClientPropertySubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPropertySubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryAvgAggregateOutputType = {
    priceFrom: number | null
    priceTo: number | null
    sizeFrom: number | null
    sizeTo: number | null
  }

  export type SearchQuerySumAggregateOutputType = {
    priceFrom: number | null
    priceTo: number | null
    sizeFrom: number | null
    sizeTo: number | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    location: string | null
    listingType: $Enums.PropertyListingType | null
    category: string | null
    subCategory: string | null
    priceFrom: number | null
    priceTo: number | null
    sizeFrom: number | null
    sizeTo: number | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    location: string | null
    listingType: $Enums.PropertyListingType | null
    category: string | null
    subCategory: string | null
    priceFrom: number | null
    priceTo: number | null
    sizeFrom: number | null
    sizeTo: number | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    location: number
    listingType: number
    category: number
    subCategory: number
    priceFrom: number
    priceTo: number
    sizeFrom: number
    sizeTo: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchQueryAvgAggregateInputType = {
    priceFrom?: true
    priceTo?: true
    sizeFrom?: true
    sizeTo?: true
  }

  export type SearchQuerySumAggregateInputType = {
    priceFrom?: true
    priceTo?: true
    sizeFrom?: true
    sizeTo?: true
  }

  export type SearchQueryMinAggregateInputType = {
    id?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    priceFrom?: true
    priceTo?: true
    sizeFrom?: true
    sizeTo?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    priceFrom?: true
    priceTo?: true
    sizeFrom?: true
    sizeTo?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    location?: true
    listingType?: true
    category?: true
    subCategory?: true
    priceFrom?: true
    priceTo?: true
    sizeFrom?: true
    sizeTo?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _avg?: SearchQueryAvgAggregateInputType
    _sum?: SearchQuerySumAggregateInputType
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    location: string
    listingType: $Enums.PropertyListingType
    category: string
    subCategory: string | null
    priceFrom: number | null
    priceTo: number | null
    sizeFrom: number | null
    sizeTo: number | null
    clientId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    priceFrom?: boolean
    priceTo?: boolean
    sizeFrom?: boolean
    sizeTo?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    priceFrom?: boolean
    priceTo?: boolean
    sizeFrom?: boolean
    sizeTo?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    priceFrom?: boolean
    priceTo?: boolean
    sizeFrom?: boolean
    sizeTo?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectScalar = {
    id?: boolean
    location?: boolean
    listingType?: boolean
    category?: boolean
    subCategory?: boolean
    priceFrom?: boolean
    priceTo?: boolean
    sizeFrom?: boolean
    sizeTo?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location" | "listingType" | "category" | "subCategory" | "priceFrom" | "priceTo" | "sizeFrom" | "sizeTo" | "clientId" | "createdAt" | "updatedAt", ExtArgs["result"]["searchQuery"]>

  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      location: string
      listingType: $Enums.PropertyListingType
      category: string
      subCategory: string | null
      priceFrom: number | null
      priceTo: number | null
      sizeFrom: number | null
      sizeTo: number | null
      clientId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchQueries and returns the data saved in the database.
     * @param {SearchQueryCreateManyAndReturnArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries and returns the data updated in the database.
     * @param {SearchQueryUpdateManyAndReturnArgs} args - Arguments to update many SearchQueries.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchQueryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchQueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly location: FieldRef<"SearchQuery", 'String'>
    readonly listingType: FieldRef<"SearchQuery", 'PropertyListingType'>
    readonly category: FieldRef<"SearchQuery", 'String'>
    readonly subCategory: FieldRef<"SearchQuery", 'String'>
    readonly priceFrom: FieldRef<"SearchQuery", 'Int'>
    readonly priceTo: FieldRef<"SearchQuery", 'Int'>
    readonly sizeFrom: FieldRef<"SearchQuery", 'Int'>
    readonly sizeTo: FieldRef<"SearchQuery", 'Int'>
    readonly clientId: FieldRef<"SearchQuery", 'String'>
    readonly createdAt: FieldRef<"SearchQuery", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery createManyAndReturn
   */
  export type SearchQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery updateManyAndReturn
   */
  export type SearchQueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to delete.
     */
    limit?: number
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
  }


  /**
   * Model ExternalListing
   */

  export type AggregateExternalListing = {
    _count: ExternalListingCountAggregateOutputType | null
    _min: ExternalListingMinAggregateOutputType | null
    _max: ExternalListingMaxAggregateOutputType | null
  }

  export type ExternalListingMinAggregateOutputType = {
    id: string | null
    category: $Enums.ExternalListingCategory | null
    fullName: string | null
    type: string | null
    title: string | null
    description: string | null
    price: string | null
    attributes: string | null
    location: string | null
    phoneNumber: string | null
    email: string | null
    sourceId: string | null
    sourceName: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalListingMaxAggregateOutputType = {
    id: string | null
    category: $Enums.ExternalListingCategory | null
    fullName: string | null
    type: string | null
    title: string | null
    description: string | null
    price: string | null
    attributes: string | null
    location: string | null
    phoneNumber: string | null
    email: string | null
    sourceId: string | null
    sourceName: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalListingCountAggregateOutputType = {
    id: number
    category: number
    fullName: number
    type: number
    title: number
    description: number
    price: number
    attributes: number
    location: number
    phoneNumber: number
    email: number
    sourceId: number
    sourceName: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalListingMinAggregateInputType = {
    id?: true
    category?: true
    fullName?: true
    type?: true
    title?: true
    description?: true
    price?: true
    attributes?: true
    location?: true
    phoneNumber?: true
    email?: true
    sourceId?: true
    sourceName?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalListingMaxAggregateInputType = {
    id?: true
    category?: true
    fullName?: true
    type?: true
    title?: true
    description?: true
    price?: true
    attributes?: true
    location?: true
    phoneNumber?: true
    email?: true
    sourceId?: true
    sourceName?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalListingCountAggregateInputType = {
    id?: true
    category?: true
    fullName?: true
    type?: true
    title?: true
    description?: true
    price?: true
    attributes?: true
    location?: true
    phoneNumber?: true
    email?: true
    sourceId?: true
    sourceName?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalListing to aggregate.
     */
    where?: ExternalListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalListings to fetch.
     */
    orderBy?: ExternalListingOrderByWithRelationInput | ExternalListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalListings
    **/
    _count?: true | ExternalListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalListingMaxAggregateInputType
  }

  export type GetExternalListingAggregateType<T extends ExternalListingAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalListing[P]>
      : GetScalarType<T[P], AggregateExternalListing[P]>
  }




  export type ExternalListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalListingWhereInput
    orderBy?: ExternalListingOrderByWithAggregationInput | ExternalListingOrderByWithAggregationInput[]
    by: ExternalListingScalarFieldEnum[] | ExternalListingScalarFieldEnum
    having?: ExternalListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalListingCountAggregateInputType | true
    _min?: ExternalListingMinAggregateInputType
    _max?: ExternalListingMaxAggregateInputType
  }

  export type ExternalListingGroupByOutputType = {
    id: string
    category: $Enums.ExternalListingCategory
    fullName: string
    type: string
    title: string
    description: string
    price: string
    attributes: string | null
    location: string
    phoneNumber: string | null
    email: string | null
    sourceId: string
    sourceName: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: ExternalListingCountAggregateOutputType | null
    _min: ExternalListingMinAggregateOutputType | null
    _max: ExternalListingMaxAggregateOutputType | null
  }

  type GetExternalListingGroupByPayload<T extends ExternalListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalListingGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalListingGroupByOutputType[P]>
        }
      >
    >


  export type ExternalListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    fullName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    attributes?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    sourceId?: boolean
    sourceName?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["externalListing"]>

  export type ExternalListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    fullName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    attributes?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    sourceId?: boolean
    sourceName?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["externalListing"]>

  export type ExternalListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    fullName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    attributes?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    sourceId?: boolean
    sourceName?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["externalListing"]>

  export type ExternalListingSelectScalar = {
    id?: boolean
    category?: boolean
    fullName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    attributes?: boolean
    location?: boolean
    phoneNumber?: boolean
    email?: boolean
    sourceId?: boolean
    sourceName?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "fullName" | "type" | "title" | "description" | "price" | "attributes" | "location" | "phoneNumber" | "email" | "sourceId" | "sourceName" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["externalListing"]>

  export type $ExternalListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalListing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.ExternalListingCategory
      fullName: string
      type: string
      title: string
      description: string
      price: string
      attributes: string | null
      location: string
      phoneNumber: string | null
      email: string | null
      sourceId: string
      sourceName: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalListing"]>
    composites: {}
  }

  type ExternalListingGetPayload<S extends boolean | null | undefined | ExternalListingDefaultArgs> = $Result.GetResult<Prisma.$ExternalListingPayload, S>

  type ExternalListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ExternalListingCountAggregateInputType | true
    }

  export interface ExternalListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalListing'], meta: { name: 'ExternalListing' } }
    /**
     * Find zero or one ExternalListing that matches the filter.
     * @param {ExternalListingFindUniqueArgs} args - Arguments to find a ExternalListing
     * @example
     * // Get one ExternalListing
     * const externalListing = await prisma.externalListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalListingFindUniqueArgs>(args: SelectSubset<T, ExternalListingFindUniqueArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalListingFindUniqueOrThrowArgs} args - Arguments to find a ExternalListing
     * @example
     * // Get one ExternalListing
     * const externalListing = await prisma.externalListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingFindFirstArgs} args - Arguments to find a ExternalListing
     * @example
     * // Get one ExternalListing
     * const externalListing = await prisma.externalListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalListingFindFirstArgs>(args?: SelectSubset<T, ExternalListingFindFirstArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingFindFirstOrThrowArgs} args - Arguments to find a ExternalListing
     * @example
     * // Get one ExternalListing
     * const externalListing = await prisma.externalListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalListings
     * const externalListings = await prisma.externalListing.findMany()
     * 
     * // Get first 10 ExternalListings
     * const externalListings = await prisma.externalListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalListingWithIdOnly = await prisma.externalListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalListingFindManyArgs>(args?: SelectSubset<T, ExternalListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalListing.
     * @param {ExternalListingCreateArgs} args - Arguments to create a ExternalListing.
     * @example
     * // Create one ExternalListing
     * const ExternalListing = await prisma.externalListing.create({
     *   data: {
     *     // ... data to create a ExternalListing
     *   }
     * })
     * 
     */
    create<T extends ExternalListingCreateArgs>(args: SelectSubset<T, ExternalListingCreateArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalListings.
     * @param {ExternalListingCreateManyArgs} args - Arguments to create many ExternalListings.
     * @example
     * // Create many ExternalListings
     * const externalListing = await prisma.externalListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalListingCreateManyArgs>(args?: SelectSubset<T, ExternalListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalListings and returns the data saved in the database.
     * @param {ExternalListingCreateManyAndReturnArgs} args - Arguments to create many ExternalListings.
     * @example
     * // Create many ExternalListings
     * const externalListing = await prisma.externalListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalListings and only return the `id`
     * const externalListingWithIdOnly = await prisma.externalListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExternalListing.
     * @param {ExternalListingDeleteArgs} args - Arguments to delete one ExternalListing.
     * @example
     * // Delete one ExternalListing
     * const ExternalListing = await prisma.externalListing.delete({
     *   where: {
     *     // ... filter to delete one ExternalListing
     *   }
     * })
     * 
     */
    delete<T extends ExternalListingDeleteArgs>(args: SelectSubset<T, ExternalListingDeleteArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalListing.
     * @param {ExternalListingUpdateArgs} args - Arguments to update one ExternalListing.
     * @example
     * // Update one ExternalListing
     * const externalListing = await prisma.externalListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalListingUpdateArgs>(args: SelectSubset<T, ExternalListingUpdateArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalListings.
     * @param {ExternalListingDeleteManyArgs} args - Arguments to filter ExternalListings to delete.
     * @example
     * // Delete a few ExternalListings
     * const { count } = await prisma.externalListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalListingDeleteManyArgs>(args?: SelectSubset<T, ExternalListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalListings
     * const externalListing = await prisma.externalListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalListingUpdateManyArgs>(args: SelectSubset<T, ExternalListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalListings and returns the data updated in the database.
     * @param {ExternalListingUpdateManyAndReturnArgs} args - Arguments to update many ExternalListings.
     * @example
     * // Update many ExternalListings
     * const externalListing = await prisma.externalListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalListings and only return the `id`
     * const externalListingWithIdOnly = await prisma.externalListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalListingUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExternalListing.
     * @param {ExternalListingUpsertArgs} args - Arguments to update or create a ExternalListing.
     * @example
     * // Update or create a ExternalListing
     * const externalListing = await prisma.externalListing.upsert({
     *   create: {
     *     // ... data to create a ExternalListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalListing we want to update
     *   }
     * })
     */
    upsert<T extends ExternalListingUpsertArgs>(args: SelectSubset<T, ExternalListingUpsertArgs<ExtArgs>>): Prisma__ExternalListingClient<$Result.GetResult<Prisma.$ExternalListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingCountArgs} args - Arguments to filter ExternalListings to count.
     * @example
     * // Count the number of ExternalListings
     * const count = await prisma.externalListing.count({
     *   where: {
     *     // ... the filter for the ExternalListings we want to count
     *   }
     * })
    **/
    count<T extends ExternalListingCountArgs>(
      args?: Subset<T, ExternalListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalListingAggregateArgs>(args: Subset<T, ExternalListingAggregateArgs>): Prisma.PrismaPromise<GetExternalListingAggregateType<T>>

    /**
     * Group by ExternalListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalListingGroupByArgs['orderBy'] }
        : { orderBy?: ExternalListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalListing model
   */
  readonly fields: ExternalListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalListing model
   */
  interface ExternalListingFieldRefs {
    readonly id: FieldRef<"ExternalListing", 'String'>
    readonly category: FieldRef<"ExternalListing", 'ExternalListingCategory'>
    readonly fullName: FieldRef<"ExternalListing", 'String'>
    readonly type: FieldRef<"ExternalListing", 'String'>
    readonly title: FieldRef<"ExternalListing", 'String'>
    readonly description: FieldRef<"ExternalListing", 'String'>
    readonly price: FieldRef<"ExternalListing", 'String'>
    readonly attributes: FieldRef<"ExternalListing", 'String'>
    readonly location: FieldRef<"ExternalListing", 'String'>
    readonly phoneNumber: FieldRef<"ExternalListing", 'String'>
    readonly email: FieldRef<"ExternalListing", 'String'>
    readonly sourceId: FieldRef<"ExternalListing", 'String'>
    readonly sourceName: FieldRef<"ExternalListing", 'String'>
    readonly url: FieldRef<"ExternalListing", 'String'>
    readonly createdAt: FieldRef<"ExternalListing", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalListing findUnique
   */
  export type ExternalListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter, which ExternalListing to fetch.
     */
    where: ExternalListingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing findUniqueOrThrow
   */
  export type ExternalListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter, which ExternalListing to fetch.
     */
    where: ExternalListingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing findFirst
   */
  export type ExternalListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter, which ExternalListing to fetch.
     */
    where?: ExternalListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalListings to fetch.
     */
    orderBy?: ExternalListingOrderByWithRelationInput | ExternalListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalListings.
     */
    cursor?: ExternalListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalListings.
     */
    distinct?: ExternalListingScalarFieldEnum | ExternalListingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing findFirstOrThrow
   */
  export type ExternalListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter, which ExternalListing to fetch.
     */
    where?: ExternalListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalListings to fetch.
     */
    orderBy?: ExternalListingOrderByWithRelationInput | ExternalListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalListings.
     */
    cursor?: ExternalListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalListings.
     */
    distinct?: ExternalListingScalarFieldEnum | ExternalListingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing findMany
   */
  export type ExternalListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter, which ExternalListings to fetch.
     */
    where?: ExternalListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalListings to fetch.
     */
    orderBy?: ExternalListingOrderByWithRelationInput | ExternalListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalListings.
     */
    cursor?: ExternalListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalListings.
     */
    skip?: number
    distinct?: ExternalListingScalarFieldEnum | ExternalListingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing create
   */
  export type ExternalListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * The data needed to create a ExternalListing.
     */
    data: XOR<ExternalListingCreateInput, ExternalListingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing createMany
   */
  export type ExternalListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalListings.
     */
    data: ExternalListingCreateManyInput | ExternalListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalListing createManyAndReturn
   */
  export type ExternalListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalListings.
     */
    data: ExternalListingCreateManyInput | ExternalListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalListing update
   */
  export type ExternalListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * The data needed to update a ExternalListing.
     */
    data: XOR<ExternalListingUpdateInput, ExternalListingUncheckedUpdateInput>
    /**
     * Choose, which ExternalListing to update.
     */
    where: ExternalListingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing updateMany
   */
  export type ExternalListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalListings.
     */
    data: XOR<ExternalListingUpdateManyMutationInput, ExternalListingUncheckedUpdateManyInput>
    /**
     * Filter which ExternalListings to update
     */
    where?: ExternalListingWhereInput
    /**
     * Limit how many ExternalListings to update.
     */
    limit?: number
  }

  /**
   * ExternalListing updateManyAndReturn
   */
  export type ExternalListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * The data used to update ExternalListings.
     */
    data: XOR<ExternalListingUpdateManyMutationInput, ExternalListingUncheckedUpdateManyInput>
    /**
     * Filter which ExternalListings to update
     */
    where?: ExternalListingWhereInput
    /**
     * Limit how many ExternalListings to update.
     */
    limit?: number
  }

  /**
   * ExternalListing upsert
   */
  export type ExternalListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * The filter to search for the ExternalListing to update in case it exists.
     */
    where: ExternalListingWhereUniqueInput
    /**
     * In case the ExternalListing found by the `where` argument doesn't exist, create a new ExternalListing with this data.
     */
    create: XOR<ExternalListingCreateInput, ExternalListingUncheckedCreateInput>
    /**
     * In case the ExternalListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalListingUpdateInput, ExternalListingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing delete
   */
  export type ExternalListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
    /**
     * Filter which ExternalListing to delete.
     */
    where: ExternalListingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ExternalListing deleteMany
   */
  export type ExternalListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalListings to delete
     */
    where?: ExternalListingWhereInput
    /**
     * Limit how many ExternalListings to delete.
     */
    limit?: number
  }

  /**
   * ExternalListing without action
   */
  export type ExternalListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalListing
     */
    select?: ExternalListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalListing
     */
    omit?: ExternalListingOmit<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    price: number | null
    approximatePrice: number | null
    estimationPrice: number | null
    size: number | null
  }

  export type PropertySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    price: number | null
    approximatePrice: number | null
    estimationPrice: number | null
    size: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    latitude: number | null
    address: string | null
    longitude: number | null
    agencyId: string | null
    status: $Enums.PropertyStatus | null
    price: number | null
    hasApproximatePrice: boolean | null
    approximatePrice: number | null
    estimationPrice: number | null
    size: number | null
    slug: string | null
    video: string | null
    createdAt: Date | null
    createdBy: string | null
    createdByMemberId: string | null
    updatedAt: Date | null
    yearBuilt: Date | null
    remarks: string | null
    builder: string | null
    propertyCadastralMunicipality: string | null
    propertyDeed: string | null
    inDevelopment: boolean | null
    inDevelopmentUntil: Date | null
    featured: boolean | null
    featuredUntil: Date | null
    orientation: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    propertyLocationId: string | null
    categoryId: string | null
    subcategoryId: string | null
    ownerId: string | null
    renterId: string | null
    externalId: string | null
    autoRenewEnabled: boolean | null
    autoRenewStartDate: Date | null
    autoRenewEndDate: Date | null
    lastAutoRenewedAt: Date | null
    bumpedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    latitude: number | null
    address: string | null
    longitude: number | null
    agencyId: string | null
    status: $Enums.PropertyStatus | null
    price: number | null
    hasApproximatePrice: boolean | null
    approximatePrice: number | null
    estimationPrice: number | null
    size: number | null
    slug: string | null
    video: string | null
    createdAt: Date | null
    createdBy: string | null
    createdByMemberId: string | null
    updatedAt: Date | null
    yearBuilt: Date | null
    remarks: string | null
    builder: string | null
    propertyCadastralMunicipality: string | null
    propertyDeed: string | null
    inDevelopment: boolean | null
    inDevelopmentUntil: Date | null
    featured: boolean | null
    featuredUntil: Date | null
    orientation: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    propertyLocationId: string | null
    categoryId: string | null
    subcategoryId: string | null
    ownerId: string | null
    renterId: string | null
    externalId: string | null
    autoRenewEnabled: boolean | null
    autoRenewStartDate: Date | null
    autoRenewEndDate: Date | null
    lastAutoRenewedAt: Date | null
    bumpedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    latitude: number
    address: number
    longitude: number
    agencyId: number
    status: number
    price: number
    hasApproximatePrice: number
    approximatePrice: number
    estimationPrice: number
    size: number
    description: number
    slug: number
    photos: number
    video: number
    createdAt: number
    createdBy: number
    createdByMemberId: number
    updatedAt: number
    attributes: number
    yearBuilt: number
    remarks: number
    builder: number
    propertyCadastralMunicipality: number
    propertyDeed: number
    inDevelopment: number
    inDevelopmentUntil: number
    propertyPlan: number
    poi: number
    featured: number
    featuredUntil: number
    orientation: number
    type: number
    listingType: number
    propertyLocationId: number
    modifications: number
    categoryId: number
    subcategoryId: number
    ownerId: number
    renterId: number
    externalId: number
    autoRenewEnabled: number
    autoRenewStartDate: number
    autoRenewEndDate: number
    lastAutoRenewedAt: number
    bumpedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    price?: true
    approximatePrice?: true
    estimationPrice?: true
    size?: true
  }

  export type PropertySumAggregateInputType = {
    latitude?: true
    longitude?: true
    price?: true
    approximatePrice?: true
    estimationPrice?: true
    size?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    latitude?: true
    address?: true
    longitude?: true
    agencyId?: true
    status?: true
    price?: true
    hasApproximatePrice?: true
    approximatePrice?: true
    estimationPrice?: true
    size?: true
    slug?: true
    video?: true
    createdAt?: true
    createdBy?: true
    createdByMemberId?: true
    updatedAt?: true
    yearBuilt?: true
    remarks?: true
    builder?: true
    propertyCadastralMunicipality?: true
    propertyDeed?: true
    inDevelopment?: true
    inDevelopmentUntil?: true
    featured?: true
    featuredUntil?: true
    orientation?: true
    type?: true
    listingType?: true
    propertyLocationId?: true
    categoryId?: true
    subcategoryId?: true
    ownerId?: true
    renterId?: true
    externalId?: true
    autoRenewEnabled?: true
    autoRenewStartDate?: true
    autoRenewEndDate?: true
    lastAutoRenewedAt?: true
    bumpedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    latitude?: true
    address?: true
    longitude?: true
    agencyId?: true
    status?: true
    price?: true
    hasApproximatePrice?: true
    approximatePrice?: true
    estimationPrice?: true
    size?: true
    slug?: true
    video?: true
    createdAt?: true
    createdBy?: true
    createdByMemberId?: true
    updatedAt?: true
    yearBuilt?: true
    remarks?: true
    builder?: true
    propertyCadastralMunicipality?: true
    propertyDeed?: true
    inDevelopment?: true
    inDevelopmentUntil?: true
    featured?: true
    featuredUntil?: true
    orientation?: true
    type?: true
    listingType?: true
    propertyLocationId?: true
    categoryId?: true
    subcategoryId?: true
    ownerId?: true
    renterId?: true
    externalId?: true
    autoRenewEnabled?: true
    autoRenewStartDate?: true
    autoRenewEndDate?: true
    lastAutoRenewedAt?: true
    bumpedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    address?: true
    longitude?: true
    agencyId?: true
    status?: true
    price?: true
    hasApproximatePrice?: true
    approximatePrice?: true
    estimationPrice?: true
    size?: true
    description?: true
    slug?: true
    photos?: true
    video?: true
    createdAt?: true
    createdBy?: true
    createdByMemberId?: true
    updatedAt?: true
    attributes?: true
    yearBuilt?: true
    remarks?: true
    builder?: true
    propertyCadastralMunicipality?: true
    propertyDeed?: true
    inDevelopment?: true
    inDevelopmentUntil?: true
    propertyPlan?: true
    poi?: true
    featured?: true
    featuredUntil?: true
    orientation?: true
    type?: true
    listingType?: true
    propertyLocationId?: true
    modifications?: true
    categoryId?: true
    subcategoryId?: true
    ownerId?: true
    renterId?: true
    externalId?: true
    autoRenewEnabled?: true
    autoRenewStartDate?: true
    autoRenewEndDate?: true
    lastAutoRenewedAt?: true
    bumpedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: JsonValue
    latitude: number
    address: string
    longitude: number
    agencyId: string | null
    status: $Enums.PropertyStatus
    price: number
    hasApproximatePrice: boolean | null
    approximatePrice: number | null
    estimationPrice: number | null
    size: number
    description: JsonValue
    slug: string | null
    photos: JsonValue | null
    video: string | null
    createdAt: Date
    createdBy: string
    createdByMemberId: string | null
    updatedAt: Date
    attributes: JsonValue | null
    yearBuilt: Date | null
    remarks: string | null
    builder: string | null
    propertyCadastralMunicipality: string | null
    propertyDeed: string | null
    inDevelopment: boolean | null
    inDevelopmentUntil: Date | null
    propertyPlan: JsonValue | null
    poi: JsonValue | null
    featured: boolean
    featuredUntil: Date | null
    orientation: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId: string | null
    modifications: JsonValue | null
    categoryId: string | null
    subcategoryId: string | null
    ownerId: string | null
    renterId: string | null
    externalId: string | null
    autoRenewEnabled: boolean
    autoRenewStartDate: Date | null
    autoRenewEndDate: Date | null
    lastAutoRenewedAt: Date | null
    bumpedAt: Date | null
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    address?: boolean
    longitude?: boolean
    agencyId?: boolean
    status?: boolean
    price?: boolean
    hasApproximatePrice?: boolean
    approximatePrice?: boolean
    estimationPrice?: boolean
    size?: boolean
    description?: boolean
    slug?: boolean
    photos?: boolean
    video?: boolean
    createdAt?: boolean
    createdBy?: boolean
    createdByMemberId?: boolean
    updatedAt?: boolean
    attributes?: boolean
    yearBuilt?: boolean
    remarks?: boolean
    builder?: boolean
    propertyCadastralMunicipality?: boolean
    propertyDeed?: boolean
    inDevelopment?: boolean
    inDevelopmentUntil?: boolean
    propertyPlan?: boolean
    poi?: boolean
    featured?: boolean
    featuredUntil?: boolean
    orientation?: boolean
    type?: boolean
    listingType?: boolean
    propertyLocationId?: boolean
    modifications?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    ownerId?: boolean
    renterId?: boolean
    externalId?: boolean
    autoRenewEnabled?: boolean
    autoRenewStartDate?: boolean
    autoRenewEndDate?: boolean
    lastAutoRenewedAt?: boolean
    bumpedAt?: boolean
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    views?: boolean | Property$viewsArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    PropertyFavorite?: boolean | Property$PropertyFavoriteArgs<ExtArgs>
    PropertySale?: boolean | Property$PropertySaleArgs<ExtArgs>
    PropertyEngagement?: boolean | Property$PropertyEngagementArgs<ExtArgs>
    propertyReview?: boolean | Property$propertyReviewArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    address?: boolean
    longitude?: boolean
    agencyId?: boolean
    status?: boolean
    price?: boolean
    hasApproximatePrice?: boolean
    approximatePrice?: boolean
    estimationPrice?: boolean
    size?: boolean
    description?: boolean
    slug?: boolean
    photos?: boolean
    video?: boolean
    createdAt?: boolean
    createdBy?: boolean
    createdByMemberId?: boolean
    updatedAt?: boolean
    attributes?: boolean
    yearBuilt?: boolean
    remarks?: boolean
    builder?: boolean
    propertyCadastralMunicipality?: boolean
    propertyDeed?: boolean
    inDevelopment?: boolean
    inDevelopmentUntil?: boolean
    propertyPlan?: boolean
    poi?: boolean
    featured?: boolean
    featuredUntil?: boolean
    orientation?: boolean
    type?: boolean
    listingType?: boolean
    propertyLocationId?: boolean
    modifications?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    ownerId?: boolean
    renterId?: boolean
    externalId?: boolean
    autoRenewEnabled?: boolean
    autoRenewStartDate?: boolean
    autoRenewEndDate?: boolean
    lastAutoRenewedAt?: boolean
    bumpedAt?: boolean
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    address?: boolean
    longitude?: boolean
    agencyId?: boolean
    status?: boolean
    price?: boolean
    hasApproximatePrice?: boolean
    approximatePrice?: boolean
    estimationPrice?: boolean
    size?: boolean
    description?: boolean
    slug?: boolean
    photos?: boolean
    video?: boolean
    createdAt?: boolean
    createdBy?: boolean
    createdByMemberId?: boolean
    updatedAt?: boolean
    attributes?: boolean
    yearBuilt?: boolean
    remarks?: boolean
    builder?: boolean
    propertyCadastralMunicipality?: boolean
    propertyDeed?: boolean
    inDevelopment?: boolean
    inDevelopmentUntil?: boolean
    propertyPlan?: boolean
    poi?: boolean
    featured?: boolean
    featuredUntil?: boolean
    orientation?: boolean
    type?: boolean
    listingType?: boolean
    propertyLocationId?: boolean
    modifications?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    ownerId?: boolean
    renterId?: boolean
    externalId?: boolean
    autoRenewEnabled?: boolean
    autoRenewStartDate?: boolean
    autoRenewEndDate?: boolean
    lastAutoRenewedAt?: boolean
    bumpedAt?: boolean
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    latitude?: boolean
    address?: boolean
    longitude?: boolean
    agencyId?: boolean
    status?: boolean
    price?: boolean
    hasApproximatePrice?: boolean
    approximatePrice?: boolean
    estimationPrice?: boolean
    size?: boolean
    description?: boolean
    slug?: boolean
    photos?: boolean
    video?: boolean
    createdAt?: boolean
    createdBy?: boolean
    createdByMemberId?: boolean
    updatedAt?: boolean
    attributes?: boolean
    yearBuilt?: boolean
    remarks?: boolean
    builder?: boolean
    propertyCadastralMunicipality?: boolean
    propertyDeed?: boolean
    inDevelopment?: boolean
    inDevelopmentUntil?: boolean
    propertyPlan?: boolean
    poi?: boolean
    featured?: boolean
    featuredUntil?: boolean
    orientation?: boolean
    type?: boolean
    listingType?: boolean
    propertyLocationId?: boolean
    modifications?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    ownerId?: boolean
    renterId?: boolean
    externalId?: boolean
    autoRenewEnabled?: boolean
    autoRenewStartDate?: boolean
    autoRenewEndDate?: boolean
    lastAutoRenewedAt?: boolean
    bumpedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "latitude" | "address" | "longitude" | "agencyId" | "status" | "price" | "hasApproximatePrice" | "approximatePrice" | "estimationPrice" | "size" | "description" | "slug" | "photos" | "video" | "createdAt" | "createdBy" | "createdByMemberId" | "updatedAt" | "attributes" | "yearBuilt" | "remarks" | "builder" | "propertyCadastralMunicipality" | "propertyDeed" | "inDevelopment" | "inDevelopmentUntil" | "propertyPlan" | "poi" | "featured" | "featuredUntil" | "orientation" | "type" | "listingType" | "propertyLocationId" | "modifications" | "categoryId" | "subcategoryId" | "ownerId" | "renterId" | "externalId" | "autoRenewEnabled" | "autoRenewStartDate" | "autoRenewEndDate" | "lastAutoRenewedAt" | "bumpedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    views?: boolean | Property$viewsArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    PropertyFavorite?: boolean | Property$PropertyFavoriteArgs<ExtArgs>
    PropertySale?: boolean | Property$PropertySaleArgs<ExtArgs>
    PropertyEngagement?: boolean | Property$PropertyEngagementArgs<ExtArgs>
    propertyReview?: boolean | Property$propertyReviewArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByMember?: boolean | Property$createdByMemberArgs<ExtArgs>
    agency?: boolean | Property$agencyArgs<ExtArgs>
    propertyLocation?: boolean | Property$propertyLocationArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    subcategory?: boolean | Property$subcategoryArgs<ExtArgs>
    owner?: boolean | Property$ownerArgs<ExtArgs>
    renter?: boolean | Property$renterArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      createdByMember: Prisma.$AgencyMemberPayload<ExtArgs> | null
      views: Prisma.$PropertyViewPayload<ExtArgs>[]
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      PropertyFavorite: Prisma.$PropertyFavoritePayload<ExtArgs>[]
      PropertySale: Prisma.$PropertySalePayload<ExtArgs> | null
      PropertyEngagement: Prisma.$PropertyEngagementPayload<ExtArgs>[]
      propertyReview: Prisma.$PropertySubmissionReviewPayload<ExtArgs>[]
      propertyLocation: Prisma.$PropertyLocationPayload<ExtArgs> | null
      category: Prisma.$PropertyCategoryPayload<ExtArgs> | null
      subcategory: Prisma.$PropertySubcategoryPayload<ExtArgs> | null
      owner: Prisma.$AgencyClientPayload<ExtArgs> | null
      renter: Prisma.$AgencyClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: Prisma.JsonValue
      latitude: number
      address: string
      longitude: number
      agencyId: string | null
      status: $Enums.PropertyStatus
      price: number
      hasApproximatePrice: boolean | null
      approximatePrice: number | null
      estimationPrice: number | null
      size: number
      description: Prisma.JsonValue
      slug: string | null
      photos: Prisma.JsonValue | null
      video: string | null
      createdAt: Date
      createdBy: string
      createdByMemberId: string | null
      updatedAt: Date
      attributes: Prisma.JsonValue | null
      yearBuilt: Date | null
      remarks: string | null
      builder: string | null
      propertyCadastralMunicipality: string | null
      propertyDeed: string | null
      inDevelopment: boolean | null
      inDevelopmentUntil: Date | null
      propertyPlan: Prisma.JsonValue | null
      poi: Prisma.JsonValue | null
      featured: boolean
      featuredUntil: Date | null
      orientation: $Enums.PropertyOrientation | null
      type: $Enums.PropertyType
      listingType: $Enums.PropertyListingType
      propertyLocationId: string | null
      modifications: Prisma.JsonValue | null
      categoryId: string | null
      subcategoryId: string | null
      ownerId: string | null
      renterId: string | null
      externalId: string | null
      autoRenewEnabled: boolean
      autoRenewStartDate: Date | null
      autoRenewEndDate: Date | null
      lastAutoRenewedAt: Date | null
      bumpedAt: Date | null
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByMember<T extends Property$createdByMemberArgs<ExtArgs> = {}>(args?: Subset<T, Property$createdByMemberArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    views<T extends Property$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Property$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agency<T extends Property$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Property$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PropertyFavorite<T extends Property$PropertyFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertyFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertySale<T extends Property$PropertySaleArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertySaleArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PropertyEngagement<T extends Property$PropertyEngagementArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertyEngagementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyReview<T extends Property$propertyReviewArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyLocation<T extends Property$propertyLocationArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyLocationArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Property$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Property$categoryArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends Property$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, Property$subcategoryArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends Property$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Property$ownerArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    renter<T extends Property$renterArgs<ExtArgs> = {}>(args?: Subset<T, Property$renterArgs<ExtArgs>>): Prisma__AgencyClientClient<$Result.GetResult<Prisma.$AgencyClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'Json'>
    readonly latitude: FieldRef<"Property", 'Float'>
    readonly address: FieldRef<"Property", 'String'>
    readonly longitude: FieldRef<"Property", 'Float'>
    readonly agencyId: FieldRef<"Property", 'String'>
    readonly status: FieldRef<"Property", 'PropertyStatus'>
    readonly price: FieldRef<"Property", 'Int'>
    readonly hasApproximatePrice: FieldRef<"Property", 'Boolean'>
    readonly approximatePrice: FieldRef<"Property", 'Int'>
    readonly estimationPrice: FieldRef<"Property", 'Int'>
    readonly size: FieldRef<"Property", 'Int'>
    readonly description: FieldRef<"Property", 'Json'>
    readonly slug: FieldRef<"Property", 'String'>
    readonly photos: FieldRef<"Property", 'Json'>
    readonly video: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly createdBy: FieldRef<"Property", 'String'>
    readonly createdByMemberId: FieldRef<"Property", 'String'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly attributes: FieldRef<"Property", 'Json'>
    readonly yearBuilt: FieldRef<"Property", 'DateTime'>
    readonly remarks: FieldRef<"Property", 'String'>
    readonly builder: FieldRef<"Property", 'String'>
    readonly propertyCadastralMunicipality: FieldRef<"Property", 'String'>
    readonly propertyDeed: FieldRef<"Property", 'String'>
    readonly inDevelopment: FieldRef<"Property", 'Boolean'>
    readonly inDevelopmentUntil: FieldRef<"Property", 'DateTime'>
    readonly propertyPlan: FieldRef<"Property", 'Json'>
    readonly poi: FieldRef<"Property", 'Json'>
    readonly featured: FieldRef<"Property", 'Boolean'>
    readonly featuredUntil: FieldRef<"Property", 'DateTime'>
    readonly orientation: FieldRef<"Property", 'PropertyOrientation'>
    readonly type: FieldRef<"Property", 'PropertyType'>
    readonly listingType: FieldRef<"Property", 'PropertyListingType'>
    readonly propertyLocationId: FieldRef<"Property", 'String'>
    readonly modifications: FieldRef<"Property", 'Json'>
    readonly categoryId: FieldRef<"Property", 'String'>
    readonly subcategoryId: FieldRef<"Property", 'String'>
    readonly ownerId: FieldRef<"Property", 'String'>
    readonly renterId: FieldRef<"Property", 'String'>
    readonly externalId: FieldRef<"Property", 'String'>
    readonly autoRenewEnabled: FieldRef<"Property", 'Boolean'>
    readonly autoRenewStartDate: FieldRef<"Property", 'DateTime'>
    readonly autoRenewEndDate: FieldRef<"Property", 'DateTime'>
    readonly lastAutoRenewedAt: FieldRef<"Property", 'DateTime'>
    readonly bumpedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.createdByMember
   */
  export type Property$createdByMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    where?: AgencyMemberWhereInput
  }

  /**
   * Property.views
   */
  export type Property$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * Property.agency
   */
  export type Property$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Property.PropertyFavorite
   */
  export type Property$PropertyFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    where?: PropertyFavoriteWhereInput
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    cursor?: PropertyFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyFavoriteScalarFieldEnum | PropertyFavoriteScalarFieldEnum[]
  }

  /**
   * Property.PropertySale
   */
  export type Property$PropertySaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    where?: PropertySaleWhereInput
  }

  /**
   * Property.PropertyEngagement
   */
  export type Property$PropertyEngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    where?: PropertyEngagementWhereInput
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    cursor?: PropertyEngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyEngagementScalarFieldEnum | PropertyEngagementScalarFieldEnum[]
  }

  /**
   * Property.propertyReview
   */
  export type Property$propertyReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    where?: PropertySubmissionReviewWhereInput
    orderBy?: PropertySubmissionReviewOrderByWithRelationInput | PropertySubmissionReviewOrderByWithRelationInput[]
    cursor?: PropertySubmissionReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertySubmissionReviewScalarFieldEnum | PropertySubmissionReviewScalarFieldEnum[]
  }

  /**
   * Property.propertyLocation
   */
  export type Property$propertyLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    where?: PropertyLocationWhereInput
  }

  /**
   * Property.category
   */
  export type Property$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    where?: PropertyCategoryWhereInput
  }

  /**
   * Property.subcategory
   */
  export type Property$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    where?: PropertySubcategoryWhereInput
  }

  /**
   * Property.owner
   */
  export type Property$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    where?: AgencyClientWhereInput
  }

  /**
   * Property.renter
   */
  export type Property$renterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyClient
     */
    select?: AgencyClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyClient
     */
    omit?: AgencyClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyClientInclude<ExtArgs> | null
    where?: AgencyClientWhereInput
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model PropertyCategory
   */

  export type AggregatePropertyCategory = {
    _count: PropertyCategoryCountAggregateOutputType | null
    _min: PropertyCategoryMinAggregateOutputType | null
    _max: PropertyCategoryMaxAggregateOutputType | null
  }

  export type PropertyCategoryMinAggregateOutputType = {
    id: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCategoryMaxAggregateOutputType = {
    id: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCategoryCountAggregateOutputType = {
    id: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyCategoryMinAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCategoryMaxAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCategoryCountAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategory to aggregate.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyCategories
    **/
    _count?: true | PropertyCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyCategoryMaxAggregateInputType
  }

  export type GetPropertyCategoryAggregateType<T extends PropertyCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyCategory[P]>
      : GetScalarType<T[P], AggregatePropertyCategory[P]>
  }




  export type PropertyCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyCategoryWhereInput
    orderBy?: PropertyCategoryOrderByWithAggregationInput | PropertyCategoryOrderByWithAggregationInput[]
    by: PropertyCategoryScalarFieldEnum[] | PropertyCategoryScalarFieldEnum
    having?: PropertyCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCategoryCountAggregateInputType | true
    _min?: PropertyCategoryMinAggregateInputType
    _max?: PropertyCategoryMaxAggregateInputType
  }

  export type PropertyCategoryGroupByOutputType = {
    id: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyCategoryCountAggregateOutputType | null
    _min: PropertyCategoryMinAggregateOutputType | null
    _max: PropertyCategoryMaxAggregateOutputType | null
  }

  type GetPropertyCategoryGroupByPayload<T extends PropertyCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PropertyCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    properties?: boolean | PropertyCategory$propertiesArgs<ExtArgs>
    subcategories?: boolean | PropertyCategory$subcategoriesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectScalar = {
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyCategory"]>
  export type PropertyCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategory$propertiesArgs<ExtArgs>
    subcategories?: boolean | PropertyCategory$subcategoriesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyCategory"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      subcategories: Prisma.$PropertySubcategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyCategory"]>
    composites: {}
  }

  type PropertyCategoryGetPayload<S extends boolean | null | undefined | PropertyCategoryDefaultArgs> = $Result.GetResult<Prisma.$PropertyCategoryPayload, S>

  type PropertyCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyCategoryCountAggregateInputType | true
    }

  export interface PropertyCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyCategory'], meta: { name: 'PropertyCategory' } }
    /**
     * Find zero or one PropertyCategory that matches the filter.
     * @param {PropertyCategoryFindUniqueArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyCategoryFindUniqueArgs>(args: SelectSubset<T, PropertyCategoryFindUniqueArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyCategoryFindUniqueOrThrowArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindFirstArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyCategoryFindFirstArgs>(args?: SelectSubset<T, PropertyCategoryFindFirstArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindFirstOrThrowArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyCategories
     * const propertyCategories = await prisma.propertyCategory.findMany()
     * 
     * // Get first 10 PropertyCategories
     * const propertyCategories = await prisma.propertyCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyCategoryFindManyArgs>(args?: SelectSubset<T, PropertyCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyCategory.
     * @param {PropertyCategoryCreateArgs} args - Arguments to create a PropertyCategory.
     * @example
     * // Create one PropertyCategory
     * const PropertyCategory = await prisma.propertyCategory.create({
     *   data: {
     *     // ... data to create a PropertyCategory
     *   }
     * })
     * 
     */
    create<T extends PropertyCategoryCreateArgs>(args: SelectSubset<T, PropertyCategoryCreateArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyCategories.
     * @param {PropertyCategoryCreateManyArgs} args - Arguments to create many PropertyCategories.
     * @example
     * // Create many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCategoryCreateManyArgs>(args?: SelectSubset<T, PropertyCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyCategories and returns the data saved in the database.
     * @param {PropertyCategoryCreateManyAndReturnArgs} args - Arguments to create many PropertyCategories.
     * @example
     * // Create many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyCategories and only return the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyCategory.
     * @param {PropertyCategoryDeleteArgs} args - Arguments to delete one PropertyCategory.
     * @example
     * // Delete one PropertyCategory
     * const PropertyCategory = await prisma.propertyCategory.delete({
     *   where: {
     *     // ... filter to delete one PropertyCategory
     *   }
     * })
     * 
     */
    delete<T extends PropertyCategoryDeleteArgs>(args: SelectSubset<T, PropertyCategoryDeleteArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyCategory.
     * @param {PropertyCategoryUpdateArgs} args - Arguments to update one PropertyCategory.
     * @example
     * // Update one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyCategoryUpdateArgs>(args: SelectSubset<T, PropertyCategoryUpdateArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyCategories.
     * @param {PropertyCategoryDeleteManyArgs} args - Arguments to filter PropertyCategories to delete.
     * @example
     * // Delete a few PropertyCategories
     * const { count } = await prisma.propertyCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyCategoryDeleteManyArgs>(args?: SelectSubset<T, PropertyCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyCategoryUpdateManyArgs>(args: SelectSubset<T, PropertyCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategories and returns the data updated in the database.
     * @param {PropertyCategoryUpdateManyAndReturnArgs} args - Arguments to update many PropertyCategories.
     * @example
     * // Update many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyCategories and only return the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyCategory.
     * @param {PropertyCategoryUpsertArgs} args - Arguments to update or create a PropertyCategory.
     * @example
     * // Update or create a PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.upsert({
     *   create: {
     *     // ... data to create a PropertyCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyCategory we want to update
     *   }
     * })
     */
    upsert<T extends PropertyCategoryUpsertArgs>(args: SelectSubset<T, PropertyCategoryUpsertArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryCountArgs} args - Arguments to filter PropertyCategories to count.
     * @example
     * // Count the number of PropertyCategories
     * const count = await prisma.propertyCategory.count({
     *   where: {
     *     // ... the filter for the PropertyCategories we want to count
     *   }
     * })
    **/
    count<T extends PropertyCategoryCountArgs>(
      args?: Subset<T, PropertyCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyCategoryAggregateArgs>(args: Subset<T, PropertyCategoryAggregateArgs>): Prisma.PrismaPromise<GetPropertyCategoryAggregateType<T>>

    /**
     * Group by PropertyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PropertyCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyCategory model
   */
  readonly fields: PropertyCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends PropertyCategory$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyCategory$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends PropertyCategory$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyCategory$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyCategory model
   */
  interface PropertyCategoryFieldRefs {
    readonly id: FieldRef<"PropertyCategory", 'String'>
    readonly value: FieldRef<"PropertyCategory", 'String'>
    readonly createdAt: FieldRef<"PropertyCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyCategory findUnique
   */
  export type PropertyCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where: PropertyCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory findUniqueOrThrow
   */
  export type PropertyCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where: PropertyCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory findFirst
   */
  export type PropertyCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategories.
     */
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory findFirstOrThrow
   */
  export type PropertyCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategories.
     */
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory findMany
   */
  export type PropertyCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategories to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory create
   */
  export type PropertyCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyCategory.
     */
    data: XOR<PropertyCategoryCreateInput, PropertyCategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory createMany
   */
  export type PropertyCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyCategories.
     */
    data: PropertyCategoryCreateManyInput | PropertyCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategory createManyAndReturn
   */
  export type PropertyCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyCategories.
     */
    data: PropertyCategoryCreateManyInput | PropertyCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategory update
   */
  export type PropertyCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyCategory.
     */
    data: XOR<PropertyCategoryUpdateInput, PropertyCategoryUncheckedUpdateInput>
    /**
     * Choose, which PropertyCategory to update.
     */
    where: PropertyCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory updateMany
   */
  export type PropertyCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyCategories.
     */
    data: XOR<PropertyCategoryUpdateManyMutationInput, PropertyCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategories to update
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to update.
     */
    limit?: number
  }

  /**
   * PropertyCategory updateManyAndReturn
   */
  export type PropertyCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * The data used to update PropertyCategories.
     */
    data: XOR<PropertyCategoryUpdateManyMutationInput, PropertyCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategories to update
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to update.
     */
    limit?: number
  }

  /**
   * PropertyCategory upsert
   */
  export type PropertyCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyCategory to update in case it exists.
     */
    where: PropertyCategoryWhereUniqueInput
    /**
     * In case the PropertyCategory found by the `where` argument doesn't exist, create a new PropertyCategory with this data.
     */
    create: XOR<PropertyCategoryCreateInput, PropertyCategoryUncheckedCreateInput>
    /**
     * In case the PropertyCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyCategoryUpdateInput, PropertyCategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory delete
   */
  export type PropertyCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter which PropertyCategory to delete.
     */
    where: PropertyCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyCategory deleteMany
   */
  export type PropertyCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategories to delete
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to delete.
     */
    limit?: number
  }

  /**
   * PropertyCategory.properties
   */
  export type PropertyCategory$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyCategory.subcategories
   */
  export type PropertyCategory$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    where?: PropertySubcategoryWhereInput
    orderBy?: PropertySubcategoryOrderByWithRelationInput | PropertySubcategoryOrderByWithRelationInput[]
    cursor?: PropertySubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertySubcategoryScalarFieldEnum | PropertySubcategoryScalarFieldEnum[]
  }

  /**
   * PropertyCategory without action
   */
  export type PropertyCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertySubcategory
   */

  export type AggregatePropertySubcategory = {
    _count: PropertySubcategoryCountAggregateOutputType | null
    _min: PropertySubcategoryMinAggregateOutputType | null
    _max: PropertySubcategoryMaxAggregateOutputType | null
  }

  export type PropertySubcategoryMinAggregateOutputType = {
    id: string | null
    value: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubcategoryMaxAggregateOutputType = {
    id: string | null
    value: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubcategoryCountAggregateOutputType = {
    id: number
    value: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertySubcategoryMinAggregateInputType = {
    id?: true
    value?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubcategoryMaxAggregateInputType = {
    id?: true
    value?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubcategoryCountAggregateInputType = {
    id?: true
    value?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertySubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubcategory to aggregate.
     */
    where?: PropertySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubcategories to fetch.
     */
    orderBy?: PropertySubcategoryOrderByWithRelationInput | PropertySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySubcategories
    **/
    _count?: true | PropertySubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySubcategoryMaxAggregateInputType
  }

  export type GetPropertySubcategoryAggregateType<T extends PropertySubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySubcategory[P]>
      : GetScalarType<T[P], AggregatePropertySubcategory[P]>
  }




  export type PropertySubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySubcategoryWhereInput
    orderBy?: PropertySubcategoryOrderByWithAggregationInput | PropertySubcategoryOrderByWithAggregationInput[]
    by: PropertySubcategoryScalarFieldEnum[] | PropertySubcategoryScalarFieldEnum
    having?: PropertySubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySubcategoryCountAggregateInputType | true
    _min?: PropertySubcategoryMinAggregateInputType
    _max?: PropertySubcategoryMaxAggregateInputType
  }

  export type PropertySubcategoryGroupByOutputType = {
    id: string
    value: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: PropertySubcategoryCountAggregateOutputType | null
    _min: PropertySubcategoryMinAggregateOutputType | null
    _max: PropertySubcategoryMaxAggregateOutputType | null
  }

  type GetPropertySubcategoryGroupByPayload<T extends PropertySubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type PropertySubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
    properties?: boolean | PropertySubcategory$propertiesArgs<ExtArgs>
    _count?: boolean | PropertySubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubcategory"]>

  export type PropertySubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubcategory"]>

  export type PropertySubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubcategory"]>

  export type PropertySubcategorySelectScalar = {
    id?: boolean
    value?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertySubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["propertySubcategory"]>
  export type PropertySubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
    properties?: boolean | PropertySubcategory$propertiesArgs<ExtArgs>
    _count?: boolean | PropertySubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertySubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
  }
  export type PropertySubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | PropertyCategoryDefaultArgs<ExtArgs>
  }

  export type $PropertySubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySubcategory"
    objects: {
      category: Prisma.$PropertyCategoryPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertySubcategory"]>
    composites: {}
  }

  type PropertySubcategoryGetPayload<S extends boolean | null | undefined | PropertySubcategoryDefaultArgs> = $Result.GetResult<Prisma.$PropertySubcategoryPayload, S>

  type PropertySubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertySubcategoryCountAggregateInputType | true
    }

  export interface PropertySubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySubcategory'], meta: { name: 'PropertySubcategory' } }
    /**
     * Find zero or one PropertySubcategory that matches the filter.
     * @param {PropertySubcategoryFindUniqueArgs} args - Arguments to find a PropertySubcategory
     * @example
     * // Get one PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySubcategoryFindUniqueArgs>(args: SelectSubset<T, PropertySubcategoryFindUniqueArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySubcategoryFindUniqueOrThrowArgs} args - Arguments to find a PropertySubcategory
     * @example
     * // Get one PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryFindFirstArgs} args - Arguments to find a PropertySubcategory
     * @example
     * // Get one PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySubcategoryFindFirstArgs>(args?: SelectSubset<T, PropertySubcategoryFindFirstArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryFindFirstOrThrowArgs} args - Arguments to find a PropertySubcategory
     * @example
     * // Get one PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySubcategories
     * const propertySubcategories = await prisma.propertySubcategory.findMany()
     * 
     * // Get first 10 PropertySubcategories
     * const propertySubcategories = await prisma.propertySubcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySubcategoryWithIdOnly = await prisma.propertySubcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySubcategoryFindManyArgs>(args?: SelectSubset<T, PropertySubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySubcategory.
     * @param {PropertySubcategoryCreateArgs} args - Arguments to create a PropertySubcategory.
     * @example
     * // Create one PropertySubcategory
     * const PropertySubcategory = await prisma.propertySubcategory.create({
     *   data: {
     *     // ... data to create a PropertySubcategory
     *   }
     * })
     * 
     */
    create<T extends PropertySubcategoryCreateArgs>(args: SelectSubset<T, PropertySubcategoryCreateArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySubcategories.
     * @param {PropertySubcategoryCreateManyArgs} args - Arguments to create many PropertySubcategories.
     * @example
     * // Create many PropertySubcategories
     * const propertySubcategory = await prisma.propertySubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySubcategoryCreateManyArgs>(args?: SelectSubset<T, PropertySubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySubcategories and returns the data saved in the database.
     * @param {PropertySubcategoryCreateManyAndReturnArgs} args - Arguments to create many PropertySubcategories.
     * @example
     * // Create many PropertySubcategories
     * const propertySubcategory = await prisma.propertySubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySubcategories and only return the `id`
     * const propertySubcategoryWithIdOnly = await prisma.propertySubcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySubcategory.
     * @param {PropertySubcategoryDeleteArgs} args - Arguments to delete one PropertySubcategory.
     * @example
     * // Delete one PropertySubcategory
     * const PropertySubcategory = await prisma.propertySubcategory.delete({
     *   where: {
     *     // ... filter to delete one PropertySubcategory
     *   }
     * })
     * 
     */
    delete<T extends PropertySubcategoryDeleteArgs>(args: SelectSubset<T, PropertySubcategoryDeleteArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySubcategory.
     * @param {PropertySubcategoryUpdateArgs} args - Arguments to update one PropertySubcategory.
     * @example
     * // Update one PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySubcategoryUpdateArgs>(args: SelectSubset<T, PropertySubcategoryUpdateArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySubcategories.
     * @param {PropertySubcategoryDeleteManyArgs} args - Arguments to filter PropertySubcategories to delete.
     * @example
     * // Delete a few PropertySubcategories
     * const { count } = await prisma.propertySubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySubcategoryDeleteManyArgs>(args?: SelectSubset<T, PropertySubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySubcategories
     * const propertySubcategory = await prisma.propertySubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySubcategoryUpdateManyArgs>(args: SelectSubset<T, PropertySubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubcategories and returns the data updated in the database.
     * @param {PropertySubcategoryUpdateManyAndReturnArgs} args - Arguments to update many PropertySubcategories.
     * @example
     * // Update many PropertySubcategories
     * const propertySubcategory = await prisma.propertySubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySubcategories and only return the `id`
     * const propertySubcategoryWithIdOnly = await prisma.propertySubcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySubcategory.
     * @param {PropertySubcategoryUpsertArgs} args - Arguments to update or create a PropertySubcategory.
     * @example
     * // Update or create a PropertySubcategory
     * const propertySubcategory = await prisma.propertySubcategory.upsert({
     *   create: {
     *     // ... data to create a PropertySubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySubcategory we want to update
     *   }
     * })
     */
    upsert<T extends PropertySubcategoryUpsertArgs>(args: SelectSubset<T, PropertySubcategoryUpsertArgs<ExtArgs>>): Prisma__PropertySubcategoryClient<$Result.GetResult<Prisma.$PropertySubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryCountArgs} args - Arguments to filter PropertySubcategories to count.
     * @example
     * // Count the number of PropertySubcategories
     * const count = await prisma.propertySubcategory.count({
     *   where: {
     *     // ... the filter for the PropertySubcategories we want to count
     *   }
     * })
    **/
    count<T extends PropertySubcategoryCountArgs>(
      args?: Subset<T, PropertySubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySubcategoryAggregateArgs>(args: Subset<T, PropertySubcategoryAggregateArgs>): Prisma.PrismaPromise<GetPropertySubcategoryAggregateType<T>>

    /**
     * Group by PropertySubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: PropertySubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySubcategory model
   */
  readonly fields: PropertySubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends PropertyCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyCategoryDefaultArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends PropertySubcategory$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertySubcategory$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySubcategory model
   */
  interface PropertySubcategoryFieldRefs {
    readonly id: FieldRef<"PropertySubcategory", 'String'>
    readonly value: FieldRef<"PropertySubcategory", 'String'>
    readonly categoryId: FieldRef<"PropertySubcategory", 'String'>
    readonly createdAt: FieldRef<"PropertySubcategory", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertySubcategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertySubcategory findUnique
   */
  export type PropertySubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubcategory to fetch.
     */
    where: PropertySubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory findUniqueOrThrow
   */
  export type PropertySubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubcategory to fetch.
     */
    where: PropertySubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory findFirst
   */
  export type PropertySubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubcategory to fetch.
     */
    where?: PropertySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubcategories to fetch.
     */
    orderBy?: PropertySubcategoryOrderByWithRelationInput | PropertySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubcategories.
     */
    cursor?: PropertySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubcategories.
     */
    distinct?: PropertySubcategoryScalarFieldEnum | PropertySubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory findFirstOrThrow
   */
  export type PropertySubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubcategory to fetch.
     */
    where?: PropertySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubcategories to fetch.
     */
    orderBy?: PropertySubcategoryOrderByWithRelationInput | PropertySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubcategories.
     */
    cursor?: PropertySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubcategories.
     */
    distinct?: PropertySubcategoryScalarFieldEnum | PropertySubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory findMany
   */
  export type PropertySubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubcategories to fetch.
     */
    where?: PropertySubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubcategories to fetch.
     */
    orderBy?: PropertySubcategoryOrderByWithRelationInput | PropertySubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySubcategories.
     */
    cursor?: PropertySubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubcategories.
     */
    skip?: number
    distinct?: PropertySubcategoryScalarFieldEnum | PropertySubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory create
   */
  export type PropertySubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertySubcategory.
     */
    data: XOR<PropertySubcategoryCreateInput, PropertySubcategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory createMany
   */
  export type PropertySubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySubcategories.
     */
    data: PropertySubcategoryCreateManyInput | PropertySubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySubcategory createManyAndReturn
   */
  export type PropertySubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySubcategories.
     */
    data: PropertySubcategoryCreateManyInput | PropertySubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySubcategory update
   */
  export type PropertySubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertySubcategory.
     */
    data: XOR<PropertySubcategoryUpdateInput, PropertySubcategoryUncheckedUpdateInput>
    /**
     * Choose, which PropertySubcategory to update.
     */
    where: PropertySubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory updateMany
   */
  export type PropertySubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySubcategories.
     */
    data: XOR<PropertySubcategoryUpdateManyMutationInput, PropertySubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubcategories to update
     */
    where?: PropertySubcategoryWhereInput
    /**
     * Limit how many PropertySubcategories to update.
     */
    limit?: number
  }

  /**
   * PropertySubcategory updateManyAndReturn
   */
  export type PropertySubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update PropertySubcategories.
     */
    data: XOR<PropertySubcategoryUpdateManyMutationInput, PropertySubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubcategories to update
     */
    where?: PropertySubcategoryWhereInput
    /**
     * Limit how many PropertySubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySubcategory upsert
   */
  export type PropertySubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertySubcategory to update in case it exists.
     */
    where: PropertySubcategoryWhereUniqueInput
    /**
     * In case the PropertySubcategory found by the `where` argument doesn't exist, create a new PropertySubcategory with this data.
     */
    create: XOR<PropertySubcategoryCreateInput, PropertySubcategoryUncheckedCreateInput>
    /**
     * In case the PropertySubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySubcategoryUpdateInput, PropertySubcategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory delete
   */
  export type PropertySubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
    /**
     * Filter which PropertySubcategory to delete.
     */
    where: PropertySubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubcategory deleteMany
   */
  export type PropertySubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubcategories to delete
     */
    where?: PropertySubcategoryWhereInput
    /**
     * Limit how many PropertySubcategories to delete.
     */
    limit?: number
  }

  /**
   * PropertySubcategory.properties
   */
  export type PropertySubcategory$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertySubcategory without action
   */
  export type PropertySubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubcategory
     */
    select?: PropertySubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubcategory
     */
    omit?: PropertySubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertyLocation
   */

  export type AggregatePropertyLocation = {
    _count: PropertyLocationCountAggregateOutputType | null
    _min: PropertyLocationMinAggregateOutputType | null
    _max: PropertyLocationMaxAggregateOutputType | null
  }

  export type PropertyLocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
  }

  export type PropertyLocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
  }

  export type PropertyLocationCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    _all: number
  }


  export type PropertyLocationMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
  }

  export type PropertyLocationMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
  }

  export type PropertyLocationCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    _all?: true
  }

  export type PropertyLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyLocation to aggregate.
     */
    where?: PropertyLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLocations to fetch.
     */
    orderBy?: PropertyLocationOrderByWithRelationInput | PropertyLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyLocations
    **/
    _count?: true | PropertyLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyLocationMaxAggregateInputType
  }

  export type GetPropertyLocationAggregateType<T extends PropertyLocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyLocation[P]>
      : GetScalarType<T[P], AggregatePropertyLocation[P]>
  }




  export type PropertyLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyLocationWhereInput
    orderBy?: PropertyLocationOrderByWithAggregationInput | PropertyLocationOrderByWithAggregationInput[]
    by: PropertyLocationScalarFieldEnum[] | PropertyLocationScalarFieldEnum
    having?: PropertyLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyLocationCountAggregateInputType | true
    _min?: PropertyLocationMinAggregateInputType
    _max?: PropertyLocationMaxAggregateInputType
  }

  export type PropertyLocationGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    _count: PropertyLocationCountAggregateOutputType | null
    _min: PropertyLocationMinAggregateOutputType | null
    _max: PropertyLocationMaxAggregateOutputType | null
  }

  type GetPropertyLocationGroupByPayload<T extends PropertyLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyLocationGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyLocationGroupByOutputType[P]>
        }
      >
    >


  export type PropertyLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
    children?: boolean | PropertyLocation$childrenArgs<ExtArgs>
    properties?: boolean | PropertyLocation$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyLocation"]>

  export type PropertyLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
  }, ExtArgs["result"]["propertyLocation"]>

  export type PropertyLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
  }, ExtArgs["result"]["propertyLocation"]>

  export type PropertyLocationSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
  }

  export type PropertyLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId", ExtArgs["result"]["propertyLocation"]>
  export type PropertyLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
    children?: boolean | PropertyLocation$childrenArgs<ExtArgs>
    properties?: boolean | PropertyLocation$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
  }
  export type PropertyLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | PropertyLocation$parentArgs<ExtArgs>
  }

  export type $PropertyLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyLocation"
    objects: {
      parent: Prisma.$PropertyLocationPayload<ExtArgs> | null
      children: Prisma.$PropertyLocationPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string | null
    }, ExtArgs["result"]["propertyLocation"]>
    composites: {}
  }

  type PropertyLocationGetPayload<S extends boolean | null | undefined | PropertyLocationDefaultArgs> = $Result.GetResult<Prisma.$PropertyLocationPayload, S>

  type PropertyLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyLocationCountAggregateInputType | true
    }

  export interface PropertyLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyLocation'], meta: { name: 'PropertyLocation' } }
    /**
     * Find zero or one PropertyLocation that matches the filter.
     * @param {PropertyLocationFindUniqueArgs} args - Arguments to find a PropertyLocation
     * @example
     * // Get one PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyLocationFindUniqueArgs>(args: SelectSubset<T, PropertyLocationFindUniqueArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyLocationFindUniqueOrThrowArgs} args - Arguments to find a PropertyLocation
     * @example
     * // Get one PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationFindFirstArgs} args - Arguments to find a PropertyLocation
     * @example
     * // Get one PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyLocationFindFirstArgs>(args?: SelectSubset<T, PropertyLocationFindFirstArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationFindFirstOrThrowArgs} args - Arguments to find a PropertyLocation
     * @example
     * // Get one PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyLocations
     * const propertyLocations = await prisma.propertyLocation.findMany()
     * 
     * // Get first 10 PropertyLocations
     * const propertyLocations = await prisma.propertyLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyLocationWithIdOnly = await prisma.propertyLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyLocationFindManyArgs>(args?: SelectSubset<T, PropertyLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyLocation.
     * @param {PropertyLocationCreateArgs} args - Arguments to create a PropertyLocation.
     * @example
     * // Create one PropertyLocation
     * const PropertyLocation = await prisma.propertyLocation.create({
     *   data: {
     *     // ... data to create a PropertyLocation
     *   }
     * })
     * 
     */
    create<T extends PropertyLocationCreateArgs>(args: SelectSubset<T, PropertyLocationCreateArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyLocations.
     * @param {PropertyLocationCreateManyArgs} args - Arguments to create many PropertyLocations.
     * @example
     * // Create many PropertyLocations
     * const propertyLocation = await prisma.propertyLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyLocationCreateManyArgs>(args?: SelectSubset<T, PropertyLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyLocations and returns the data saved in the database.
     * @param {PropertyLocationCreateManyAndReturnArgs} args - Arguments to create many PropertyLocations.
     * @example
     * // Create many PropertyLocations
     * const propertyLocation = await prisma.propertyLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyLocations and only return the `id`
     * const propertyLocationWithIdOnly = await prisma.propertyLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyLocation.
     * @param {PropertyLocationDeleteArgs} args - Arguments to delete one PropertyLocation.
     * @example
     * // Delete one PropertyLocation
     * const PropertyLocation = await prisma.propertyLocation.delete({
     *   where: {
     *     // ... filter to delete one PropertyLocation
     *   }
     * })
     * 
     */
    delete<T extends PropertyLocationDeleteArgs>(args: SelectSubset<T, PropertyLocationDeleteArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyLocation.
     * @param {PropertyLocationUpdateArgs} args - Arguments to update one PropertyLocation.
     * @example
     * // Update one PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyLocationUpdateArgs>(args: SelectSubset<T, PropertyLocationUpdateArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyLocations.
     * @param {PropertyLocationDeleteManyArgs} args - Arguments to filter PropertyLocations to delete.
     * @example
     * // Delete a few PropertyLocations
     * const { count } = await prisma.propertyLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyLocationDeleteManyArgs>(args?: SelectSubset<T, PropertyLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyLocations
     * const propertyLocation = await prisma.propertyLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyLocationUpdateManyArgs>(args: SelectSubset<T, PropertyLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyLocations and returns the data updated in the database.
     * @param {PropertyLocationUpdateManyAndReturnArgs} args - Arguments to update many PropertyLocations.
     * @example
     * // Update many PropertyLocations
     * const propertyLocation = await prisma.propertyLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyLocations and only return the `id`
     * const propertyLocationWithIdOnly = await prisma.propertyLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyLocation.
     * @param {PropertyLocationUpsertArgs} args - Arguments to update or create a PropertyLocation.
     * @example
     * // Update or create a PropertyLocation
     * const propertyLocation = await prisma.propertyLocation.upsert({
     *   create: {
     *     // ... data to create a PropertyLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyLocation we want to update
     *   }
     * })
     */
    upsert<T extends PropertyLocationUpsertArgs>(args: SelectSubset<T, PropertyLocationUpsertArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationCountArgs} args - Arguments to filter PropertyLocations to count.
     * @example
     * // Count the number of PropertyLocations
     * const count = await prisma.propertyLocation.count({
     *   where: {
     *     // ... the filter for the PropertyLocations we want to count
     *   }
     * })
    **/
    count<T extends PropertyLocationCountArgs>(
      args?: Subset<T, PropertyLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyLocationAggregateArgs>(args: Subset<T, PropertyLocationAggregateArgs>): Prisma.PrismaPromise<GetPropertyLocationAggregateType<T>>

    /**
     * Group by PropertyLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyLocationGroupByArgs['orderBy'] }
        : { orderBy?: PropertyLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyLocation model
   */
  readonly fields: PropertyLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends PropertyLocation$parentArgs<ExtArgs> = {}>(args?: Subset<T, PropertyLocation$parentArgs<ExtArgs>>): Prisma__PropertyLocationClient<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends PropertyLocation$childrenArgs<ExtArgs> = {}>(args?: Subset<T, PropertyLocation$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends PropertyLocation$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyLocation$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyLocation model
   */
  interface PropertyLocationFieldRefs {
    readonly id: FieldRef<"PropertyLocation", 'String'>
    readonly name: FieldRef<"PropertyLocation", 'String'>
    readonly parentId: FieldRef<"PropertyLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyLocation findUnique
   */
  export type PropertyLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLocation to fetch.
     */
    where: PropertyLocationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation findUniqueOrThrow
   */
  export type PropertyLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLocation to fetch.
     */
    where: PropertyLocationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation findFirst
   */
  export type PropertyLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLocation to fetch.
     */
    where?: PropertyLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLocations to fetch.
     */
    orderBy?: PropertyLocationOrderByWithRelationInput | PropertyLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyLocations.
     */
    cursor?: PropertyLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyLocations.
     */
    distinct?: PropertyLocationScalarFieldEnum | PropertyLocationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation findFirstOrThrow
   */
  export type PropertyLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLocation to fetch.
     */
    where?: PropertyLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLocations to fetch.
     */
    orderBy?: PropertyLocationOrderByWithRelationInput | PropertyLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyLocations.
     */
    cursor?: PropertyLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyLocations.
     */
    distinct?: PropertyLocationScalarFieldEnum | PropertyLocationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation findMany
   */
  export type PropertyLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLocations to fetch.
     */
    where?: PropertyLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLocations to fetch.
     */
    orderBy?: PropertyLocationOrderByWithRelationInput | PropertyLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyLocations.
     */
    cursor?: PropertyLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLocations.
     */
    skip?: number
    distinct?: PropertyLocationScalarFieldEnum | PropertyLocationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation create
   */
  export type PropertyLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyLocation.
     */
    data: XOR<PropertyLocationCreateInput, PropertyLocationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation createMany
   */
  export type PropertyLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyLocations.
     */
    data: PropertyLocationCreateManyInput | PropertyLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyLocation createManyAndReturn
   */
  export type PropertyLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyLocations.
     */
    data: PropertyLocationCreateManyInput | PropertyLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyLocation update
   */
  export type PropertyLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyLocation.
     */
    data: XOR<PropertyLocationUpdateInput, PropertyLocationUncheckedUpdateInput>
    /**
     * Choose, which PropertyLocation to update.
     */
    where: PropertyLocationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation updateMany
   */
  export type PropertyLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyLocations.
     */
    data: XOR<PropertyLocationUpdateManyMutationInput, PropertyLocationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyLocations to update
     */
    where?: PropertyLocationWhereInput
    /**
     * Limit how many PropertyLocations to update.
     */
    limit?: number
  }

  /**
   * PropertyLocation updateManyAndReturn
   */
  export type PropertyLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * The data used to update PropertyLocations.
     */
    data: XOR<PropertyLocationUpdateManyMutationInput, PropertyLocationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyLocations to update
     */
    where?: PropertyLocationWhereInput
    /**
     * Limit how many PropertyLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyLocation upsert
   */
  export type PropertyLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyLocation to update in case it exists.
     */
    where: PropertyLocationWhereUniqueInput
    /**
     * In case the PropertyLocation found by the `where` argument doesn't exist, create a new PropertyLocation with this data.
     */
    create: XOR<PropertyLocationCreateInput, PropertyLocationUncheckedCreateInput>
    /**
     * In case the PropertyLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyLocationUpdateInput, PropertyLocationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation delete
   */
  export type PropertyLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    /**
     * Filter which PropertyLocation to delete.
     */
    where: PropertyLocationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyLocation deleteMany
   */
  export type PropertyLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyLocations to delete
     */
    where?: PropertyLocationWhereInput
    /**
     * Limit how many PropertyLocations to delete.
     */
    limit?: number
  }

  /**
   * PropertyLocation.parent
   */
  export type PropertyLocation$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    where?: PropertyLocationWhereInput
  }

  /**
   * PropertyLocation.children
   */
  export type PropertyLocation$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
    where?: PropertyLocationWhereInput
    orderBy?: PropertyLocationOrderByWithRelationInput | PropertyLocationOrderByWithRelationInput[]
    cursor?: PropertyLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyLocationScalarFieldEnum | PropertyLocationScalarFieldEnum[]
  }

  /**
   * PropertyLocation.properties
   */
  export type PropertyLocation$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyLocation without action
   */
  export type PropertyLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLocation
     */
    select?: PropertyLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyLocation
     */
    omit?: PropertyLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyLocationInclude<ExtArgs> | null
  }


  /**
   * Model PropertySubmissionReview
   */

  export type AggregatePropertySubmissionReview = {
    _count: PropertySubmissionReviewCountAggregateOutputType | null
    _min: PropertySubmissionReviewMinAggregateOutputType | null
    _max: PropertySubmissionReviewMaxAggregateOutputType | null
  }

  export type PropertySubmissionReviewMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubmissionReviewMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubmissionReviewCountAggregateOutputType = {
    id: number
    propertyId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertySubmissionReviewMinAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubmissionReviewMaxAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubmissionReviewCountAggregateInputType = {
    id?: true
    propertyId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertySubmissionReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubmissionReview to aggregate.
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissionReviews to fetch.
     */
    orderBy?: PropertySubmissionReviewOrderByWithRelationInput | PropertySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySubmissionReviews
    **/
    _count?: true | PropertySubmissionReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySubmissionReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySubmissionReviewMaxAggregateInputType
  }

  export type GetPropertySubmissionReviewAggregateType<T extends PropertySubmissionReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySubmissionReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySubmissionReview[P]>
      : GetScalarType<T[P], AggregatePropertySubmissionReview[P]>
  }




  export type PropertySubmissionReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySubmissionReviewWhereInput
    orderBy?: PropertySubmissionReviewOrderByWithAggregationInput | PropertySubmissionReviewOrderByWithAggregationInput[]
    by: PropertySubmissionReviewScalarFieldEnum[] | PropertySubmissionReviewScalarFieldEnum
    having?: PropertySubmissionReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySubmissionReviewCountAggregateInputType | true
    _min?: PropertySubmissionReviewMinAggregateInputType
    _max?: PropertySubmissionReviewMaxAggregateInputType
  }

  export type PropertySubmissionReviewGroupByOutputType = {
    id: string
    propertyId: string
    title: JsonValue
    description: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PropertySubmissionReviewCountAggregateOutputType | null
    _min: PropertySubmissionReviewMinAggregateOutputType | null
    _max: PropertySubmissionReviewMaxAggregateOutputType | null
  }

  type GetPropertySubmissionReviewGroupByPayload<T extends PropertySubmissionReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySubmissionReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySubmissionReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySubmissionReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySubmissionReviewGroupByOutputType[P]>
        }
      >
    >


  export type PropertySubmissionReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubmissionReview"]>

  export type PropertySubmissionReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubmissionReview"]>

  export type PropertySubmissionReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySubmissionReview"]>

  export type PropertySubmissionReviewSelectScalar = {
    id?: boolean
    propertyId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertySubmissionReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["propertySubmissionReview"]>
  export type PropertySubmissionReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertySubmissionReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertySubmissionReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertySubmissionReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySubmissionReview"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      title: Prisma.JsonValue
      description: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertySubmissionReview"]>
    composites: {}
  }

  type PropertySubmissionReviewGetPayload<S extends boolean | null | undefined | PropertySubmissionReviewDefaultArgs> = $Result.GetResult<Prisma.$PropertySubmissionReviewPayload, S>

  type PropertySubmissionReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySubmissionReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertySubmissionReviewCountAggregateInputType | true
    }

  export interface PropertySubmissionReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySubmissionReview'], meta: { name: 'PropertySubmissionReview' } }
    /**
     * Find zero or one PropertySubmissionReview that matches the filter.
     * @param {PropertySubmissionReviewFindUniqueArgs} args - Arguments to find a PropertySubmissionReview
     * @example
     * // Get one PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySubmissionReviewFindUniqueArgs>(args: SelectSubset<T, PropertySubmissionReviewFindUniqueArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySubmissionReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySubmissionReviewFindUniqueOrThrowArgs} args - Arguments to find a PropertySubmissionReview
     * @example
     * // Get one PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySubmissionReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySubmissionReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubmissionReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewFindFirstArgs} args - Arguments to find a PropertySubmissionReview
     * @example
     * // Get one PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySubmissionReviewFindFirstArgs>(args?: SelectSubset<T, PropertySubmissionReviewFindFirstArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubmissionReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewFindFirstOrThrowArgs} args - Arguments to find a PropertySubmissionReview
     * @example
     * // Get one PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySubmissionReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySubmissionReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySubmissionReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySubmissionReviews
     * const propertySubmissionReviews = await prisma.propertySubmissionReview.findMany()
     * 
     * // Get first 10 PropertySubmissionReviews
     * const propertySubmissionReviews = await prisma.propertySubmissionReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySubmissionReviewWithIdOnly = await prisma.propertySubmissionReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySubmissionReviewFindManyArgs>(args?: SelectSubset<T, PropertySubmissionReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySubmissionReview.
     * @param {PropertySubmissionReviewCreateArgs} args - Arguments to create a PropertySubmissionReview.
     * @example
     * // Create one PropertySubmissionReview
     * const PropertySubmissionReview = await prisma.propertySubmissionReview.create({
     *   data: {
     *     // ... data to create a PropertySubmissionReview
     *   }
     * })
     * 
     */
    create<T extends PropertySubmissionReviewCreateArgs>(args: SelectSubset<T, PropertySubmissionReviewCreateArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySubmissionReviews.
     * @param {PropertySubmissionReviewCreateManyArgs} args - Arguments to create many PropertySubmissionReviews.
     * @example
     * // Create many PropertySubmissionReviews
     * const propertySubmissionReview = await prisma.propertySubmissionReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySubmissionReviewCreateManyArgs>(args?: SelectSubset<T, PropertySubmissionReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySubmissionReviews and returns the data saved in the database.
     * @param {PropertySubmissionReviewCreateManyAndReturnArgs} args - Arguments to create many PropertySubmissionReviews.
     * @example
     * // Create many PropertySubmissionReviews
     * const propertySubmissionReview = await prisma.propertySubmissionReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySubmissionReviews and only return the `id`
     * const propertySubmissionReviewWithIdOnly = await prisma.propertySubmissionReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySubmissionReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySubmissionReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySubmissionReview.
     * @param {PropertySubmissionReviewDeleteArgs} args - Arguments to delete one PropertySubmissionReview.
     * @example
     * // Delete one PropertySubmissionReview
     * const PropertySubmissionReview = await prisma.propertySubmissionReview.delete({
     *   where: {
     *     // ... filter to delete one PropertySubmissionReview
     *   }
     * })
     * 
     */
    delete<T extends PropertySubmissionReviewDeleteArgs>(args: SelectSubset<T, PropertySubmissionReviewDeleteArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySubmissionReview.
     * @param {PropertySubmissionReviewUpdateArgs} args - Arguments to update one PropertySubmissionReview.
     * @example
     * // Update one PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySubmissionReviewUpdateArgs>(args: SelectSubset<T, PropertySubmissionReviewUpdateArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySubmissionReviews.
     * @param {PropertySubmissionReviewDeleteManyArgs} args - Arguments to filter PropertySubmissionReviews to delete.
     * @example
     * // Delete a few PropertySubmissionReviews
     * const { count } = await prisma.propertySubmissionReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySubmissionReviewDeleteManyArgs>(args?: SelectSubset<T, PropertySubmissionReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubmissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySubmissionReviews
     * const propertySubmissionReview = await prisma.propertySubmissionReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySubmissionReviewUpdateManyArgs>(args: SelectSubset<T, PropertySubmissionReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubmissionReviews and returns the data updated in the database.
     * @param {PropertySubmissionReviewUpdateManyAndReturnArgs} args - Arguments to update many PropertySubmissionReviews.
     * @example
     * // Update many PropertySubmissionReviews
     * const propertySubmissionReview = await prisma.propertySubmissionReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySubmissionReviews and only return the `id`
     * const propertySubmissionReviewWithIdOnly = await prisma.propertySubmissionReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySubmissionReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySubmissionReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySubmissionReview.
     * @param {PropertySubmissionReviewUpsertArgs} args - Arguments to update or create a PropertySubmissionReview.
     * @example
     * // Update or create a PropertySubmissionReview
     * const propertySubmissionReview = await prisma.propertySubmissionReview.upsert({
     *   create: {
     *     // ... data to create a PropertySubmissionReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySubmissionReview we want to update
     *   }
     * })
     */
    upsert<T extends PropertySubmissionReviewUpsertArgs>(args: SelectSubset<T, PropertySubmissionReviewUpsertArgs<ExtArgs>>): Prisma__PropertySubmissionReviewClient<$Result.GetResult<Prisma.$PropertySubmissionReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySubmissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewCountArgs} args - Arguments to filter PropertySubmissionReviews to count.
     * @example
     * // Count the number of PropertySubmissionReviews
     * const count = await prisma.propertySubmissionReview.count({
     *   where: {
     *     // ... the filter for the PropertySubmissionReviews we want to count
     *   }
     * })
    **/
    count<T extends PropertySubmissionReviewCountArgs>(
      args?: Subset<T, PropertySubmissionReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySubmissionReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySubmissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySubmissionReviewAggregateArgs>(args: Subset<T, PropertySubmissionReviewAggregateArgs>): Prisma.PrismaPromise<GetPropertySubmissionReviewAggregateType<T>>

    /**
     * Group by PropertySubmissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySubmissionReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySubmissionReviewGroupByArgs['orderBy'] }
        : { orderBy?: PropertySubmissionReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySubmissionReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySubmissionReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySubmissionReview model
   */
  readonly fields: PropertySubmissionReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySubmissionReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySubmissionReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySubmissionReview model
   */
  interface PropertySubmissionReviewFieldRefs {
    readonly id: FieldRef<"PropertySubmissionReview", 'String'>
    readonly propertyId: FieldRef<"PropertySubmissionReview", 'String'>
    readonly title: FieldRef<"PropertySubmissionReview", 'Json'>
    readonly description: FieldRef<"PropertySubmissionReview", 'Json'>
    readonly createdAt: FieldRef<"PropertySubmissionReview", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertySubmissionReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertySubmissionReview findUnique
   */
  export type PropertySubmissionReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubmissionReview to fetch.
     */
    where: PropertySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview findUniqueOrThrow
   */
  export type PropertySubmissionReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubmissionReview to fetch.
     */
    where: PropertySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview findFirst
   */
  export type PropertySubmissionReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubmissionReview to fetch.
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissionReviews to fetch.
     */
    orderBy?: PropertySubmissionReviewOrderByWithRelationInput | PropertySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubmissionReviews.
     */
    cursor?: PropertySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubmissionReviews.
     */
    distinct?: PropertySubmissionReviewScalarFieldEnum | PropertySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview findFirstOrThrow
   */
  export type PropertySubmissionReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubmissionReview to fetch.
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissionReviews to fetch.
     */
    orderBy?: PropertySubmissionReviewOrderByWithRelationInput | PropertySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubmissionReviews.
     */
    cursor?: PropertySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubmissionReviews.
     */
    distinct?: PropertySubmissionReviewScalarFieldEnum | PropertySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview findMany
   */
  export type PropertySubmissionReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertySubmissionReviews to fetch.
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissionReviews to fetch.
     */
    orderBy?: PropertySubmissionReviewOrderByWithRelationInput | PropertySubmissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySubmissionReviews.
     */
    cursor?: PropertySubmissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissionReviews.
     */
    skip?: number
    distinct?: PropertySubmissionReviewScalarFieldEnum | PropertySubmissionReviewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview create
   */
  export type PropertySubmissionReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertySubmissionReview.
     */
    data: XOR<PropertySubmissionReviewCreateInput, PropertySubmissionReviewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview createMany
   */
  export type PropertySubmissionReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySubmissionReviews.
     */
    data: PropertySubmissionReviewCreateManyInput | PropertySubmissionReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySubmissionReview createManyAndReturn
   */
  export type PropertySubmissionReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySubmissionReviews.
     */
    data: PropertySubmissionReviewCreateManyInput | PropertySubmissionReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySubmissionReview update
   */
  export type PropertySubmissionReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertySubmissionReview.
     */
    data: XOR<PropertySubmissionReviewUpdateInput, PropertySubmissionReviewUncheckedUpdateInput>
    /**
     * Choose, which PropertySubmissionReview to update.
     */
    where: PropertySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview updateMany
   */
  export type PropertySubmissionReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySubmissionReviews.
     */
    data: XOR<PropertySubmissionReviewUpdateManyMutationInput, PropertySubmissionReviewUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubmissionReviews to update
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * Limit how many PropertySubmissionReviews to update.
     */
    limit?: number
  }

  /**
   * PropertySubmissionReview updateManyAndReturn
   */
  export type PropertySubmissionReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * The data used to update PropertySubmissionReviews.
     */
    data: XOR<PropertySubmissionReviewUpdateManyMutationInput, PropertySubmissionReviewUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubmissionReviews to update
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * Limit how many PropertySubmissionReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySubmissionReview upsert
   */
  export type PropertySubmissionReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertySubmissionReview to update in case it exists.
     */
    where: PropertySubmissionReviewWhereUniqueInput
    /**
     * In case the PropertySubmissionReview found by the `where` argument doesn't exist, create a new PropertySubmissionReview with this data.
     */
    create: XOR<PropertySubmissionReviewCreateInput, PropertySubmissionReviewUncheckedCreateInput>
    /**
     * In case the PropertySubmissionReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySubmissionReviewUpdateInput, PropertySubmissionReviewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview delete
   */
  export type PropertySubmissionReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
    /**
     * Filter which PropertySubmissionReview to delete.
     */
    where: PropertySubmissionReviewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySubmissionReview deleteMany
   */
  export type PropertySubmissionReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubmissionReviews to delete
     */
    where?: PropertySubmissionReviewWhereInput
    /**
     * Limit how many PropertySubmissionReviews to delete.
     */
    limit?: number
  }

  /**
   * PropertySubmissionReview without action
   */
  export type PropertySubmissionReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmissionReview
     */
    select?: PropertySubmissionReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmissionReview
     */
    omit?: PropertySubmissionReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySubmissionReviewInclude<ExtArgs> | null
  }


  /**
   * Model PropertySale
   */

  export type AggregatePropertySale = {
    _count: PropertySaleCountAggregateOutputType | null
    _avg: PropertySaleAvgAggregateOutputType | null
    _sum: PropertySaleSumAggregateOutputType | null
    _min: PropertySaleMinAggregateOutputType | null
    _max: PropertySaleMaxAggregateOutputType | null
  }

  export type PropertySaleAvgAggregateOutputType = {
    soldFor: number | null
  }

  export type PropertySaleSumAggregateOutputType = {
    soldFor: number | null
  }

  export type PropertySaleMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    agencyId: string | null
    propertyDeed: string | null
    soldAt: Date | null
    soldFor: number | null
    visibility: boolean | null
  }

  export type PropertySaleMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    agencyId: string | null
    propertyDeed: string | null
    soldAt: Date | null
    soldFor: number | null
    visibility: boolean | null
  }

  export type PropertySaleCountAggregateOutputType = {
    id: number
    propertyId: number
    agencyId: number
    propertyDeed: number
    soldAt: number
    soldFor: number
    visibility: number
    _all: number
  }


  export type PropertySaleAvgAggregateInputType = {
    soldFor?: true
  }

  export type PropertySaleSumAggregateInputType = {
    soldFor?: true
  }

  export type PropertySaleMinAggregateInputType = {
    id?: true
    propertyId?: true
    agencyId?: true
    propertyDeed?: true
    soldAt?: true
    soldFor?: true
    visibility?: true
  }

  export type PropertySaleMaxAggregateInputType = {
    id?: true
    propertyId?: true
    agencyId?: true
    propertyDeed?: true
    soldAt?: true
    soldFor?: true
    visibility?: true
  }

  export type PropertySaleCountAggregateInputType = {
    id?: true
    propertyId?: true
    agencyId?: true
    propertyDeed?: true
    soldAt?: true
    soldFor?: true
    visibility?: true
    _all?: true
  }

  export type PropertySaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySale to aggregate.
     */
    where?: PropertySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySales to fetch.
     */
    orderBy?: PropertySaleOrderByWithRelationInput | PropertySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySales
    **/
    _count?: true | PropertySaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertySaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySaleMaxAggregateInputType
  }

  export type GetPropertySaleAggregateType<T extends PropertySaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySale[P]>
      : GetScalarType<T[P], AggregatePropertySale[P]>
  }




  export type PropertySaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySaleWhereInput
    orderBy?: PropertySaleOrderByWithAggregationInput | PropertySaleOrderByWithAggregationInput[]
    by: PropertySaleScalarFieldEnum[] | PropertySaleScalarFieldEnum
    having?: PropertySaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySaleCountAggregateInputType | true
    _avg?: PropertySaleAvgAggregateInputType
    _sum?: PropertySaleSumAggregateInputType
    _min?: PropertySaleMinAggregateInputType
    _max?: PropertySaleMaxAggregateInputType
  }

  export type PropertySaleGroupByOutputType = {
    id: string
    propertyId: string
    agencyId: string
    propertyDeed: string
    soldAt: Date
    soldFor: number
    visibility: boolean
    _count: PropertySaleCountAggregateOutputType | null
    _avg: PropertySaleAvgAggregateOutputType | null
    _sum: PropertySaleSumAggregateOutputType | null
    _min: PropertySaleMinAggregateOutputType | null
    _max: PropertySaleMaxAggregateOutputType | null
  }

  type GetPropertySaleGroupByPayload<T extends PropertySaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySaleGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySaleGroupByOutputType[P]>
        }
      >
    >


  export type PropertySaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agencyId?: boolean
    propertyDeed?: boolean
    soldAt?: boolean
    soldFor?: boolean
    visibility?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySale"]>

  export type PropertySaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agencyId?: boolean
    propertyDeed?: boolean
    soldAt?: boolean
    soldFor?: boolean
    visibility?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySale"]>

  export type PropertySaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agencyId?: boolean
    propertyDeed?: boolean
    soldAt?: boolean
    soldFor?: boolean
    visibility?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySale"]>

  export type PropertySaleSelectScalar = {
    id?: boolean
    propertyId?: boolean
    agencyId?: boolean
    propertyDeed?: boolean
    soldAt?: boolean
    soldFor?: boolean
    visibility?: boolean
  }

  export type PropertySaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "agencyId" | "propertyDeed" | "soldAt" | "soldFor" | "visibility", ExtArgs["result"]["propertySale"]>
  export type PropertySaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type PropertySaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type PropertySaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $PropertySalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySale"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      agencyId: string
      propertyDeed: string
      soldAt: Date
      soldFor: number
      visibility: boolean
    }, ExtArgs["result"]["propertySale"]>
    composites: {}
  }

  type PropertySaleGetPayload<S extends boolean | null | undefined | PropertySaleDefaultArgs> = $Result.GetResult<Prisma.$PropertySalePayload, S>

  type PropertySaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertySaleCountAggregateInputType | true
    }

  export interface PropertySaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySale'], meta: { name: 'PropertySale' } }
    /**
     * Find zero or one PropertySale that matches the filter.
     * @param {PropertySaleFindUniqueArgs} args - Arguments to find a PropertySale
     * @example
     * // Get one PropertySale
     * const propertySale = await prisma.propertySale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySaleFindUniqueArgs>(args: SelectSubset<T, PropertySaleFindUniqueArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySaleFindUniqueOrThrowArgs} args - Arguments to find a PropertySale
     * @example
     * // Get one PropertySale
     * const propertySale = await prisma.propertySale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleFindFirstArgs} args - Arguments to find a PropertySale
     * @example
     * // Get one PropertySale
     * const propertySale = await prisma.propertySale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySaleFindFirstArgs>(args?: SelectSubset<T, PropertySaleFindFirstArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleFindFirstOrThrowArgs} args - Arguments to find a PropertySale
     * @example
     * // Get one PropertySale
     * const propertySale = await prisma.propertySale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySales
     * const propertySales = await prisma.propertySale.findMany()
     * 
     * // Get first 10 PropertySales
     * const propertySales = await prisma.propertySale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySaleWithIdOnly = await prisma.propertySale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySaleFindManyArgs>(args?: SelectSubset<T, PropertySaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySale.
     * @param {PropertySaleCreateArgs} args - Arguments to create a PropertySale.
     * @example
     * // Create one PropertySale
     * const PropertySale = await prisma.propertySale.create({
     *   data: {
     *     // ... data to create a PropertySale
     *   }
     * })
     * 
     */
    create<T extends PropertySaleCreateArgs>(args: SelectSubset<T, PropertySaleCreateArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySales.
     * @param {PropertySaleCreateManyArgs} args - Arguments to create many PropertySales.
     * @example
     * // Create many PropertySales
     * const propertySale = await prisma.propertySale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySaleCreateManyArgs>(args?: SelectSubset<T, PropertySaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySales and returns the data saved in the database.
     * @param {PropertySaleCreateManyAndReturnArgs} args - Arguments to create many PropertySales.
     * @example
     * // Create many PropertySales
     * const propertySale = await prisma.propertySale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySales and only return the `id`
     * const propertySaleWithIdOnly = await prisma.propertySale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySale.
     * @param {PropertySaleDeleteArgs} args - Arguments to delete one PropertySale.
     * @example
     * // Delete one PropertySale
     * const PropertySale = await prisma.propertySale.delete({
     *   where: {
     *     // ... filter to delete one PropertySale
     *   }
     * })
     * 
     */
    delete<T extends PropertySaleDeleteArgs>(args: SelectSubset<T, PropertySaleDeleteArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySale.
     * @param {PropertySaleUpdateArgs} args - Arguments to update one PropertySale.
     * @example
     * // Update one PropertySale
     * const propertySale = await prisma.propertySale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySaleUpdateArgs>(args: SelectSubset<T, PropertySaleUpdateArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySales.
     * @param {PropertySaleDeleteManyArgs} args - Arguments to filter PropertySales to delete.
     * @example
     * // Delete a few PropertySales
     * const { count } = await prisma.propertySale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySaleDeleteManyArgs>(args?: SelectSubset<T, PropertySaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySales
     * const propertySale = await prisma.propertySale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySaleUpdateManyArgs>(args: SelectSubset<T, PropertySaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySales and returns the data updated in the database.
     * @param {PropertySaleUpdateManyAndReturnArgs} args - Arguments to update many PropertySales.
     * @example
     * // Update many PropertySales
     * const propertySale = await prisma.propertySale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySales and only return the `id`
     * const propertySaleWithIdOnly = await prisma.propertySale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySale.
     * @param {PropertySaleUpsertArgs} args - Arguments to update or create a PropertySale.
     * @example
     * // Update or create a PropertySale
     * const propertySale = await prisma.propertySale.upsert({
     *   create: {
     *     // ... data to create a PropertySale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySale we want to update
     *   }
     * })
     */
    upsert<T extends PropertySaleUpsertArgs>(args: SelectSubset<T, PropertySaleUpsertArgs<ExtArgs>>): Prisma__PropertySaleClient<$Result.GetResult<Prisma.$PropertySalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleCountArgs} args - Arguments to filter PropertySales to count.
     * @example
     * // Count the number of PropertySales
     * const count = await prisma.propertySale.count({
     *   where: {
     *     // ... the filter for the PropertySales we want to count
     *   }
     * })
    **/
    count<T extends PropertySaleCountArgs>(
      args?: Subset<T, PropertySaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySaleAggregateArgs>(args: Subset<T, PropertySaleAggregateArgs>): Prisma.PrismaPromise<GetPropertySaleAggregateType<T>>

    /**
     * Group by PropertySale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySaleGroupByArgs['orderBy'] }
        : { orderBy?: PropertySaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySale model
   */
  readonly fields: PropertySaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySale model
   */
  interface PropertySaleFieldRefs {
    readonly id: FieldRef<"PropertySale", 'String'>
    readonly propertyId: FieldRef<"PropertySale", 'String'>
    readonly agencyId: FieldRef<"PropertySale", 'String'>
    readonly propertyDeed: FieldRef<"PropertySale", 'String'>
    readonly soldAt: FieldRef<"PropertySale", 'DateTime'>
    readonly soldFor: FieldRef<"PropertySale", 'Int'>
    readonly visibility: FieldRef<"PropertySale", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PropertySale findUnique
   */
  export type PropertySaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter, which PropertySale to fetch.
     */
    where: PropertySaleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale findUniqueOrThrow
   */
  export type PropertySaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter, which PropertySale to fetch.
     */
    where: PropertySaleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale findFirst
   */
  export type PropertySaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter, which PropertySale to fetch.
     */
    where?: PropertySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySales to fetch.
     */
    orderBy?: PropertySaleOrderByWithRelationInput | PropertySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySales.
     */
    cursor?: PropertySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySales.
     */
    distinct?: PropertySaleScalarFieldEnum | PropertySaleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale findFirstOrThrow
   */
  export type PropertySaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter, which PropertySale to fetch.
     */
    where?: PropertySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySales to fetch.
     */
    orderBy?: PropertySaleOrderByWithRelationInput | PropertySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySales.
     */
    cursor?: PropertySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySales.
     */
    distinct?: PropertySaleScalarFieldEnum | PropertySaleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale findMany
   */
  export type PropertySaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter, which PropertySales to fetch.
     */
    where?: PropertySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySales to fetch.
     */
    orderBy?: PropertySaleOrderByWithRelationInput | PropertySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySales.
     */
    cursor?: PropertySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySales.
     */
    skip?: number
    distinct?: PropertySaleScalarFieldEnum | PropertySaleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale create
   */
  export type PropertySaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertySale.
     */
    data: XOR<PropertySaleCreateInput, PropertySaleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale createMany
   */
  export type PropertySaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySales.
     */
    data: PropertySaleCreateManyInput | PropertySaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySale createManyAndReturn
   */
  export type PropertySaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySales.
     */
    data: PropertySaleCreateManyInput | PropertySaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySale update
   */
  export type PropertySaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertySale.
     */
    data: XOR<PropertySaleUpdateInput, PropertySaleUncheckedUpdateInput>
    /**
     * Choose, which PropertySale to update.
     */
    where: PropertySaleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale updateMany
   */
  export type PropertySaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySales.
     */
    data: XOR<PropertySaleUpdateManyMutationInput, PropertySaleUncheckedUpdateManyInput>
    /**
     * Filter which PropertySales to update
     */
    where?: PropertySaleWhereInput
    /**
     * Limit how many PropertySales to update.
     */
    limit?: number
  }

  /**
   * PropertySale updateManyAndReturn
   */
  export type PropertySaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * The data used to update PropertySales.
     */
    data: XOR<PropertySaleUpdateManyMutationInput, PropertySaleUncheckedUpdateManyInput>
    /**
     * Filter which PropertySales to update
     */
    where?: PropertySaleWhereInput
    /**
     * Limit how many PropertySales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySale upsert
   */
  export type PropertySaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertySale to update in case it exists.
     */
    where: PropertySaleWhereUniqueInput
    /**
     * In case the PropertySale found by the `where` argument doesn't exist, create a new PropertySale with this data.
     */
    create: XOR<PropertySaleCreateInput, PropertySaleUncheckedCreateInput>
    /**
     * In case the PropertySale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySaleUpdateInput, PropertySaleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale delete
   */
  export type PropertySaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
    /**
     * Filter which PropertySale to delete.
     */
    where: PropertySaleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertySale deleteMany
   */
  export type PropertySaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySales to delete
     */
    where?: PropertySaleWhereInput
    /**
     * Limit how many PropertySales to delete.
     */
    limit?: number
  }

  /**
   * PropertySale without action
   */
  export type PropertySaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySale
     */
    select?: PropertySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySale
     */
    omit?: PropertySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySaleInclude<ExtArgs> | null
  }


  /**
   * Model PropertyView
   */

  export type AggregatePropertyView = {
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  export type PropertyViewMinAggregateOutputType = {
    id: string | null
    viewDate: Date | null
    propertyId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyViewMaxAggregateOutputType = {
    id: string | null
    viewDate: Date | null
    propertyId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyViewCountAggregateOutputType = {
    id: number
    viewDate: number
    propertyId: number
    clientId: number
    additionalInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyViewMinAggregateInputType = {
    id?: true
    viewDate?: true
    propertyId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyViewMaxAggregateInputType = {
    id?: true
    viewDate?: true
    propertyId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyViewCountAggregateInputType = {
    id?: true
    viewDate?: true
    propertyId?: true
    clientId?: true
    additionalInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyView to aggregate.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyViews
    **/
    _count?: true | PropertyViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyViewMaxAggregateInputType
  }

  export type GetPropertyViewAggregateType<T extends PropertyViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyView[P]>
      : GetScalarType<T[P], AggregatePropertyView[P]>
  }




  export type PropertyViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithAggregationInput | PropertyViewOrderByWithAggregationInput[]
    by: PropertyViewScalarFieldEnum[] | PropertyViewScalarFieldEnum
    having?: PropertyViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyViewCountAggregateInputType | true
    _min?: PropertyViewMinAggregateInputType
    _max?: PropertyViewMaxAggregateInputType
  }

  export type PropertyViewGroupByOutputType = {
    id: string
    viewDate: Date
    propertyId: string
    clientId: string | null
    additionalInfo: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  type GetPropertyViewGroupByPayload<T extends PropertyViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
        }
      >
    >


  export type PropertyViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viewDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viewDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viewDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectScalar = {
    id?: boolean
    viewDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "viewDate" | "propertyId" | "clientId" | "additionalInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyView"]>
  export type PropertyViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }
  export type PropertyViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }
  export type PropertyViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyView$clientArgs<ExtArgs>
  }

  export type $PropertyViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyView"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      viewDate: Date
      propertyId: string
      clientId: string | null
      additionalInfo: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyView"]>
    composites: {}
  }

  type PropertyViewGetPayload<S extends boolean | null | undefined | PropertyViewDefaultArgs> = $Result.GetResult<Prisma.$PropertyViewPayload, S>

  type PropertyViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyViewCountAggregateInputType | true
    }

  export interface PropertyViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyView'], meta: { name: 'PropertyView' } }
    /**
     * Find zero or one PropertyView that matches the filter.
     * @param {PropertyViewFindUniqueArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyViewFindUniqueArgs>(args: SelectSubset<T, PropertyViewFindUniqueArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyViewFindUniqueOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyViewFindFirstArgs>(args?: SelectSubset<T, PropertyViewFindFirstArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyViews
     * const propertyViews = await prisma.propertyView.findMany()
     * 
     * // Get first 10 PropertyViews
     * const propertyViews = await prisma.propertyView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyViewFindManyArgs>(args?: SelectSubset<T, PropertyViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyView.
     * @param {PropertyViewCreateArgs} args - Arguments to create a PropertyView.
     * @example
     * // Create one PropertyView
     * const PropertyView = await prisma.propertyView.create({
     *   data: {
     *     // ... data to create a PropertyView
     *   }
     * })
     * 
     */
    create<T extends PropertyViewCreateArgs>(args: SelectSubset<T, PropertyViewCreateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyViews.
     * @param {PropertyViewCreateManyArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyViewCreateManyArgs>(args?: SelectSubset<T, PropertyViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyViews and returns the data saved in the database.
     * @param {PropertyViewCreateManyAndReturnArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyViewCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyView.
     * @param {PropertyViewDeleteArgs} args - Arguments to delete one PropertyView.
     * @example
     * // Delete one PropertyView
     * const PropertyView = await prisma.propertyView.delete({
     *   where: {
     *     // ... filter to delete one PropertyView
     *   }
     * })
     * 
     */
    delete<T extends PropertyViewDeleteArgs>(args: SelectSubset<T, PropertyViewDeleteArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyView.
     * @param {PropertyViewUpdateArgs} args - Arguments to update one PropertyView.
     * @example
     * // Update one PropertyView
     * const propertyView = await prisma.propertyView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyViewUpdateArgs>(args: SelectSubset<T, PropertyViewUpdateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyViews.
     * @param {PropertyViewDeleteManyArgs} args - Arguments to filter PropertyViews to delete.
     * @example
     * // Delete a few PropertyViews
     * const { count } = await prisma.propertyView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyViewDeleteManyArgs>(args?: SelectSubset<T, PropertyViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyViewUpdateManyArgs>(args: SelectSubset<T, PropertyViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews and returns the data updated in the database.
     * @param {PropertyViewUpdateManyAndReturnArgs} args - Arguments to update many PropertyViews.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyViewUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyView.
     * @param {PropertyViewUpsertArgs} args - Arguments to update or create a PropertyView.
     * @example
     * // Update or create a PropertyView
     * const propertyView = await prisma.propertyView.upsert({
     *   create: {
     *     // ... data to create a PropertyView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyView we want to update
     *   }
     * })
     */
    upsert<T extends PropertyViewUpsertArgs>(args: SelectSubset<T, PropertyViewUpsertArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewCountArgs} args - Arguments to filter PropertyViews to count.
     * @example
     * // Count the number of PropertyViews
     * const count = await prisma.propertyView.count({
     *   where: {
     *     // ... the filter for the PropertyViews we want to count
     *   }
     * })
    **/
    count<T extends PropertyViewCountArgs>(
      args?: Subset<T, PropertyViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyViewAggregateArgs>(args: Subset<T, PropertyViewAggregateArgs>): Prisma.PrismaPromise<GetPropertyViewAggregateType<T>>

    /**
     * Group by PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyViewGroupByArgs['orderBy'] }
        : { orderBy?: PropertyViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyView model
   */
  readonly fields: PropertyViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends PropertyView$clientArgs<ExtArgs> = {}>(args?: Subset<T, PropertyView$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyView model
   */
  interface PropertyViewFieldRefs {
    readonly id: FieldRef<"PropertyView", 'String'>
    readonly viewDate: FieldRef<"PropertyView", 'DateTime'>
    readonly propertyId: FieldRef<"PropertyView", 'String'>
    readonly clientId: FieldRef<"PropertyView", 'String'>
    readonly additionalInfo: FieldRef<"PropertyView", 'Json'>
    readonly createdAt: FieldRef<"PropertyView", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyView findUnique
   */
  export type PropertyViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView findUniqueOrThrow
   */
  export type PropertyViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView findFirst
   */
  export type PropertyViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView findFirstOrThrow
   */
  export type PropertyViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView findMany
   */
  export type PropertyViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViews to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView create
   */
  export type PropertyViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyView.
     */
    data: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView createMany
   */
  export type PropertyViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyView createManyAndReturn
   */
  export type PropertyViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView update
   */
  export type PropertyViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyView.
     */
    data: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
    /**
     * Choose, which PropertyView to update.
     */
    where: PropertyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView updateMany
   */
  export type PropertyViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
  }

  /**
   * PropertyView updateManyAndReturn
   */
  export type PropertyViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView upsert
   */
  export type PropertyViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyView to update in case it exists.
     */
    where: PropertyViewWhereUniqueInput
    /**
     * In case the PropertyView found by the `where` argument doesn't exist, create a new PropertyView with this data.
     */
    create: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
    /**
     * In case the PropertyView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView delete
   */
  export type PropertyViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter which PropertyView to delete.
     */
    where: PropertyViewWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyView deleteMany
   */
  export type PropertyViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViews to delete
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to delete.
     */
    limit?: number
  }

  /**
   * PropertyView.client
   */
  export type PropertyView$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * PropertyView without action
   */
  export type PropertyViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
  }


  /**
   * Model PropertyFavorite
   */

  export type AggregatePropertyFavorite = {
    _count: PropertyFavoriteCountAggregateOutputType | null
    _min: PropertyFavoriteMinAggregateOutputType | null
    _max: PropertyFavoriteMaxAggregateOutputType | null
  }

  export type PropertyFavoriteMinAggregateOutputType = {
    id: string | null
    favoriteDate: Date | null
    propertyId: string | null
    clientId: string | null
  }

  export type PropertyFavoriteMaxAggregateOutputType = {
    id: string | null
    favoriteDate: Date | null
    propertyId: string | null
    clientId: string | null
  }

  export type PropertyFavoriteCountAggregateOutputType = {
    id: number
    favoriteDate: number
    propertyId: number
    clientId: number
    _all: number
  }


  export type PropertyFavoriteMinAggregateInputType = {
    id?: true
    favoriteDate?: true
    propertyId?: true
    clientId?: true
  }

  export type PropertyFavoriteMaxAggregateInputType = {
    id?: true
    favoriteDate?: true
    propertyId?: true
    clientId?: true
  }

  export type PropertyFavoriteCountAggregateInputType = {
    id?: true
    favoriteDate?: true
    propertyId?: true
    clientId?: true
    _all?: true
  }

  export type PropertyFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFavorite to aggregate.
     */
    where?: PropertyFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFavorites to fetch.
     */
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyFavorites
    **/
    _count?: true | PropertyFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyFavoriteMaxAggregateInputType
  }

  export type GetPropertyFavoriteAggregateType<T extends PropertyFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyFavorite[P]>
      : GetScalarType<T[P], AggregatePropertyFavorite[P]>
  }




  export type PropertyFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFavoriteWhereInput
    orderBy?: PropertyFavoriteOrderByWithAggregationInput | PropertyFavoriteOrderByWithAggregationInput[]
    by: PropertyFavoriteScalarFieldEnum[] | PropertyFavoriteScalarFieldEnum
    having?: PropertyFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyFavoriteCountAggregateInputType | true
    _min?: PropertyFavoriteMinAggregateInputType
    _max?: PropertyFavoriteMaxAggregateInputType
  }

  export type PropertyFavoriteGroupByOutputType = {
    id: string
    favoriteDate: Date
    propertyId: string | null
    clientId: string | null
    _count: PropertyFavoriteCountAggregateOutputType | null
    _min: PropertyFavoriteMinAggregateOutputType | null
    _max: PropertyFavoriteMaxAggregateOutputType | null
  }

  type GetPropertyFavoriteGroupByPayload<T extends PropertyFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type PropertyFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    favoriteDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFavorite"]>

  export type PropertyFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    favoriteDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFavorite"]>

  export type PropertyFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    favoriteDate?: boolean
    propertyId?: boolean
    clientId?: boolean
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFavorite"]>

  export type PropertyFavoriteSelectScalar = {
    id?: boolean
    favoriteDate?: boolean
    propertyId?: boolean
    clientId?: boolean
  }

  export type PropertyFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "favoriteDate" | "propertyId" | "clientId", ExtArgs["result"]["propertyFavorite"]>
  export type PropertyFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }
  export type PropertyFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }
  export type PropertyFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyFavorite$propertyArgs<ExtArgs>
    client?: boolean | PropertyFavorite$clientArgs<ExtArgs>
  }

  export type $PropertyFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyFavorite"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      favoriteDate: Date
      propertyId: string | null
      clientId: string | null
    }, ExtArgs["result"]["propertyFavorite"]>
    composites: {}
  }

  type PropertyFavoriteGetPayload<S extends boolean | null | undefined | PropertyFavoriteDefaultArgs> = $Result.GetResult<Prisma.$PropertyFavoritePayload, S>

  type PropertyFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyFavoriteCountAggregateInputType | true
    }

  export interface PropertyFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyFavorite'], meta: { name: 'PropertyFavorite' } }
    /**
     * Find zero or one PropertyFavorite that matches the filter.
     * @param {PropertyFavoriteFindUniqueArgs} args - Arguments to find a PropertyFavorite
     * @example
     * // Get one PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFavoriteFindUniqueArgs>(args: SelectSubset<T, PropertyFavoriteFindUniqueArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFavoriteFindUniqueOrThrowArgs} args - Arguments to find a PropertyFavorite
     * @example
     * // Get one PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteFindFirstArgs} args - Arguments to find a PropertyFavorite
     * @example
     * // Get one PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFavoriteFindFirstArgs>(args?: SelectSubset<T, PropertyFavoriteFindFirstArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteFindFirstOrThrowArgs} args - Arguments to find a PropertyFavorite
     * @example
     * // Get one PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyFavorites
     * const propertyFavorites = await prisma.propertyFavorite.findMany()
     * 
     * // Get first 10 PropertyFavorites
     * const propertyFavorites = await prisma.propertyFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyFavoriteWithIdOnly = await prisma.propertyFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFavoriteFindManyArgs>(args?: SelectSubset<T, PropertyFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyFavorite.
     * @param {PropertyFavoriteCreateArgs} args - Arguments to create a PropertyFavorite.
     * @example
     * // Create one PropertyFavorite
     * const PropertyFavorite = await prisma.propertyFavorite.create({
     *   data: {
     *     // ... data to create a PropertyFavorite
     *   }
     * })
     * 
     */
    create<T extends PropertyFavoriteCreateArgs>(args: SelectSubset<T, PropertyFavoriteCreateArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyFavorites.
     * @param {PropertyFavoriteCreateManyArgs} args - Arguments to create many PropertyFavorites.
     * @example
     * // Create many PropertyFavorites
     * const propertyFavorite = await prisma.propertyFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyFavoriteCreateManyArgs>(args?: SelectSubset<T, PropertyFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyFavorites and returns the data saved in the database.
     * @param {PropertyFavoriteCreateManyAndReturnArgs} args - Arguments to create many PropertyFavorites.
     * @example
     * // Create many PropertyFavorites
     * const propertyFavorite = await prisma.propertyFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyFavorites and only return the `id`
     * const propertyFavoriteWithIdOnly = await prisma.propertyFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyFavorite.
     * @param {PropertyFavoriteDeleteArgs} args - Arguments to delete one PropertyFavorite.
     * @example
     * // Delete one PropertyFavorite
     * const PropertyFavorite = await prisma.propertyFavorite.delete({
     *   where: {
     *     // ... filter to delete one PropertyFavorite
     *   }
     * })
     * 
     */
    delete<T extends PropertyFavoriteDeleteArgs>(args: SelectSubset<T, PropertyFavoriteDeleteArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyFavorite.
     * @param {PropertyFavoriteUpdateArgs} args - Arguments to update one PropertyFavorite.
     * @example
     * // Update one PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyFavoriteUpdateArgs>(args: SelectSubset<T, PropertyFavoriteUpdateArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyFavorites.
     * @param {PropertyFavoriteDeleteManyArgs} args - Arguments to filter PropertyFavorites to delete.
     * @example
     * // Delete a few PropertyFavorites
     * const { count } = await prisma.propertyFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyFavoriteDeleteManyArgs>(args?: SelectSubset<T, PropertyFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyFavorites
     * const propertyFavorite = await prisma.propertyFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyFavoriteUpdateManyArgs>(args: SelectSubset<T, PropertyFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFavorites and returns the data updated in the database.
     * @param {PropertyFavoriteUpdateManyAndReturnArgs} args - Arguments to update many PropertyFavorites.
     * @example
     * // Update many PropertyFavorites
     * const propertyFavorite = await prisma.propertyFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyFavorites and only return the `id`
     * const propertyFavoriteWithIdOnly = await prisma.propertyFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyFavorite.
     * @param {PropertyFavoriteUpsertArgs} args - Arguments to update or create a PropertyFavorite.
     * @example
     * // Update or create a PropertyFavorite
     * const propertyFavorite = await prisma.propertyFavorite.upsert({
     *   create: {
     *     // ... data to create a PropertyFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyFavorite we want to update
     *   }
     * })
     */
    upsert<T extends PropertyFavoriteUpsertArgs>(args: SelectSubset<T, PropertyFavoriteUpsertArgs<ExtArgs>>): Prisma__PropertyFavoriteClient<$Result.GetResult<Prisma.$PropertyFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteCountArgs} args - Arguments to filter PropertyFavorites to count.
     * @example
     * // Count the number of PropertyFavorites
     * const count = await prisma.propertyFavorite.count({
     *   where: {
     *     // ... the filter for the PropertyFavorites we want to count
     *   }
     * })
    **/
    count<T extends PropertyFavoriteCountArgs>(
      args?: Subset<T, PropertyFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyFavoriteAggregateArgs>(args: Subset<T, PropertyFavoriteAggregateArgs>): Prisma.PrismaPromise<GetPropertyFavoriteAggregateType<T>>

    /**
     * Group by PropertyFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: PropertyFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyFavorite model
   */
  readonly fields: PropertyFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyFavorite$propertyArgs<ExtArgs> = {}>(args?: Subset<T, PropertyFavorite$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends PropertyFavorite$clientArgs<ExtArgs> = {}>(args?: Subset<T, PropertyFavorite$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyFavorite model
   */
  interface PropertyFavoriteFieldRefs {
    readonly id: FieldRef<"PropertyFavorite", 'String'>
    readonly favoriteDate: FieldRef<"PropertyFavorite", 'DateTime'>
    readonly propertyId: FieldRef<"PropertyFavorite", 'String'>
    readonly clientId: FieldRef<"PropertyFavorite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyFavorite findUnique
   */
  export type PropertyFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFavorite to fetch.
     */
    where: PropertyFavoriteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite findUniqueOrThrow
   */
  export type PropertyFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFavorite to fetch.
     */
    where: PropertyFavoriteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite findFirst
   */
  export type PropertyFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFavorite to fetch.
     */
    where?: PropertyFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFavorites to fetch.
     */
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFavorites.
     */
    cursor?: PropertyFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFavorites.
     */
    distinct?: PropertyFavoriteScalarFieldEnum | PropertyFavoriteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite findFirstOrThrow
   */
  export type PropertyFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFavorite to fetch.
     */
    where?: PropertyFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFavorites to fetch.
     */
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFavorites.
     */
    cursor?: PropertyFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFavorites.
     */
    distinct?: PropertyFavoriteScalarFieldEnum | PropertyFavoriteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite findMany
   */
  export type PropertyFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFavorites to fetch.
     */
    where?: PropertyFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFavorites to fetch.
     */
    orderBy?: PropertyFavoriteOrderByWithRelationInput | PropertyFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyFavorites.
     */
    cursor?: PropertyFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFavorites.
     */
    skip?: number
    distinct?: PropertyFavoriteScalarFieldEnum | PropertyFavoriteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite create
   */
  export type PropertyFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyFavorite.
     */
    data: XOR<PropertyFavoriteCreateInput, PropertyFavoriteUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite createMany
   */
  export type PropertyFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyFavorites.
     */
    data: PropertyFavoriteCreateManyInput | PropertyFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyFavorite createManyAndReturn
   */
  export type PropertyFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyFavorites.
     */
    data: PropertyFavoriteCreateManyInput | PropertyFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFavorite update
   */
  export type PropertyFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyFavorite.
     */
    data: XOR<PropertyFavoriteUpdateInput, PropertyFavoriteUncheckedUpdateInput>
    /**
     * Choose, which PropertyFavorite to update.
     */
    where: PropertyFavoriteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite updateMany
   */
  export type PropertyFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyFavorites.
     */
    data: XOR<PropertyFavoriteUpdateManyMutationInput, PropertyFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFavorites to update
     */
    where?: PropertyFavoriteWhereInput
    /**
     * Limit how many PropertyFavorites to update.
     */
    limit?: number
  }

  /**
   * PropertyFavorite updateManyAndReturn
   */
  export type PropertyFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update PropertyFavorites.
     */
    data: XOR<PropertyFavoriteUpdateManyMutationInput, PropertyFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFavorites to update
     */
    where?: PropertyFavoriteWhereInput
    /**
     * Limit how many PropertyFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFavorite upsert
   */
  export type PropertyFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyFavorite to update in case it exists.
     */
    where: PropertyFavoriteWhereUniqueInput
    /**
     * In case the PropertyFavorite found by the `where` argument doesn't exist, create a new PropertyFavorite with this data.
     */
    create: XOR<PropertyFavoriteCreateInput, PropertyFavoriteUncheckedCreateInput>
    /**
     * In case the PropertyFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyFavoriteUpdateInput, PropertyFavoriteUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite delete
   */
  export type PropertyFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
    /**
     * Filter which PropertyFavorite to delete.
     */
    where: PropertyFavoriteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyFavorite deleteMany
   */
  export type PropertyFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFavorites to delete
     */
    where?: PropertyFavoriteWhereInput
    /**
     * Limit how many PropertyFavorites to delete.
     */
    limit?: number
  }

  /**
   * PropertyFavorite.property
   */
  export type PropertyFavorite$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * PropertyFavorite.client
   */
  export type PropertyFavorite$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * PropertyFavorite without action
   */
  export type PropertyFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFavorite
     */
    select?: PropertyFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFavorite
     */
    omit?: PropertyFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model PropertyEngagement
   */

  export type AggregatePropertyEngagement = {
    _count: PropertyEngagementCountAggregateOutputType | null
    _min: PropertyEngagementMinAggregateOutputType | null
    _max: PropertyEngagementMaxAggregateOutputType | null
  }

  export type PropertyEngagementMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    type: $Enums.EngagementType | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyEngagementMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    type: $Enums.EngagementType | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyEngagementCountAggregateOutputType = {
    id: number
    propertyId: number
    type: number
    clientId: number
    createdAt: number
    updatedAt: number
    additionalInfo: number
    _all: number
  }


  export type PropertyEngagementMinAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyEngagementMaxAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyEngagementCountAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    additionalInfo?: true
    _all?: true
  }

  export type PropertyEngagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyEngagement to aggregate.
     */
    where?: PropertyEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyEngagements to fetch.
     */
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyEngagements
    **/
    _count?: true | PropertyEngagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyEngagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyEngagementMaxAggregateInputType
  }

  export type GetPropertyEngagementAggregateType<T extends PropertyEngagementAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyEngagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyEngagement[P]>
      : GetScalarType<T[P], AggregatePropertyEngagement[P]>
  }




  export type PropertyEngagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyEngagementWhereInput
    orderBy?: PropertyEngagementOrderByWithAggregationInput | PropertyEngagementOrderByWithAggregationInput[]
    by: PropertyEngagementScalarFieldEnum[] | PropertyEngagementScalarFieldEnum
    having?: PropertyEngagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyEngagementCountAggregateInputType | true
    _min?: PropertyEngagementMinAggregateInputType
    _max?: PropertyEngagementMaxAggregateInputType
  }

  export type PropertyEngagementGroupByOutputType = {
    id: string
    propertyId: string
    type: $Enums.EngagementType
    clientId: string | null
    createdAt: Date
    updatedAt: Date
    additionalInfo: JsonValue | null
    _count: PropertyEngagementCountAggregateOutputType | null
    _min: PropertyEngagementMinAggregateOutputType | null
    _max: PropertyEngagementMaxAggregateOutputType | null
  }

  type GetPropertyEngagementGroupByPayload<T extends PropertyEngagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyEngagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyEngagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyEngagementGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyEngagementGroupByOutputType[P]>
        }
      >
    >


  export type PropertyEngagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    additionalInfo?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyEngagement"]>

  export type PropertyEngagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    additionalInfo?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyEngagement"]>

  export type PropertyEngagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    additionalInfo?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }, ExtArgs["result"]["propertyEngagement"]>

  export type PropertyEngagementSelectScalar = {
    id?: boolean
    propertyId?: boolean
    type?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    additionalInfo?: boolean
  }

  export type PropertyEngagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "type" | "clientId" | "createdAt" | "updatedAt" | "additionalInfo", ExtArgs["result"]["propertyEngagement"]>
  export type PropertyEngagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }
  export type PropertyEngagementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }
  export type PropertyEngagementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    client?: boolean | PropertyEngagement$clientArgs<ExtArgs>
  }

  export type $PropertyEngagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyEngagement"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      type: $Enums.EngagementType
      clientId: string | null
      createdAt: Date
      updatedAt: Date
      additionalInfo: Prisma.JsonValue | null
    }, ExtArgs["result"]["propertyEngagement"]>
    composites: {}
  }

  type PropertyEngagementGetPayload<S extends boolean | null | undefined | PropertyEngagementDefaultArgs> = $Result.GetResult<Prisma.$PropertyEngagementPayload, S>

  type PropertyEngagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyEngagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PropertyEngagementCountAggregateInputType | true
    }

  export interface PropertyEngagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyEngagement'], meta: { name: 'PropertyEngagement' } }
    /**
     * Find zero or one PropertyEngagement that matches the filter.
     * @param {PropertyEngagementFindUniqueArgs} args - Arguments to find a PropertyEngagement
     * @example
     * // Get one PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyEngagementFindUniqueArgs>(args: SelectSubset<T, PropertyEngagementFindUniqueArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyEngagement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyEngagementFindUniqueOrThrowArgs} args - Arguments to find a PropertyEngagement
     * @example
     * // Get one PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyEngagementFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyEngagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyEngagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementFindFirstArgs} args - Arguments to find a PropertyEngagement
     * @example
     * // Get one PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyEngagementFindFirstArgs>(args?: SelectSubset<T, PropertyEngagementFindFirstArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyEngagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementFindFirstOrThrowArgs} args - Arguments to find a PropertyEngagement
     * @example
     * // Get one PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyEngagementFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyEngagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyEngagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyEngagements
     * const propertyEngagements = await prisma.propertyEngagement.findMany()
     * 
     * // Get first 10 PropertyEngagements
     * const propertyEngagements = await prisma.propertyEngagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyEngagementWithIdOnly = await prisma.propertyEngagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyEngagementFindManyArgs>(args?: SelectSubset<T, PropertyEngagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyEngagement.
     * @param {PropertyEngagementCreateArgs} args - Arguments to create a PropertyEngagement.
     * @example
     * // Create one PropertyEngagement
     * const PropertyEngagement = await prisma.propertyEngagement.create({
     *   data: {
     *     // ... data to create a PropertyEngagement
     *   }
     * })
     * 
     */
    create<T extends PropertyEngagementCreateArgs>(args: SelectSubset<T, PropertyEngagementCreateArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyEngagements.
     * @param {PropertyEngagementCreateManyArgs} args - Arguments to create many PropertyEngagements.
     * @example
     * // Create many PropertyEngagements
     * const propertyEngagement = await prisma.propertyEngagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyEngagementCreateManyArgs>(args?: SelectSubset<T, PropertyEngagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyEngagements and returns the data saved in the database.
     * @param {PropertyEngagementCreateManyAndReturnArgs} args - Arguments to create many PropertyEngagements.
     * @example
     * // Create many PropertyEngagements
     * const propertyEngagement = await prisma.propertyEngagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyEngagements and only return the `id`
     * const propertyEngagementWithIdOnly = await prisma.propertyEngagement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyEngagementCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyEngagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyEngagement.
     * @param {PropertyEngagementDeleteArgs} args - Arguments to delete one PropertyEngagement.
     * @example
     * // Delete one PropertyEngagement
     * const PropertyEngagement = await prisma.propertyEngagement.delete({
     *   where: {
     *     // ... filter to delete one PropertyEngagement
     *   }
     * })
     * 
     */
    delete<T extends PropertyEngagementDeleteArgs>(args: SelectSubset<T, PropertyEngagementDeleteArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyEngagement.
     * @param {PropertyEngagementUpdateArgs} args - Arguments to update one PropertyEngagement.
     * @example
     * // Update one PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyEngagementUpdateArgs>(args: SelectSubset<T, PropertyEngagementUpdateArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyEngagements.
     * @param {PropertyEngagementDeleteManyArgs} args - Arguments to filter PropertyEngagements to delete.
     * @example
     * // Delete a few PropertyEngagements
     * const { count } = await prisma.propertyEngagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyEngagementDeleteManyArgs>(args?: SelectSubset<T, PropertyEngagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyEngagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyEngagements
     * const propertyEngagement = await prisma.propertyEngagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyEngagementUpdateManyArgs>(args: SelectSubset<T, PropertyEngagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyEngagements and returns the data updated in the database.
     * @param {PropertyEngagementUpdateManyAndReturnArgs} args - Arguments to update many PropertyEngagements.
     * @example
     * // Update many PropertyEngagements
     * const propertyEngagement = await prisma.propertyEngagement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyEngagements and only return the `id`
     * const propertyEngagementWithIdOnly = await prisma.propertyEngagement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyEngagementUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyEngagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyEngagement.
     * @param {PropertyEngagementUpsertArgs} args - Arguments to update or create a PropertyEngagement.
     * @example
     * // Update or create a PropertyEngagement
     * const propertyEngagement = await prisma.propertyEngagement.upsert({
     *   create: {
     *     // ... data to create a PropertyEngagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyEngagement we want to update
     *   }
     * })
     */
    upsert<T extends PropertyEngagementUpsertArgs>(args: SelectSubset<T, PropertyEngagementUpsertArgs<ExtArgs>>): Prisma__PropertyEngagementClient<$Result.GetResult<Prisma.$PropertyEngagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyEngagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementCountArgs} args - Arguments to filter PropertyEngagements to count.
     * @example
     * // Count the number of PropertyEngagements
     * const count = await prisma.propertyEngagement.count({
     *   where: {
     *     // ... the filter for the PropertyEngagements we want to count
     *   }
     * })
    **/
    count<T extends PropertyEngagementCountArgs>(
      args?: Subset<T, PropertyEngagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyEngagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyEngagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyEngagementAggregateArgs>(args: Subset<T, PropertyEngagementAggregateArgs>): Prisma.PrismaPromise<GetPropertyEngagementAggregateType<T>>

    /**
     * Group by PropertyEngagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyEngagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyEngagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyEngagementGroupByArgs['orderBy'] }
        : { orderBy?: PropertyEngagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyEngagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyEngagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyEngagement model
   */
  readonly fields: PropertyEngagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyEngagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyEngagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends PropertyEngagement$clientArgs<ExtArgs> = {}>(args?: Subset<T, PropertyEngagement$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyEngagement model
   */
  interface PropertyEngagementFieldRefs {
    readonly id: FieldRef<"PropertyEngagement", 'String'>
    readonly propertyId: FieldRef<"PropertyEngagement", 'String'>
    readonly type: FieldRef<"PropertyEngagement", 'EngagementType'>
    readonly clientId: FieldRef<"PropertyEngagement", 'String'>
    readonly createdAt: FieldRef<"PropertyEngagement", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyEngagement", 'DateTime'>
    readonly additionalInfo: FieldRef<"PropertyEngagement", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PropertyEngagement findUnique
   */
  export type PropertyEngagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter, which PropertyEngagement to fetch.
     */
    where: PropertyEngagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement findUniqueOrThrow
   */
  export type PropertyEngagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter, which PropertyEngagement to fetch.
     */
    where: PropertyEngagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement findFirst
   */
  export type PropertyEngagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter, which PropertyEngagement to fetch.
     */
    where?: PropertyEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyEngagements to fetch.
     */
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyEngagements.
     */
    cursor?: PropertyEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyEngagements.
     */
    distinct?: PropertyEngagementScalarFieldEnum | PropertyEngagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement findFirstOrThrow
   */
  export type PropertyEngagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter, which PropertyEngagement to fetch.
     */
    where?: PropertyEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyEngagements to fetch.
     */
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyEngagements.
     */
    cursor?: PropertyEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyEngagements.
     */
    distinct?: PropertyEngagementScalarFieldEnum | PropertyEngagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement findMany
   */
  export type PropertyEngagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter, which PropertyEngagements to fetch.
     */
    where?: PropertyEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyEngagements to fetch.
     */
    orderBy?: PropertyEngagementOrderByWithRelationInput | PropertyEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyEngagements.
     */
    cursor?: PropertyEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyEngagements.
     */
    skip?: number
    distinct?: PropertyEngagementScalarFieldEnum | PropertyEngagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement create
   */
  export type PropertyEngagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyEngagement.
     */
    data: XOR<PropertyEngagementCreateInput, PropertyEngagementUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement createMany
   */
  export type PropertyEngagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyEngagements.
     */
    data: PropertyEngagementCreateManyInput | PropertyEngagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyEngagement createManyAndReturn
   */
  export type PropertyEngagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyEngagements.
     */
    data: PropertyEngagementCreateManyInput | PropertyEngagementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyEngagement update
   */
  export type PropertyEngagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyEngagement.
     */
    data: XOR<PropertyEngagementUpdateInput, PropertyEngagementUncheckedUpdateInput>
    /**
     * Choose, which PropertyEngagement to update.
     */
    where: PropertyEngagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement updateMany
   */
  export type PropertyEngagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyEngagements.
     */
    data: XOR<PropertyEngagementUpdateManyMutationInput, PropertyEngagementUncheckedUpdateManyInput>
    /**
     * Filter which PropertyEngagements to update
     */
    where?: PropertyEngagementWhereInput
    /**
     * Limit how many PropertyEngagements to update.
     */
    limit?: number
  }

  /**
   * PropertyEngagement updateManyAndReturn
   */
  export type PropertyEngagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * The data used to update PropertyEngagements.
     */
    data: XOR<PropertyEngagementUpdateManyMutationInput, PropertyEngagementUncheckedUpdateManyInput>
    /**
     * Filter which PropertyEngagements to update
     */
    where?: PropertyEngagementWhereInput
    /**
     * Limit how many PropertyEngagements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyEngagement upsert
   */
  export type PropertyEngagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyEngagement to update in case it exists.
     */
    where: PropertyEngagementWhereUniqueInput
    /**
     * In case the PropertyEngagement found by the `where` argument doesn't exist, create a new PropertyEngagement with this data.
     */
    create: XOR<PropertyEngagementCreateInput, PropertyEngagementUncheckedCreateInput>
    /**
     * In case the PropertyEngagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyEngagementUpdateInput, PropertyEngagementUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement delete
   */
  export type PropertyEngagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
    /**
     * Filter which PropertyEngagement to delete.
     */
    where: PropertyEngagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PropertyEngagement deleteMany
   */
  export type PropertyEngagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyEngagements to delete
     */
    where?: PropertyEngagementWhereInput
    /**
     * Limit how many PropertyEngagements to delete.
     */
    limit?: number
  }

  /**
   * PropertyEngagement.client
   */
  export type PropertyEngagement$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * PropertyEngagement without action
   */
  export type PropertyEngagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyEngagement
     */
    select?: PropertyEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyEngagement
     */
    omit?: PropertyEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyEngagementInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    size: number | null
  }

  export type ProposalSumAggregateOutputType = {
    size: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    size: number | null
    category: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    status: $Enums.ProposalStatus | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    size: number | null
    category: $Enums.PropertyType | null
    listingType: $Enums.PropertyListingType | null
    status: $Enums.ProposalStatus | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    title: number
    description: number
    location: number
    size: number
    category: number
    listingType: number
    status: number
    photos: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    size?: true
  }

  export type ProposalSumAggregateInputType = {
    size?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    size?: true
    category?: true
    listingType?: true
    status?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    size?: true
    category?: true
    listingType?: true
    status?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    size?: true
    category?: true
    listingType?: true
    status?: true
    photos?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    title: string
    description: string
    location: string
    size: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status: $Enums.ProposalStatus
    photos: JsonValue | null
    clientId: string
    createdAt: Date
    updatedAt: Date
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    size?: boolean
    category?: boolean
    listingType?: boolean
    status?: boolean
    photos?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    offers?: boolean | Proposal$offersArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    size?: boolean
    category?: boolean
    listingType?: boolean
    status?: boolean
    photos?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    size?: boolean
    category?: boolean
    listingType?: boolean
    status?: boolean
    photos?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    size?: boolean
    category?: boolean
    listingType?: boolean
    status?: boolean
    photos?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "location" | "size" | "category" | "listingType" | "status" | "photos" | "clientId" | "createdAt" | "updatedAt", ExtArgs["result"]["proposal"]>
  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    offers?: boolean | Proposal$offersArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      offers: Prisma.$ProposalOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      location: string
      size: number | null
      category: $Enums.PropertyType
      listingType: $Enums.PropertyListingType
      status: $Enums.ProposalStatus
      photos: Prisma.JsonValue | null
      clientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {ProposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals and returns the data updated in the database.
     * @param {ProposalUpdateManyAndReturnArgs} args - Arguments to update many Proposals.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offers<T extends Proposal$offersArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly title: FieldRef<"Proposal", 'String'>
    readonly description: FieldRef<"Proposal", 'String'>
    readonly location: FieldRef<"Proposal", 'String'>
    readonly size: FieldRef<"Proposal", 'Int'>
    readonly category: FieldRef<"Proposal", 'PropertyType'>
    readonly listingType: FieldRef<"Proposal", 'PropertyListingType'>
    readonly status: FieldRef<"Proposal", 'ProposalStatus'>
    readonly photos: FieldRef<"Proposal", 'Json'>
    readonly clientId: FieldRef<"Proposal", 'String'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly updatedAt: FieldRef<"Proposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proposal createManyAndReturn
   */
  export type ProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
  }

  /**
   * Proposal updateManyAndReturn
   */
  export type ProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to delete.
     */
    limit?: number
  }

  /**
   * Proposal.offers
   */
  export type Proposal$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    where?: ProposalOfferWhereInput
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    cursor?: ProposalOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalOfferScalarFieldEnum | ProposalOfferScalarFieldEnum[]
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Model ProposalOffer
   */

  export type AggregateProposalOffer = {
    _count: ProposalOfferCountAggregateOutputType | null
    _avg: ProposalOfferAvgAggregateOutputType | null
    _sum: ProposalOfferSumAggregateOutputType | null
    _min: ProposalOfferMinAggregateOutputType | null
    _max: ProposalOfferMaxAggregateOutputType | null
  }

  export type ProposalOfferAvgAggregateOutputType = {
    price: number | null
  }

  export type ProposalOfferSumAggregateOutputType = {
    price: number | null
  }

  export type ProposalOfferMinAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
    description: string | null
    saleTimeline: Date | null
    proposalId: string | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalOfferMaxAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
    description: string | null
    saleTimeline: Date | null
    proposalId: string | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalOfferCountAggregateOutputType = {
    id: number
    title: number
    price: number
    description: number
    saleTimeline: number
    proposalId: number
    agencyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalOfferAvgAggregateInputType = {
    price?: true
  }

  export type ProposalOfferSumAggregateInputType = {
    price?: true
  }

  export type ProposalOfferMinAggregateInputType = {
    id?: true
    title?: true
    price?: true
    description?: true
    saleTimeline?: true
    proposalId?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalOfferMaxAggregateInputType = {
    id?: true
    title?: true
    price?: true
    description?: true
    saleTimeline?: true
    proposalId?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalOfferCountAggregateInputType = {
    id?: true
    title?: true
    price?: true
    description?: true
    saleTimeline?: true
    proposalId?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalOffer to aggregate.
     */
    where?: ProposalOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOffers to fetch.
     */
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalOffers
    **/
    _count?: true | ProposalOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalOfferMaxAggregateInputType
  }

  export type GetProposalOfferAggregateType<T extends ProposalOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalOffer[P]>
      : GetScalarType<T[P], AggregateProposalOffer[P]>
  }




  export type ProposalOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalOfferWhereInput
    orderBy?: ProposalOfferOrderByWithAggregationInput | ProposalOfferOrderByWithAggregationInput[]
    by: ProposalOfferScalarFieldEnum[] | ProposalOfferScalarFieldEnum
    having?: ProposalOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalOfferCountAggregateInputType | true
    _avg?: ProposalOfferAvgAggregateInputType
    _sum?: ProposalOfferSumAggregateInputType
    _min?: ProposalOfferMinAggregateInputType
    _max?: ProposalOfferMaxAggregateInputType
  }

  export type ProposalOfferGroupByOutputType = {
    id: string
    title: string
    price: number
    description: string
    saleTimeline: Date
    proposalId: string
    agencyId: string
    createdAt: Date
    updatedAt: Date
    _count: ProposalOfferCountAggregateOutputType | null
    _avg: ProposalOfferAvgAggregateOutputType | null
    _sum: ProposalOfferSumAggregateOutputType | null
    _min: ProposalOfferMinAggregateOutputType | null
    _max: ProposalOfferMaxAggregateOutputType | null
  }

  type GetProposalOfferGroupByPayload<T extends ProposalOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalOfferGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalOfferGroupByOutputType[P]>
        }
      >
    >


  export type ProposalOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    saleTimeline?: boolean
    proposalId?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    proposalCollaboration?: boolean | ProposalOffer$proposalCollaborationArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOffer"]>

  export type ProposalOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    saleTimeline?: boolean
    proposalId?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOffer"]>

  export type ProposalOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    saleTimeline?: boolean
    proposalId?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOffer"]>

  export type ProposalOfferSelectScalar = {
    id?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    saleTimeline?: boolean
    proposalId?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "price" | "description" | "saleTimeline" | "proposalId" | "agencyId" | "createdAt" | "updatedAt", ExtArgs["result"]["proposalOffer"]>
  export type ProposalOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    proposalCollaboration?: boolean | ProposalOffer$proposalCollaborationArgs<ExtArgs>
  }
  export type ProposalOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type ProposalOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $ProposalOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalOffer"
    objects: {
      proposal: Prisma.$ProposalPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      proposalCollaboration: Prisma.$ProposalCollaborationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      price: number
      description: string
      saleTimeline: Date
      proposalId: string
      agencyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposalOffer"]>
    composites: {}
  }

  type ProposalOfferGetPayload<S extends boolean | null | undefined | ProposalOfferDefaultArgs> = $Result.GetResult<Prisma.$ProposalOfferPayload, S>

  type ProposalOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProposalOfferCountAggregateInputType | true
    }

  export interface ProposalOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalOffer'], meta: { name: 'ProposalOffer' } }
    /**
     * Find zero or one ProposalOffer that matches the filter.
     * @param {ProposalOfferFindUniqueArgs} args - Arguments to find a ProposalOffer
     * @example
     * // Get one ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalOfferFindUniqueArgs>(args: SelectSubset<T, ProposalOfferFindUniqueArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProposalOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalOfferFindUniqueOrThrowArgs} args - Arguments to find a ProposalOffer
     * @example
     * // Get one ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferFindFirstArgs} args - Arguments to find a ProposalOffer
     * @example
     * // Get one ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalOfferFindFirstArgs>(args?: SelectSubset<T, ProposalOfferFindFirstArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferFindFirstOrThrowArgs} args - Arguments to find a ProposalOffer
     * @example
     * // Get one ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProposalOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalOffers
     * const proposalOffers = await prisma.proposalOffer.findMany()
     * 
     * // Get first 10 ProposalOffers
     * const proposalOffers = await prisma.proposalOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalOfferWithIdOnly = await prisma.proposalOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalOfferFindManyArgs>(args?: SelectSubset<T, ProposalOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProposalOffer.
     * @param {ProposalOfferCreateArgs} args - Arguments to create a ProposalOffer.
     * @example
     * // Create one ProposalOffer
     * const ProposalOffer = await prisma.proposalOffer.create({
     *   data: {
     *     // ... data to create a ProposalOffer
     *   }
     * })
     * 
     */
    create<T extends ProposalOfferCreateArgs>(args: SelectSubset<T, ProposalOfferCreateArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProposalOffers.
     * @param {ProposalOfferCreateManyArgs} args - Arguments to create many ProposalOffers.
     * @example
     * // Create many ProposalOffers
     * const proposalOffer = await prisma.proposalOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalOfferCreateManyArgs>(args?: SelectSubset<T, ProposalOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalOffers and returns the data saved in the database.
     * @param {ProposalOfferCreateManyAndReturnArgs} args - Arguments to create many ProposalOffers.
     * @example
     * // Create many ProposalOffers
     * const proposalOffer = await prisma.proposalOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalOffers and only return the `id`
     * const proposalOfferWithIdOnly = await prisma.proposalOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProposalOffer.
     * @param {ProposalOfferDeleteArgs} args - Arguments to delete one ProposalOffer.
     * @example
     * // Delete one ProposalOffer
     * const ProposalOffer = await prisma.proposalOffer.delete({
     *   where: {
     *     // ... filter to delete one ProposalOffer
     *   }
     * })
     * 
     */
    delete<T extends ProposalOfferDeleteArgs>(args: SelectSubset<T, ProposalOfferDeleteArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProposalOffer.
     * @param {ProposalOfferUpdateArgs} args - Arguments to update one ProposalOffer.
     * @example
     * // Update one ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalOfferUpdateArgs>(args: SelectSubset<T, ProposalOfferUpdateArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProposalOffers.
     * @param {ProposalOfferDeleteManyArgs} args - Arguments to filter ProposalOffers to delete.
     * @example
     * // Delete a few ProposalOffers
     * const { count } = await prisma.proposalOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalOfferDeleteManyArgs>(args?: SelectSubset<T, ProposalOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalOffers
     * const proposalOffer = await prisma.proposalOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalOfferUpdateManyArgs>(args: SelectSubset<T, ProposalOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalOffers and returns the data updated in the database.
     * @param {ProposalOfferUpdateManyAndReturnArgs} args - Arguments to update many ProposalOffers.
     * @example
     * // Update many ProposalOffers
     * const proposalOffer = await prisma.proposalOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProposalOffers and only return the `id`
     * const proposalOfferWithIdOnly = await prisma.proposalOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProposalOffer.
     * @param {ProposalOfferUpsertArgs} args - Arguments to update or create a ProposalOffer.
     * @example
     * // Update or create a ProposalOffer
     * const proposalOffer = await prisma.proposalOffer.upsert({
     *   create: {
     *     // ... data to create a ProposalOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalOffer we want to update
     *   }
     * })
     */
    upsert<T extends ProposalOfferUpsertArgs>(args: SelectSubset<T, ProposalOfferUpsertArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProposalOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferCountArgs} args - Arguments to filter ProposalOffers to count.
     * @example
     * // Count the number of ProposalOffers
     * const count = await prisma.proposalOffer.count({
     *   where: {
     *     // ... the filter for the ProposalOffers we want to count
     *   }
     * })
    **/
    count<T extends ProposalOfferCountArgs>(
      args?: Subset<T, ProposalOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalOfferAggregateArgs>(args: Subset<T, ProposalOfferAggregateArgs>): Prisma.PrismaPromise<GetProposalOfferAggregateType<T>>

    /**
     * Group by ProposalOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalOfferGroupByArgs['orderBy'] }
        : { orderBy?: ProposalOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalOffer model
   */
  readonly fields: ProposalOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposalCollaboration<T extends ProposalOffer$proposalCollaborationArgs<ExtArgs> = {}>(args?: Subset<T, ProposalOffer$proposalCollaborationArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalOffer model
   */
  interface ProposalOfferFieldRefs {
    readonly id: FieldRef<"ProposalOffer", 'String'>
    readonly title: FieldRef<"ProposalOffer", 'String'>
    readonly price: FieldRef<"ProposalOffer", 'Int'>
    readonly description: FieldRef<"ProposalOffer", 'String'>
    readonly saleTimeline: FieldRef<"ProposalOffer", 'DateTime'>
    readonly proposalId: FieldRef<"ProposalOffer", 'String'>
    readonly agencyId: FieldRef<"ProposalOffer", 'String'>
    readonly createdAt: FieldRef<"ProposalOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"ProposalOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalOffer findUnique
   */
  export type ProposalOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOffer to fetch.
     */
    where: ProposalOfferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer findUniqueOrThrow
   */
  export type ProposalOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOffer to fetch.
     */
    where: ProposalOfferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer findFirst
   */
  export type ProposalOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOffer to fetch.
     */
    where?: ProposalOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOffers to fetch.
     */
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalOffers.
     */
    cursor?: ProposalOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalOffers.
     */
    distinct?: ProposalOfferScalarFieldEnum | ProposalOfferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer findFirstOrThrow
   */
  export type ProposalOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOffer to fetch.
     */
    where?: ProposalOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOffers to fetch.
     */
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalOffers.
     */
    cursor?: ProposalOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalOffers.
     */
    distinct?: ProposalOfferScalarFieldEnum | ProposalOfferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer findMany
   */
  export type ProposalOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOffers to fetch.
     */
    where?: ProposalOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOffers to fetch.
     */
    orderBy?: ProposalOfferOrderByWithRelationInput | ProposalOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalOffers.
     */
    cursor?: ProposalOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOffers.
     */
    skip?: number
    distinct?: ProposalOfferScalarFieldEnum | ProposalOfferScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer create
   */
  export type ProposalOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalOffer.
     */
    data: XOR<ProposalOfferCreateInput, ProposalOfferUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer createMany
   */
  export type ProposalOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalOffers.
     */
    data: ProposalOfferCreateManyInput | ProposalOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalOffer createManyAndReturn
   */
  export type ProposalOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * The data used to create many ProposalOffers.
     */
    data: ProposalOfferCreateManyInput | ProposalOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalOffer update
   */
  export type ProposalOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalOffer.
     */
    data: XOR<ProposalOfferUpdateInput, ProposalOfferUncheckedUpdateInput>
    /**
     * Choose, which ProposalOffer to update.
     */
    where: ProposalOfferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer updateMany
   */
  export type ProposalOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalOffers.
     */
    data: XOR<ProposalOfferUpdateManyMutationInput, ProposalOfferUncheckedUpdateManyInput>
    /**
     * Filter which ProposalOffers to update
     */
    where?: ProposalOfferWhereInput
    /**
     * Limit how many ProposalOffers to update.
     */
    limit?: number
  }

  /**
   * ProposalOffer updateManyAndReturn
   */
  export type ProposalOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * The data used to update ProposalOffers.
     */
    data: XOR<ProposalOfferUpdateManyMutationInput, ProposalOfferUncheckedUpdateManyInput>
    /**
     * Filter which ProposalOffers to update
     */
    where?: ProposalOfferWhereInput
    /**
     * Limit how many ProposalOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalOffer upsert
   */
  export type ProposalOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalOffer to update in case it exists.
     */
    where: ProposalOfferWhereUniqueInput
    /**
     * In case the ProposalOffer found by the `where` argument doesn't exist, create a new ProposalOffer with this data.
     */
    create: XOR<ProposalOfferCreateInput, ProposalOfferUncheckedCreateInput>
    /**
     * In case the ProposalOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalOfferUpdateInput, ProposalOfferUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer delete
   */
  export type ProposalOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    /**
     * Filter which ProposalOffer to delete.
     */
    where: ProposalOfferWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalOffer deleteMany
   */
  export type ProposalOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalOffers to delete
     */
    where?: ProposalOfferWhereInput
    /**
     * Limit how many ProposalOffers to delete.
     */
    limit?: number
  }

  /**
   * ProposalOffer.proposalCollaboration
   */
  export type ProposalOffer$proposalCollaborationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    where?: ProposalCollaborationWhereInput
  }

  /**
   * ProposalOffer without action
   */
  export type ProposalOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
  }


  /**
   * Model ProposalCollaboration
   */

  export type AggregateProposalCollaboration = {
    _count: ProposalCollaborationCountAggregateOutputType | null
    _min: ProposalCollaborationMinAggregateOutputType | null
    _max: ProposalCollaborationMaxAggregateOutputType | null
  }

  export type ProposalCollaborationMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    title: string | null
    description: string | null
    email: string | null
    phone: string | null
    agencyId: string | null
    proposalOfferId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCollaborationMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    title: string | null
    description: string | null
    email: string | null
    phone: string | null
    agencyId: string | null
    proposalOfferId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCollaborationCountAggregateOutputType = {
    id: number
    clientId: number
    title: number
    description: number
    email: number
    phone: number
    agencyId: number
    proposalOfferId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalCollaborationMinAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    email?: true
    phone?: true
    agencyId?: true
    proposalOfferId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCollaborationMaxAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    email?: true
    phone?: true
    agencyId?: true
    proposalOfferId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCollaborationCountAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    email?: true
    phone?: true
    agencyId?: true
    proposalOfferId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalCollaborationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalCollaboration to aggregate.
     */
    where?: ProposalCollaborationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCollaborations to fetch.
     */
    orderBy?: ProposalCollaborationOrderByWithRelationInput | ProposalCollaborationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalCollaborationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCollaborations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCollaborations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalCollaborations
    **/
    _count?: true | ProposalCollaborationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalCollaborationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalCollaborationMaxAggregateInputType
  }

  export type GetProposalCollaborationAggregateType<T extends ProposalCollaborationAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalCollaboration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalCollaboration[P]>
      : GetScalarType<T[P], AggregateProposalCollaboration[P]>
  }




  export type ProposalCollaborationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalCollaborationWhereInput
    orderBy?: ProposalCollaborationOrderByWithAggregationInput | ProposalCollaborationOrderByWithAggregationInput[]
    by: ProposalCollaborationScalarFieldEnum[] | ProposalCollaborationScalarFieldEnum
    having?: ProposalCollaborationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCollaborationCountAggregateInputType | true
    _min?: ProposalCollaborationMinAggregateInputType
    _max?: ProposalCollaborationMaxAggregateInputType
  }

  export type ProposalCollaborationGroupByOutputType = {
    id: string
    clientId: string
    title: string
    description: string
    email: string
    phone: string | null
    agencyId: string
    proposalOfferId: string
    createdAt: Date
    updatedAt: Date
    _count: ProposalCollaborationCountAggregateOutputType | null
    _min: ProposalCollaborationMinAggregateOutputType | null
    _max: ProposalCollaborationMaxAggregateOutputType | null
  }

  type GetProposalCollaborationGroupByPayload<T extends ProposalCollaborationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalCollaborationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalCollaborationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalCollaborationGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalCollaborationGroupByOutputType[P]>
        }
      >
    >


  export type ProposalCollaborationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    agencyId?: boolean
    proposalOfferId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }, ExtArgs["result"]["proposalCollaboration"]>

  export type ProposalCollaborationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    agencyId?: boolean
    proposalOfferId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }, ExtArgs["result"]["proposalCollaboration"]>

  export type ProposalCollaborationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    agencyId?: boolean
    proposalOfferId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }, ExtArgs["result"]["proposalCollaboration"]>

  export type ProposalCollaborationSelectScalar = {
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    agencyId?: boolean
    proposalOfferId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalCollaborationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "title" | "description" | "email" | "phone" | "agencyId" | "proposalOfferId" | "createdAt" | "updatedAt", ExtArgs["result"]["proposalCollaboration"]>
  export type ProposalCollaborationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }
  export type ProposalCollaborationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }
  export type ProposalCollaborationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    proposalOffer?: boolean | ProposalCollaboration$proposalOfferArgs<ExtArgs>
  }

  export type $ProposalCollaborationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalCollaboration"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      proposalOffer: Prisma.$ProposalOfferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      title: string
      description: string
      email: string
      phone: string | null
      agencyId: string
      proposalOfferId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposalCollaboration"]>
    composites: {}
  }

  type ProposalCollaborationGetPayload<S extends boolean | null | undefined | ProposalCollaborationDefaultArgs> = $Result.GetResult<Prisma.$ProposalCollaborationPayload, S>

  type ProposalCollaborationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalCollaborationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProposalCollaborationCountAggregateInputType | true
    }

  export interface ProposalCollaborationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalCollaboration'], meta: { name: 'ProposalCollaboration' } }
    /**
     * Find zero or one ProposalCollaboration that matches the filter.
     * @param {ProposalCollaborationFindUniqueArgs} args - Arguments to find a ProposalCollaboration
     * @example
     * // Get one ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalCollaborationFindUniqueArgs>(args: SelectSubset<T, ProposalCollaborationFindUniqueArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProposalCollaboration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalCollaborationFindUniqueOrThrowArgs} args - Arguments to find a ProposalCollaboration
     * @example
     * // Get one ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalCollaborationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalCollaborationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalCollaboration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationFindFirstArgs} args - Arguments to find a ProposalCollaboration
     * @example
     * // Get one ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalCollaborationFindFirstArgs>(args?: SelectSubset<T, ProposalCollaborationFindFirstArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalCollaboration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationFindFirstOrThrowArgs} args - Arguments to find a ProposalCollaboration
     * @example
     * // Get one ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalCollaborationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalCollaborationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProposalCollaborations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalCollaborations
     * const proposalCollaborations = await prisma.proposalCollaboration.findMany()
     * 
     * // Get first 10 ProposalCollaborations
     * const proposalCollaborations = await prisma.proposalCollaboration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalCollaborationWithIdOnly = await prisma.proposalCollaboration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalCollaborationFindManyArgs>(args?: SelectSubset<T, ProposalCollaborationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProposalCollaboration.
     * @param {ProposalCollaborationCreateArgs} args - Arguments to create a ProposalCollaboration.
     * @example
     * // Create one ProposalCollaboration
     * const ProposalCollaboration = await prisma.proposalCollaboration.create({
     *   data: {
     *     // ... data to create a ProposalCollaboration
     *   }
     * })
     * 
     */
    create<T extends ProposalCollaborationCreateArgs>(args: SelectSubset<T, ProposalCollaborationCreateArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProposalCollaborations.
     * @param {ProposalCollaborationCreateManyArgs} args - Arguments to create many ProposalCollaborations.
     * @example
     * // Create many ProposalCollaborations
     * const proposalCollaboration = await prisma.proposalCollaboration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCollaborationCreateManyArgs>(args?: SelectSubset<T, ProposalCollaborationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalCollaborations and returns the data saved in the database.
     * @param {ProposalCollaborationCreateManyAndReturnArgs} args - Arguments to create many ProposalCollaborations.
     * @example
     * // Create many ProposalCollaborations
     * const proposalCollaboration = await prisma.proposalCollaboration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalCollaborations and only return the `id`
     * const proposalCollaborationWithIdOnly = await prisma.proposalCollaboration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCollaborationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCollaborationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProposalCollaboration.
     * @param {ProposalCollaborationDeleteArgs} args - Arguments to delete one ProposalCollaboration.
     * @example
     * // Delete one ProposalCollaboration
     * const ProposalCollaboration = await prisma.proposalCollaboration.delete({
     *   where: {
     *     // ... filter to delete one ProposalCollaboration
     *   }
     * })
     * 
     */
    delete<T extends ProposalCollaborationDeleteArgs>(args: SelectSubset<T, ProposalCollaborationDeleteArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProposalCollaboration.
     * @param {ProposalCollaborationUpdateArgs} args - Arguments to update one ProposalCollaboration.
     * @example
     * // Update one ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalCollaborationUpdateArgs>(args: SelectSubset<T, ProposalCollaborationUpdateArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProposalCollaborations.
     * @param {ProposalCollaborationDeleteManyArgs} args - Arguments to filter ProposalCollaborations to delete.
     * @example
     * // Delete a few ProposalCollaborations
     * const { count } = await prisma.proposalCollaboration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalCollaborationDeleteManyArgs>(args?: SelectSubset<T, ProposalCollaborationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalCollaborations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalCollaborations
     * const proposalCollaboration = await prisma.proposalCollaboration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalCollaborationUpdateManyArgs>(args: SelectSubset<T, ProposalCollaborationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalCollaborations and returns the data updated in the database.
     * @param {ProposalCollaborationUpdateManyAndReturnArgs} args - Arguments to update many ProposalCollaborations.
     * @example
     * // Update many ProposalCollaborations
     * const proposalCollaboration = await prisma.proposalCollaboration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProposalCollaborations and only return the `id`
     * const proposalCollaborationWithIdOnly = await prisma.proposalCollaboration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalCollaborationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalCollaborationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProposalCollaboration.
     * @param {ProposalCollaborationUpsertArgs} args - Arguments to update or create a ProposalCollaboration.
     * @example
     * // Update or create a ProposalCollaboration
     * const proposalCollaboration = await prisma.proposalCollaboration.upsert({
     *   create: {
     *     // ... data to create a ProposalCollaboration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalCollaboration we want to update
     *   }
     * })
     */
    upsert<T extends ProposalCollaborationUpsertArgs>(args: SelectSubset<T, ProposalCollaborationUpsertArgs<ExtArgs>>): Prisma__ProposalCollaborationClient<$Result.GetResult<Prisma.$ProposalCollaborationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProposalCollaborations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationCountArgs} args - Arguments to filter ProposalCollaborations to count.
     * @example
     * // Count the number of ProposalCollaborations
     * const count = await prisma.proposalCollaboration.count({
     *   where: {
     *     // ... the filter for the ProposalCollaborations we want to count
     *   }
     * })
    **/
    count<T extends ProposalCollaborationCountArgs>(
      args?: Subset<T, ProposalCollaborationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCollaborationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalCollaboration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalCollaborationAggregateArgs>(args: Subset<T, ProposalCollaborationAggregateArgs>): Prisma.PrismaPromise<GetProposalCollaborationAggregateType<T>>

    /**
     * Group by ProposalCollaboration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCollaborationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalCollaborationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalCollaborationGroupByArgs['orderBy'] }
        : { orderBy?: ProposalCollaborationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalCollaborationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalCollaborationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalCollaboration model
   */
  readonly fields: ProposalCollaborationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalCollaboration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalCollaborationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposalOffer<T extends ProposalCollaboration$proposalOfferArgs<ExtArgs> = {}>(args?: Subset<T, ProposalCollaboration$proposalOfferArgs<ExtArgs>>): Prisma__ProposalOfferClient<$Result.GetResult<Prisma.$ProposalOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalCollaboration model
   */
  interface ProposalCollaborationFieldRefs {
    readonly id: FieldRef<"ProposalCollaboration", 'String'>
    readonly clientId: FieldRef<"ProposalCollaboration", 'String'>
    readonly title: FieldRef<"ProposalCollaboration", 'String'>
    readonly description: FieldRef<"ProposalCollaboration", 'String'>
    readonly email: FieldRef<"ProposalCollaboration", 'String'>
    readonly phone: FieldRef<"ProposalCollaboration", 'String'>
    readonly agencyId: FieldRef<"ProposalCollaboration", 'String'>
    readonly proposalOfferId: FieldRef<"ProposalCollaboration", 'String'>
    readonly createdAt: FieldRef<"ProposalCollaboration", 'DateTime'>
    readonly updatedAt: FieldRef<"ProposalCollaboration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalCollaboration findUnique
   */
  export type ProposalCollaborationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCollaboration to fetch.
     */
    where: ProposalCollaborationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration findUniqueOrThrow
   */
  export type ProposalCollaborationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCollaboration to fetch.
     */
    where: ProposalCollaborationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration findFirst
   */
  export type ProposalCollaborationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCollaboration to fetch.
     */
    where?: ProposalCollaborationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCollaborations to fetch.
     */
    orderBy?: ProposalCollaborationOrderByWithRelationInput | ProposalCollaborationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalCollaborations.
     */
    cursor?: ProposalCollaborationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCollaborations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCollaborations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalCollaborations.
     */
    distinct?: ProposalCollaborationScalarFieldEnum | ProposalCollaborationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration findFirstOrThrow
   */
  export type ProposalCollaborationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCollaboration to fetch.
     */
    where?: ProposalCollaborationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCollaborations to fetch.
     */
    orderBy?: ProposalCollaborationOrderByWithRelationInput | ProposalCollaborationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalCollaborations.
     */
    cursor?: ProposalCollaborationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCollaborations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCollaborations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalCollaborations.
     */
    distinct?: ProposalCollaborationScalarFieldEnum | ProposalCollaborationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration findMany
   */
  export type ProposalCollaborationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCollaborations to fetch.
     */
    where?: ProposalCollaborationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCollaborations to fetch.
     */
    orderBy?: ProposalCollaborationOrderByWithRelationInput | ProposalCollaborationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalCollaborations.
     */
    cursor?: ProposalCollaborationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCollaborations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCollaborations.
     */
    skip?: number
    distinct?: ProposalCollaborationScalarFieldEnum | ProposalCollaborationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration create
   */
  export type ProposalCollaborationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalCollaboration.
     */
    data: XOR<ProposalCollaborationCreateInput, ProposalCollaborationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration createMany
   */
  export type ProposalCollaborationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalCollaborations.
     */
    data: ProposalCollaborationCreateManyInput | ProposalCollaborationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalCollaboration createManyAndReturn
   */
  export type ProposalCollaborationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * The data used to create many ProposalCollaborations.
     */
    data: ProposalCollaborationCreateManyInput | ProposalCollaborationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalCollaboration update
   */
  export type ProposalCollaborationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalCollaboration.
     */
    data: XOR<ProposalCollaborationUpdateInput, ProposalCollaborationUncheckedUpdateInput>
    /**
     * Choose, which ProposalCollaboration to update.
     */
    where: ProposalCollaborationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration updateMany
   */
  export type ProposalCollaborationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalCollaborations.
     */
    data: XOR<ProposalCollaborationUpdateManyMutationInput, ProposalCollaborationUncheckedUpdateManyInput>
    /**
     * Filter which ProposalCollaborations to update
     */
    where?: ProposalCollaborationWhereInput
    /**
     * Limit how many ProposalCollaborations to update.
     */
    limit?: number
  }

  /**
   * ProposalCollaboration updateManyAndReturn
   */
  export type ProposalCollaborationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * The data used to update ProposalCollaborations.
     */
    data: XOR<ProposalCollaborationUpdateManyMutationInput, ProposalCollaborationUncheckedUpdateManyInput>
    /**
     * Filter which ProposalCollaborations to update
     */
    where?: ProposalCollaborationWhereInput
    /**
     * Limit how many ProposalCollaborations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalCollaboration upsert
   */
  export type ProposalCollaborationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalCollaboration to update in case it exists.
     */
    where: ProposalCollaborationWhereUniqueInput
    /**
     * In case the ProposalCollaboration found by the `where` argument doesn't exist, create a new ProposalCollaboration with this data.
     */
    create: XOR<ProposalCollaborationCreateInput, ProposalCollaborationUncheckedCreateInput>
    /**
     * In case the ProposalCollaboration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalCollaborationUpdateInput, ProposalCollaborationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration delete
   */
  export type ProposalCollaborationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
    /**
     * Filter which ProposalCollaboration to delete.
     */
    where: ProposalCollaborationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProposalCollaboration deleteMany
   */
  export type ProposalCollaborationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalCollaborations to delete
     */
    where?: ProposalCollaborationWhereInput
    /**
     * Limit how many ProposalCollaborations to delete.
     */
    limit?: number
  }

  /**
   * ProposalCollaboration.proposalOffer
   */
  export type ProposalCollaboration$proposalOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOffer
     */
    select?: ProposalOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOffer
     */
    omit?: ProposalOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOfferInclude<ExtArgs> | null
    where?: ProposalOfferWhereInput
  }

  /**
   * ProposalCollaboration without action
   */
  export type ProposalCollaborationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCollaboration
     */
    select?: ProposalCollaborationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalCollaboration
     */
    omit?: ProposalCollaborationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCollaborationInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly userId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    lastName: string | null
    email: string | null
    location: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    phone: string | null
    accessToken: string | null
    refreshToken: string | null
    language: $Enums.UserLanguage | null
    role: $Enums.UserRole | null
    clientId: string | null
    agencyId: string | null
    adminId: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lastName: string | null
    email: string | null
    location: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    phone: string | null
    accessToken: string | null
    refreshToken: string | null
    language: $Enums.UserLanguage | null
    role: $Enums.UserRole | null
    clientId: string | null
    agencyId: string | null
    adminId: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    lastName: number
    email: number
    location: number
    emailVerified: number
    image: number
    hashedPassword: number
    phone: number
    accessToken: number
    refreshToken: number
    language: number
    role: number
    clientId: number
    agencyId: number
    adminId: number
    ipAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    location?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    phone?: true
    accessToken?: true
    refreshToken?: true
    language?: true
    role?: true
    clientId?: true
    agencyId?: true
    adminId?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    location?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    phone?: true
    accessToken?: true
    refreshToken?: true
    language?: true
    role?: true
    clientId?: true
    agencyId?: true
    adminId?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    location?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    phone?: true
    accessToken?: true
    refreshToken?: true
    language?: true
    role?: true
    clientId?: true
    agencyId?: true
    adminId?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    lastName: string | null
    email: string
    location: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    phone: string | null
    accessToken: string | null
    refreshToken: string | null
    language: $Enums.UserLanguage | null
    role: $Enums.UserRole
    clientId: string | null
    agencyId: string | null
    adminId: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    location?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    phone?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    language?: boolean
    role?: boolean
    clientId?: boolean
    agencyId?: boolean
    adminId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | User$accountArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    agency?: boolean | User$agencyArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    UserFeatureRequest?: boolean | User$UserFeatureRequestArgs<ExtArgs>
    agencyMember?: boolean | User$agencyMemberArgs<ExtArgs>
    ownedAgency?: boolean | User$ownedAgencyArgs<ExtArgs>
    agencyInvitationSender?: boolean | User$agencyInvitationSenderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    location?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    phone?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    language?: boolean
    role?: boolean
    clientId?: boolean
    agencyId?: boolean
    adminId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | User$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    location?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    phone?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    language?: boolean
    role?: boolean
    clientId?: boolean
    agencyId?: boolean
    adminId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | User$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    location?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    phone?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    language?: boolean
    role?: boolean
    clientId?: boolean
    agencyId?: boolean
    adminId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "lastName" | "email" | "location" | "emailVerified" | "image" | "hashedPassword" | "phone" | "accessToken" | "refreshToken" | "language" | "role" | "clientId" | "agencyId" | "adminId" | "ipAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | User$accountArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    agency?: boolean | User$agencyArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    UserFeatureRequest?: boolean | User$UserFeatureRequestArgs<ExtArgs>
    agencyMember?: boolean | User$agencyMemberArgs<ExtArgs>
    ownedAgency?: boolean | User$ownedAgencyArgs<ExtArgs>
    agencyInvitationSender?: boolean | User$agencyInvitationSenderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | User$agencyArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | User$agencyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      UserFeatureRequest: Prisma.$UserFeatureRequestPayload<ExtArgs>[]
      agencyMember: Prisma.$AgencyMemberPayload<ExtArgs> | null
      ownedAgency: Prisma.$AgencyPayload<ExtArgs> | null
      agencyInvitationSender: Prisma.$AgencyInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      lastName: string | null
      email: string
      location: string | null
      emailVerified: Date | null
      image: string | null
      hashedPassword: string | null
      phone: string | null
      accessToken: string | null
      refreshToken: string | null
      language: $Enums.UserLanguage | null
      role: $Enums.UserRole
      clientId: string | null
      agencyId: string | null
      adminId: string | null
      ipAddress: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agency<T extends User$agencyArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    UserFeatureRequest<T extends User$UserFeatureRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$UserFeatureRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyMember<T extends User$agencyMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyMemberArgs<ExtArgs>>): Prisma__AgencyMemberClient<$Result.GetResult<Prisma.$AgencyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedAgency<T extends User$ownedAgencyArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedAgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyInvitationSender<T extends User$agencyInvitationSenderArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyInvitationSenderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'UserLanguage'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly agencyId: FieldRef<"User", 'String'>
    readonly adminId: FieldRef<"User", 'String'>
    readonly ipAddress: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.agency
   */
  export type User$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.UserFeatureRequest
   */
  export type User$UserFeatureRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    where?: UserFeatureRequestWhereInput
    orderBy?: UserFeatureRequestOrderByWithRelationInput | UserFeatureRequestOrderByWithRelationInput[]
    cursor?: UserFeatureRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeatureRequestScalarFieldEnum | UserFeatureRequestScalarFieldEnum[]
  }

  /**
   * User.agencyMember
   */
  export type User$agencyMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyMember
     */
    select?: AgencyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyMember
     */
    omit?: AgencyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyMemberInclude<ExtArgs> | null
    where?: AgencyMemberWhereInput
  }

  /**
   * User.ownedAgency
   */
  export type User$ownedAgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.agencyInvitationSender
   */
  export type User$agencyInvitationSenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyInvitation
     */
    select?: AgencyInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyInvitation
     */
    omit?: AgencyInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInvitationInclude<ExtArgs> | null
    where?: AgencyInvitationWhereInput
    orderBy?: AgencyInvitationOrderByWithRelationInput | AgencyInvitationOrderByWithRelationInput[]
    cursor?: AgencyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyInvitationScalarFieldEnum | AgencyInvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.NotificationStatus | null
    recipientId: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.NotificationStatus | null
    recipientId: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    recipientId: number
    createdAt: number
    readAt: number
    metadata: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
    metadata?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.NotificationStatus
    recipientId: string
    createdAt: Date
    readAt: Date | null
    metadata: JsonValue | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "recipientId" | "createdAt" | "readAt" | "metadata", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.NotificationStatus
      recipientId: string
      createdAt: Date
      readAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly description: FieldRef<"Notification", 'String'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserFeatureRequest
   */

  export type AggregateUserFeatureRequest = {
    _count: UserFeatureRequestCountAggregateOutputType | null
    _min: UserFeatureRequestMinAggregateOutputType | null
    _max: UserFeatureRequestMaxAggregateOutputType | null
  }

  export type UserFeatureRequestMinAggregateOutputType = {
    id: string | null
    featureName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFeatureRequestMaxAggregateOutputType = {
    id: string | null
    featureName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFeatureRequestCountAggregateOutputType = {
    id: number
    featureName: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFeatureRequestMinAggregateInputType = {
    id?: true
    featureName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFeatureRequestMaxAggregateInputType = {
    id?: true
    featureName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFeatureRequestCountAggregateInputType = {
    id?: true
    featureName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFeatureRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureRequest to aggregate.
     */
    where?: UserFeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureRequests to fetch.
     */
    orderBy?: UserFeatureRequestOrderByWithRelationInput | UserFeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeatureRequests
    **/
    _count?: true | UserFeatureRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeatureRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeatureRequestMaxAggregateInputType
  }

  export type GetUserFeatureRequestAggregateType<T extends UserFeatureRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeatureRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeatureRequest[P]>
      : GetScalarType<T[P], AggregateUserFeatureRequest[P]>
  }




  export type UserFeatureRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureRequestWhereInput
    orderBy?: UserFeatureRequestOrderByWithAggregationInput | UserFeatureRequestOrderByWithAggregationInput[]
    by: UserFeatureRequestScalarFieldEnum[] | UserFeatureRequestScalarFieldEnum
    having?: UserFeatureRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeatureRequestCountAggregateInputType | true
    _min?: UserFeatureRequestMinAggregateInputType
    _max?: UserFeatureRequestMaxAggregateInputType
  }

  export type UserFeatureRequestGroupByOutputType = {
    id: string
    featureName: string
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserFeatureRequestCountAggregateOutputType | null
    _min: UserFeatureRequestMinAggregateOutputType | null
    _max: UserFeatureRequestMaxAggregateOutputType | null
  }

  type GetUserFeatureRequestGroupByPayload<T extends UserFeatureRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeatureRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeatureRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeatureRequestGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeatureRequestGroupByOutputType[P]>
        }
      >
    >


  export type UserFeatureRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureRequest"]>

  export type UserFeatureRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureRequest"]>

  export type UserFeatureRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureRequest"]>

  export type UserFeatureRequestSelectScalar = {
    id?: boolean
    featureName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFeatureRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "featureName" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["userFeatureRequest"]>
  export type UserFeatureRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }
  export type UserFeatureRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }
  export type UserFeatureRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFeatureRequest$userArgs<ExtArgs>
  }

  export type $UserFeatureRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeatureRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureName: string
      userId: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["userFeatureRequest"]>
    composites: {}
  }

  type UserFeatureRequestGetPayload<S extends boolean | null | undefined | UserFeatureRequestDefaultArgs> = $Result.GetResult<Prisma.$UserFeatureRequestPayload, S>

  type UserFeatureRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFeatureRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserFeatureRequestCountAggregateInputType | true
    }

  export interface UserFeatureRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeatureRequest'], meta: { name: 'UserFeatureRequest' } }
    /**
     * Find zero or one UserFeatureRequest that matches the filter.
     * @param {UserFeatureRequestFindUniqueArgs} args - Arguments to find a UserFeatureRequest
     * @example
     * // Get one UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeatureRequestFindUniqueArgs>(args: SelectSubset<T, UserFeatureRequestFindUniqueArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFeatureRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFeatureRequestFindUniqueOrThrowArgs} args - Arguments to find a UserFeatureRequest
     * @example
     * // Get one UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeatureRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeatureRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestFindFirstArgs} args - Arguments to find a UserFeatureRequest
     * @example
     * // Get one UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeatureRequestFindFirstArgs>(args?: SelectSubset<T, UserFeatureRequestFindFirstArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestFindFirstOrThrowArgs} args - Arguments to find a UserFeatureRequest
     * @example
     * // Get one UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeatureRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeatureRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFeatureRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeatureRequests
     * const userFeatureRequests = await prisma.userFeatureRequest.findMany()
     * 
     * // Get first 10 UserFeatureRequests
     * const userFeatureRequests = await prisma.userFeatureRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeatureRequestWithIdOnly = await prisma.userFeatureRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeatureRequestFindManyArgs>(args?: SelectSubset<T, UserFeatureRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFeatureRequest.
     * @param {UserFeatureRequestCreateArgs} args - Arguments to create a UserFeatureRequest.
     * @example
     * // Create one UserFeatureRequest
     * const UserFeatureRequest = await prisma.userFeatureRequest.create({
     *   data: {
     *     // ... data to create a UserFeatureRequest
     *   }
     * })
     * 
     */
    create<T extends UserFeatureRequestCreateArgs>(args: SelectSubset<T, UserFeatureRequestCreateArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFeatureRequests.
     * @param {UserFeatureRequestCreateManyArgs} args - Arguments to create many UserFeatureRequests.
     * @example
     * // Create many UserFeatureRequests
     * const userFeatureRequest = await prisma.userFeatureRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeatureRequestCreateManyArgs>(args?: SelectSubset<T, UserFeatureRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeatureRequests and returns the data saved in the database.
     * @param {UserFeatureRequestCreateManyAndReturnArgs} args - Arguments to create many UserFeatureRequests.
     * @example
     * // Create many UserFeatureRequests
     * const userFeatureRequest = await prisma.userFeatureRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeatureRequests and only return the `id`
     * const userFeatureRequestWithIdOnly = await prisma.userFeatureRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeatureRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeatureRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFeatureRequest.
     * @param {UserFeatureRequestDeleteArgs} args - Arguments to delete one UserFeatureRequest.
     * @example
     * // Delete one UserFeatureRequest
     * const UserFeatureRequest = await prisma.userFeatureRequest.delete({
     *   where: {
     *     // ... filter to delete one UserFeatureRequest
     *   }
     * })
     * 
     */
    delete<T extends UserFeatureRequestDeleteArgs>(args: SelectSubset<T, UserFeatureRequestDeleteArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFeatureRequest.
     * @param {UserFeatureRequestUpdateArgs} args - Arguments to update one UserFeatureRequest.
     * @example
     * // Update one UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeatureRequestUpdateArgs>(args: SelectSubset<T, UserFeatureRequestUpdateArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFeatureRequests.
     * @param {UserFeatureRequestDeleteManyArgs} args - Arguments to filter UserFeatureRequests to delete.
     * @example
     * // Delete a few UserFeatureRequests
     * const { count } = await prisma.userFeatureRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeatureRequestDeleteManyArgs>(args?: SelectSubset<T, UserFeatureRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeatureRequests
     * const userFeatureRequest = await prisma.userFeatureRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeatureRequestUpdateManyArgs>(args: SelectSubset<T, UserFeatureRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureRequests and returns the data updated in the database.
     * @param {UserFeatureRequestUpdateManyAndReturnArgs} args - Arguments to update many UserFeatureRequests.
     * @example
     * // Update many UserFeatureRequests
     * const userFeatureRequest = await prisma.userFeatureRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFeatureRequests and only return the `id`
     * const userFeatureRequestWithIdOnly = await prisma.userFeatureRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFeatureRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFeatureRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFeatureRequest.
     * @param {UserFeatureRequestUpsertArgs} args - Arguments to update or create a UserFeatureRequest.
     * @example
     * // Update or create a UserFeatureRequest
     * const userFeatureRequest = await prisma.userFeatureRequest.upsert({
     *   create: {
     *     // ... data to create a UserFeatureRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeatureRequest we want to update
     *   }
     * })
     */
    upsert<T extends UserFeatureRequestUpsertArgs>(args: SelectSubset<T, UserFeatureRequestUpsertArgs<ExtArgs>>): Prisma__UserFeatureRequestClient<$Result.GetResult<Prisma.$UserFeatureRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestCountArgs} args - Arguments to filter UserFeatureRequests to count.
     * @example
     * // Count the number of UserFeatureRequests
     * const count = await prisma.userFeatureRequest.count({
     *   where: {
     *     // ... the filter for the UserFeatureRequests we want to count
     *   }
     * })
    **/
    count<T extends UserFeatureRequestCountArgs>(
      args?: Subset<T, UserFeatureRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeatureRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeatureRequestAggregateArgs>(args: Subset<T, UserFeatureRequestAggregateArgs>): Prisma.PrismaPromise<GetUserFeatureRequestAggregateType<T>>

    /**
     * Group by UserFeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeatureRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeatureRequestGroupByArgs['orderBy'] }
        : { orderBy?: UserFeatureRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeatureRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeatureRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeatureRequest model
   */
  readonly fields: UserFeatureRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeatureRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeatureRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFeatureRequest$userArgs<ExtArgs> = {}>(args?: Subset<T, UserFeatureRequest$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeatureRequest model
   */
  interface UserFeatureRequestFieldRefs {
    readonly id: FieldRef<"UserFeatureRequest", 'String'>
    readonly featureName: FieldRef<"UserFeatureRequest", 'String'>
    readonly userId: FieldRef<"UserFeatureRequest", 'String'>
    readonly createdAt: FieldRef<"UserFeatureRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFeatureRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeatureRequest findUnique
   */
  export type UserFeatureRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureRequest to fetch.
     */
    where: UserFeatureRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest findUniqueOrThrow
   */
  export type UserFeatureRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureRequest to fetch.
     */
    where: UserFeatureRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest findFirst
   */
  export type UserFeatureRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureRequest to fetch.
     */
    where?: UserFeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureRequests to fetch.
     */
    orderBy?: UserFeatureRequestOrderByWithRelationInput | UserFeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureRequests.
     */
    cursor?: UserFeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureRequests.
     */
    distinct?: UserFeatureRequestScalarFieldEnum | UserFeatureRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest findFirstOrThrow
   */
  export type UserFeatureRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureRequest to fetch.
     */
    where?: UserFeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureRequests to fetch.
     */
    orderBy?: UserFeatureRequestOrderByWithRelationInput | UserFeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureRequests.
     */
    cursor?: UserFeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureRequests.
     */
    distinct?: UserFeatureRequestScalarFieldEnum | UserFeatureRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest findMany
   */
  export type UserFeatureRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureRequests to fetch.
     */
    where?: UserFeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureRequests to fetch.
     */
    orderBy?: UserFeatureRequestOrderByWithRelationInput | UserFeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeatureRequests.
     */
    cursor?: UserFeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureRequests.
     */
    skip?: number
    distinct?: UserFeatureRequestScalarFieldEnum | UserFeatureRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest create
   */
  export type UserFeatureRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeatureRequest.
     */
    data: XOR<UserFeatureRequestCreateInput, UserFeatureRequestUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest createMany
   */
  export type UserFeatureRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeatureRequests.
     */
    data: UserFeatureRequestCreateManyInput | UserFeatureRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeatureRequest createManyAndReturn
   */
  export type UserFeatureRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * The data used to create many UserFeatureRequests.
     */
    data: UserFeatureRequestCreateManyInput | UserFeatureRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureRequest update
   */
  export type UserFeatureRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeatureRequest.
     */
    data: XOR<UserFeatureRequestUpdateInput, UserFeatureRequestUncheckedUpdateInput>
    /**
     * Choose, which UserFeatureRequest to update.
     */
    where: UserFeatureRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest updateMany
   */
  export type UserFeatureRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeatureRequests.
     */
    data: XOR<UserFeatureRequestUpdateManyMutationInput, UserFeatureRequestUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureRequests to update
     */
    where?: UserFeatureRequestWhereInput
    /**
     * Limit how many UserFeatureRequests to update.
     */
    limit?: number
  }

  /**
   * UserFeatureRequest updateManyAndReturn
   */
  export type UserFeatureRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * The data used to update UserFeatureRequests.
     */
    data: XOR<UserFeatureRequestUpdateManyMutationInput, UserFeatureRequestUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureRequests to update
     */
    where?: UserFeatureRequestWhereInput
    /**
     * Limit how many UserFeatureRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureRequest upsert
   */
  export type UserFeatureRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeatureRequest to update in case it exists.
     */
    where: UserFeatureRequestWhereUniqueInput
    /**
     * In case the UserFeatureRequest found by the `where` argument doesn't exist, create a new UserFeatureRequest with this data.
     */
    create: XOR<UserFeatureRequestCreateInput, UserFeatureRequestUncheckedCreateInput>
    /**
     * In case the UserFeatureRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeatureRequestUpdateInput, UserFeatureRequestUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest delete
   */
  export type UserFeatureRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
    /**
     * Filter which UserFeatureRequest to delete.
     */
    where: UserFeatureRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeatureRequest deleteMany
   */
  export type UserFeatureRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureRequests to delete
     */
    where?: UserFeatureRequestWhereInput
    /**
     * Limit how many UserFeatureRequests to delete.
     */
    limit?: number
  }

  /**
   * UserFeatureRequest.user
   */
  export type UserFeatureRequest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserFeatureRequest without action
   */
  export type UserFeatureRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureRequest
     */
    select?: UserFeatureRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureRequest
     */
    omit?: UserFeatureRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureRequestInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    userId: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    userId: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    userId: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    userId?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    userId?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    userId?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    userId: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "userId" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      userId: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    status: 'status',
    imotkoApproved: 'imotkoApproved',
    plan: 'plan',
    planUntil: 'planUntil',
    email: 'email',
    taxNumber: 'taxNumber',
    name: 'name',
    description: 'description',
    slug: 'slug',
    address: 'address',
    phone: 'phone',
    location: 'location',
    social: 'social',
    logo: 'logo',
    credits: 'credits',
    owner: 'owner',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const AgencyClientNotesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    agencyClientId: 'agencyClientId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyClientNotesScalarFieldEnum = (typeof AgencyClientNotesScalarFieldEnum)[keyof typeof AgencyClientNotesScalarFieldEnum]


  export const AgencyClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    status: 'status',
    location: 'location',
    agencyId: 'agencyId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyClientScalarFieldEnum = (typeof AgencyClientScalarFieldEnum)[keyof typeof AgencyClientScalarFieldEnum]


  export const AgencyClientPreferenceScalarFieldEnum: {
    id: 'id',
    propertyType: 'propertyType',
    listingType: 'listingType',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    minSize: 'minSize',
    maxSize: 'maxSize',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    locationId: 'locationId',
    location: 'location',
    createdById: 'createdById',
    agencyClientId: 'agencyClientId',
    offeredPropertyIds: 'offeredPropertyIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    lastOfferSentAt: 'lastOfferSentAt'
  };

  export type AgencyClientPreferenceScalarFieldEnum = (typeof AgencyClientPreferenceScalarFieldEnum)[keyof typeof AgencyClientPreferenceScalarFieldEnum]


  export const AgencyMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agencyId: 'agencyId',
    status: 'status',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyMemberScalarFieldEnum = (typeof AgencyMemberScalarFieldEnum)[keyof typeof AgencyMemberScalarFieldEnum]


  export const AgencyInvitationScalarFieldEnum: {
    id: 'id',
    token: 'token',
    agencyId: 'agencyId',
    email: 'email',
    senderId: 'senderId',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyInvitationScalarFieldEnum = (typeof AgencyInvitationScalarFieldEnum)[keyof typeof AgencyInvitationScalarFieldEnum]


  export const AgencySubmissionReviewScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencySubmissionReviewScalarFieldEnum = (typeof AgencySubmissionReviewScalarFieldEnum)[keyof typeof AgencySubmissionReviewScalarFieldEnum]


  export const AgencyViewScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    clientId: 'clientId',
    additionalInfo: 'additionalInfo',
    viewDate: 'viewDate',
    updatedAt: 'updatedAt'
  };

  export type AgencyViewScalarFieldEnum = (typeof AgencyViewScalarFieldEnum)[keyof typeof AgencyViewScalarFieldEnum]


  export const AgencyReviewScalarFieldEnum: {
    id: 'id',
    approved: 'approved',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    attributes: 'attributes',
    agencyId: 'agencyId',
    clientId: 'clientId'
  };

  export type AgencyReviewScalarFieldEnum = (typeof AgencyReviewScalarFieldEnum)[keyof typeof AgencyReviewScalarFieldEnum]


  export const AgentReminderScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    agencyMemberId: 'agencyMemberId',
    startDate: 'startDate',
    isRecurring: 'isRecurring',
    endDate: 'endDate',
    lastSentAt: 'lastSentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentReminderScalarFieldEnum = (typeof AgentReminderScalarFieldEnum)[keyof typeof AgentReminderScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    receiveCompanyEmail: 'receiveCompanyEmail',
    receiveCompanySMS: 'receiveCompanySMS',
    receiveAgentEmail: 'receiveAgentEmail',
    receiveAgentSMS: 'receiveAgentSMS',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    preferences: 'preferences'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientSearchScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    title: 'title',
    link: 'link',
    filters: 'filters',
    receiveOffers: 'receiveOffers',
    agencyIdsJson: 'agencyIdsJson'
  };

  export type ClientSearchScalarFieldEnum = (typeof ClientSearchScalarFieldEnum)[keyof typeof ClientSearchScalarFieldEnum]


  export const ClientPropertySubscriptionScalarFieldEnum: {
    id: 'id',
    minSize: 'minSize',
    maxSize: 'maxSize',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    location: 'location',
    listingType: 'listingType',
    category: 'category',
    subCategory: 'subCategory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    clientSearchId: 'clientSearchId'
  };

  export type ClientPropertySubscriptionScalarFieldEnum = (typeof ClientPropertySubscriptionScalarFieldEnum)[keyof typeof ClientPropertySubscriptionScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    location: 'location',
    listingType: 'listingType',
    category: 'category',
    subCategory: 'subCategory',
    priceFrom: 'priceFrom',
    priceTo: 'priceTo',
    sizeFrom: 'sizeFrom',
    sizeTo: 'sizeTo',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const ExternalListingScalarFieldEnum: {
    id: 'id',
    category: 'category',
    fullName: 'fullName',
    type: 'type',
    title: 'title',
    description: 'description',
    price: 'price',
    attributes: 'attributes',
    location: 'location',
    phoneNumber: 'phoneNumber',
    email: 'email',
    sourceId: 'sourceId',
    sourceName: 'sourceName',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalListingScalarFieldEnum = (typeof ExternalListingScalarFieldEnum)[keyof typeof ExternalListingScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    latitude: 'latitude',
    address: 'address',
    longitude: 'longitude',
    agencyId: 'agencyId',
    status: 'status',
    price: 'price',
    hasApproximatePrice: 'hasApproximatePrice',
    approximatePrice: 'approximatePrice',
    estimationPrice: 'estimationPrice',
    size: 'size',
    description: 'description',
    slug: 'slug',
    photos: 'photos',
    video: 'video',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    createdByMemberId: 'createdByMemberId',
    updatedAt: 'updatedAt',
    attributes: 'attributes',
    yearBuilt: 'yearBuilt',
    remarks: 'remarks',
    builder: 'builder',
    propertyCadastralMunicipality: 'propertyCadastralMunicipality',
    propertyDeed: 'propertyDeed',
    inDevelopment: 'inDevelopment',
    inDevelopmentUntil: 'inDevelopmentUntil',
    propertyPlan: 'propertyPlan',
    poi: 'poi',
    featured: 'featured',
    featuredUntil: 'featuredUntil',
    orientation: 'orientation',
    type: 'type',
    listingType: 'listingType',
    propertyLocationId: 'propertyLocationId',
    modifications: 'modifications',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    ownerId: 'ownerId',
    renterId: 'renterId',
    externalId: 'externalId',
    autoRenewEnabled: 'autoRenewEnabled',
    autoRenewStartDate: 'autoRenewStartDate',
    autoRenewEndDate: 'autoRenewEndDate',
    lastAutoRenewedAt: 'lastAutoRenewedAt',
    bumpedAt: 'bumpedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PropertyCategoryScalarFieldEnum: {
    id: 'id',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyCategoryScalarFieldEnum = (typeof PropertyCategoryScalarFieldEnum)[keyof typeof PropertyCategoryScalarFieldEnum]


  export const PropertySubcategoryScalarFieldEnum: {
    id: 'id',
    value: 'value',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertySubcategoryScalarFieldEnum = (typeof PropertySubcategoryScalarFieldEnum)[keyof typeof PropertySubcategoryScalarFieldEnum]


  export const PropertyLocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId'
  };

  export type PropertyLocationScalarFieldEnum = (typeof PropertyLocationScalarFieldEnum)[keyof typeof PropertyLocationScalarFieldEnum]


  export const PropertySubmissionReviewScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertySubmissionReviewScalarFieldEnum = (typeof PropertySubmissionReviewScalarFieldEnum)[keyof typeof PropertySubmissionReviewScalarFieldEnum]


  export const PropertySaleScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    agencyId: 'agencyId',
    propertyDeed: 'propertyDeed',
    soldAt: 'soldAt',
    soldFor: 'soldFor',
    visibility: 'visibility'
  };

  export type PropertySaleScalarFieldEnum = (typeof PropertySaleScalarFieldEnum)[keyof typeof PropertySaleScalarFieldEnum]


  export const PropertyViewScalarFieldEnum: {
    id: 'id',
    viewDate: 'viewDate',
    propertyId: 'propertyId',
    clientId: 'clientId',
    additionalInfo: 'additionalInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyViewScalarFieldEnum = (typeof PropertyViewScalarFieldEnum)[keyof typeof PropertyViewScalarFieldEnum]


  export const PropertyFavoriteScalarFieldEnum: {
    id: 'id',
    favoriteDate: 'favoriteDate',
    propertyId: 'propertyId',
    clientId: 'clientId'
  };

  export type PropertyFavoriteScalarFieldEnum = (typeof PropertyFavoriteScalarFieldEnum)[keyof typeof PropertyFavoriteScalarFieldEnum]


  export const PropertyEngagementScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    type: 'type',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    additionalInfo: 'additionalInfo'
  };

  export type PropertyEngagementScalarFieldEnum = (typeof PropertyEngagementScalarFieldEnum)[keyof typeof PropertyEngagementScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    size: 'size',
    category: 'category',
    listingType: 'listingType',
    status: 'status',
    photos: 'photos',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ProposalOfferScalarFieldEnum: {
    id: 'id',
    title: 'title',
    price: 'price',
    description: 'description',
    saleTimeline: 'saleTimeline',
    proposalId: 'proposalId',
    agencyId: 'agencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalOfferScalarFieldEnum = (typeof ProposalOfferScalarFieldEnum)[keyof typeof ProposalOfferScalarFieldEnum]


  export const ProposalCollaborationScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    title: 'title',
    description: 'description',
    email: 'email',
    phone: 'phone',
    agencyId: 'agencyId',
    proposalOfferId: 'proposalOfferId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalCollaborationScalarFieldEnum = (typeof ProposalCollaborationScalarFieldEnum)[keyof typeof ProposalCollaborationScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastName: 'lastName',
    email: 'email',
    location: 'location',
    emailVerified: 'emailVerified',
    image: 'image',
    hashedPassword: 'hashedPassword',
    phone: 'phone',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    language: 'language',
    role: 'role',
    clientId: 'clientId',
    agencyId: 'agencyId',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    recipientId: 'recipientId',
    createdAt: 'createdAt',
    readAt: 'readAt',
    metadata: 'metadata'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserFeatureRequestScalarFieldEnum: {
    id: 'id',
    featureName: 'featureName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFeatureRequestScalarFieldEnum = (typeof UserFeatureRequestScalarFieldEnum)[keyof typeof UserFeatureRequestScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    userId: 'userId',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AgencyOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    taxNumber: 'taxNumber',
    name: 'name',
    slug: 'slug',
    address: 'address',
    phone: 'phone',
    location: 'location',
    owner: 'owner',
    ownerId: 'ownerId'
  };

  export type AgencyOrderByRelevanceFieldEnum = (typeof AgencyOrderByRelevanceFieldEnum)[keyof typeof AgencyOrderByRelevanceFieldEnum]


  export const AgencyClientNotesOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    agencyClientId: 'agencyClientId',
    createdById: 'createdById'
  };

  export type AgencyClientNotesOrderByRelevanceFieldEnum = (typeof AgencyClientNotesOrderByRelevanceFieldEnum)[keyof typeof AgencyClientNotesOrderByRelevanceFieldEnum]


  export const AgencyClientOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    location: 'location',
    agencyId: 'agencyId',
    createdById: 'createdById'
  };

  export type AgencyClientOrderByRelevanceFieldEnum = (typeof AgencyClientOrderByRelevanceFieldEnum)[keyof typeof AgencyClientOrderByRelevanceFieldEnum]


  export const AgencyClientPreferenceOrderByRelevanceFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    locationId: 'locationId',
    location: 'location',
    createdById: 'createdById',
    agencyClientId: 'agencyClientId',
    offeredPropertyIds: 'offeredPropertyIds'
  };

  export type AgencyClientPreferenceOrderByRelevanceFieldEnum = (typeof AgencyClientPreferenceOrderByRelevanceFieldEnum)[keyof typeof AgencyClientPreferenceOrderByRelevanceFieldEnum]


  export const AgencyMemberOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    agencyId: 'agencyId'
  };

  export type AgencyMemberOrderByRelevanceFieldEnum = (typeof AgencyMemberOrderByRelevanceFieldEnum)[keyof typeof AgencyMemberOrderByRelevanceFieldEnum]


  export const AgencyInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    agencyId: 'agencyId',
    email: 'email',
    senderId: 'senderId'
  };

  export type AgencyInvitationOrderByRelevanceFieldEnum = (typeof AgencyInvitationOrderByRelevanceFieldEnum)[keyof typeof AgencyInvitationOrderByRelevanceFieldEnum]


  export const AgencySubmissionReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    agencyId: 'agencyId'
  };

  export type AgencySubmissionReviewOrderByRelevanceFieldEnum = (typeof AgencySubmissionReviewOrderByRelevanceFieldEnum)[keyof typeof AgencySubmissionReviewOrderByRelevanceFieldEnum]


  export const AgencyViewOrderByRelevanceFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    clientId: 'clientId'
  };

  export type AgencyViewOrderByRelevanceFieldEnum = (typeof AgencyViewOrderByRelevanceFieldEnum)[keyof typeof AgencyViewOrderByRelevanceFieldEnum]


  export const AgencyReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    comment: 'comment',
    agencyId: 'agencyId',
    clientId: 'clientId'
  };

  export type AgencyReviewOrderByRelevanceFieldEnum = (typeof AgencyReviewOrderByRelevanceFieldEnum)[keyof typeof AgencyReviewOrderByRelevanceFieldEnum]


  export const AgentReminderOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    agencyMemberId: 'agencyMemberId'
  };

  export type AgentReminderOrderByRelevanceFieldEnum = (typeof AgentReminderOrderByRelevanceFieldEnum)[keyof typeof AgentReminderOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const ClientSearchOrderByRelevanceFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    link: 'link'
  };

  export type ClientSearchOrderByRelevanceFieldEnum = (typeof ClientSearchOrderByRelevanceFieldEnum)[keyof typeof ClientSearchOrderByRelevanceFieldEnum]


  export const ClientPropertySubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    location: 'location',
    category: 'category',
    subCategory: 'subCategory',
    clientId: 'clientId',
    clientSearchId: 'clientSearchId'
  };

  export type ClientPropertySubscriptionOrderByRelevanceFieldEnum = (typeof ClientPropertySubscriptionOrderByRelevanceFieldEnum)[keyof typeof ClientPropertySubscriptionOrderByRelevanceFieldEnum]


  export const SearchQueryOrderByRelevanceFieldEnum: {
    id: 'id',
    location: 'location',
    category: 'category',
    subCategory: 'subCategory',
    clientId: 'clientId'
  };

  export type SearchQueryOrderByRelevanceFieldEnum = (typeof SearchQueryOrderByRelevanceFieldEnum)[keyof typeof SearchQueryOrderByRelevanceFieldEnum]


  export const ExternalListingOrderByRelevanceFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    type: 'type',
    title: 'title',
    description: 'description',
    price: 'price',
    attributes: 'attributes',
    location: 'location',
    phoneNumber: 'phoneNumber',
    email: 'email',
    sourceId: 'sourceId',
    sourceName: 'sourceName',
    url: 'url'
  };

  export type ExternalListingOrderByRelevanceFieldEnum = (typeof ExternalListingOrderByRelevanceFieldEnum)[keyof typeof ExternalListingOrderByRelevanceFieldEnum]


  export const PropertyOrderByRelevanceFieldEnum: {
    id: 'id',
    address: 'address',
    agencyId: 'agencyId',
    slug: 'slug',
    video: 'video',
    createdBy: 'createdBy',
    createdByMemberId: 'createdByMemberId',
    remarks: 'remarks',
    builder: 'builder',
    propertyCadastralMunicipality: 'propertyCadastralMunicipality',
    propertyDeed: 'propertyDeed',
    propertyLocationId: 'propertyLocationId',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    ownerId: 'ownerId',
    renterId: 'renterId',
    externalId: 'externalId'
  };

  export type PropertyOrderByRelevanceFieldEnum = (typeof PropertyOrderByRelevanceFieldEnum)[keyof typeof PropertyOrderByRelevanceFieldEnum]


  export const PropertyCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type PropertyCategoryOrderByRelevanceFieldEnum = (typeof PropertyCategoryOrderByRelevanceFieldEnum)[keyof typeof PropertyCategoryOrderByRelevanceFieldEnum]


  export const PropertySubcategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    value: 'value',
    categoryId: 'categoryId'
  };

  export type PropertySubcategoryOrderByRelevanceFieldEnum = (typeof PropertySubcategoryOrderByRelevanceFieldEnum)[keyof typeof PropertySubcategoryOrderByRelevanceFieldEnum]


  export const PropertyLocationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId'
  };

  export type PropertyLocationOrderByRelevanceFieldEnum = (typeof PropertyLocationOrderByRelevanceFieldEnum)[keyof typeof PropertyLocationOrderByRelevanceFieldEnum]


  export const PropertySubmissionReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    propertyId: 'propertyId'
  };

  export type PropertySubmissionReviewOrderByRelevanceFieldEnum = (typeof PropertySubmissionReviewOrderByRelevanceFieldEnum)[keyof typeof PropertySubmissionReviewOrderByRelevanceFieldEnum]


  export const PropertySaleOrderByRelevanceFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    agencyId: 'agencyId',
    propertyDeed: 'propertyDeed'
  };

  export type PropertySaleOrderByRelevanceFieldEnum = (typeof PropertySaleOrderByRelevanceFieldEnum)[keyof typeof PropertySaleOrderByRelevanceFieldEnum]


  export const PropertyViewOrderByRelevanceFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    clientId: 'clientId'
  };

  export type PropertyViewOrderByRelevanceFieldEnum = (typeof PropertyViewOrderByRelevanceFieldEnum)[keyof typeof PropertyViewOrderByRelevanceFieldEnum]


  export const PropertyFavoriteOrderByRelevanceFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    clientId: 'clientId'
  };

  export type PropertyFavoriteOrderByRelevanceFieldEnum = (typeof PropertyFavoriteOrderByRelevanceFieldEnum)[keyof typeof PropertyFavoriteOrderByRelevanceFieldEnum]


  export const PropertyEngagementOrderByRelevanceFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    clientId: 'clientId'
  };

  export type PropertyEngagementOrderByRelevanceFieldEnum = (typeof PropertyEngagementOrderByRelevanceFieldEnum)[keyof typeof PropertyEngagementOrderByRelevanceFieldEnum]


  export const ProposalOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    clientId: 'clientId'
  };

  export type ProposalOrderByRelevanceFieldEnum = (typeof ProposalOrderByRelevanceFieldEnum)[keyof typeof ProposalOrderByRelevanceFieldEnum]


  export const ProposalOfferOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    proposalId: 'proposalId',
    agencyId: 'agencyId'
  };

  export type ProposalOfferOrderByRelevanceFieldEnum = (typeof ProposalOfferOrderByRelevanceFieldEnum)[keyof typeof ProposalOfferOrderByRelevanceFieldEnum]


  export const ProposalCollaborationOrderByRelevanceFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    title: 'title',
    description: 'description',
    email: 'email',
    phone: 'phone',
    agencyId: 'agencyId',
    proposalOfferId: 'proposalOfferId'
  };

  export type ProposalCollaborationOrderByRelevanceFieldEnum = (typeof ProposalCollaborationOrderByRelevanceFieldEnum)[keyof typeof ProposalCollaborationOrderByRelevanceFieldEnum]


  export const AdminOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    lastName: 'lastName',
    email: 'email',
    location: 'location',
    image: 'image',
    hashedPassword: 'hashedPassword',
    phone: 'phone',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    clientId: 'clientId',
    agencyId: 'agencyId',
    adminId: 'adminId',
    ipAddress: 'ipAddress'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    recipientId: 'recipientId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const UserFeatureRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    featureName: 'featureName',
    userId: 'userId'
  };

  export type UserFeatureRequestOrderByRelevanceFieldEnum = (typeof UserFeatureRequestOrderByRelevanceFieldEnum)[keyof typeof UserFeatureRequestOrderByRelevanceFieldEnum]


  export const PasswordResetTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    userId: 'userId',
    token: 'token'
  };

  export type PasswordResetTokenOrderByRelevanceFieldEnum = (typeof PasswordResetTokenOrderByRelevanceFieldEnum)[keyof typeof PasswordResetTokenOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AgencyApprovalStatus'
   */
  export type EnumAgencyApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyApprovalStatus'>
    


  /**
   * Reference to a field of type 'AgencyApprovalStatus[]'
   */
  export type ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AgencyPlan'
   */
  export type EnumAgencyPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyPlan'>
    


  /**
   * Reference to a field of type 'AgencyPlan[]'
   */
  export type ListEnumAgencyPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyPlan[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AgencyClientStatus'
   */
  export type EnumAgencyClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyClientStatus'>
    


  /**
   * Reference to a field of type 'AgencyClientStatus[]'
   */
  export type ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyClientStatus[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'PropertyListingType'
   */
  export type EnumPropertyListingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyListingType'>
    


  /**
   * Reference to a field of type 'PropertyListingType[]'
   */
  export type ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyListingType[]'>
    


  /**
   * Reference to a field of type 'AgencyClientPreferenceStatus'
   */
  export type EnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyClientPreferenceStatus'>
    


  /**
   * Reference to a field of type 'AgencyClientPreferenceStatus[]'
   */
  export type ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyClientPreferenceStatus[]'>
    


  /**
   * Reference to a field of type 'AgencyMemberStatus'
   */
  export type EnumAgencyMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyMemberStatus'>
    


  /**
   * Reference to a field of type 'AgencyMemberStatus[]'
   */
  export type ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyMemberStatus[]'>
    


  /**
   * Reference to a field of type 'AgencyMemberRole'
   */
  export type EnumAgencyMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyMemberRole'>
    


  /**
   * Reference to a field of type 'AgencyMemberRole[]'
   */
  export type ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyMemberRole[]'>
    


  /**
   * Reference to a field of type 'AgencyInvitationStatus'
   */
  export type EnumAgencyInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyInvitationStatus'>
    


  /**
   * Reference to a field of type 'AgencyInvitationStatus[]'
   */
  export type ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgencyInvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ReminderStatus'
   */
  export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus'>
    


  /**
   * Reference to a field of type 'ReminderStatus[]'
   */
  export type ListEnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus[]'>
    


  /**
   * Reference to a field of type 'ExternalListingCategory'
   */
  export type EnumExternalListingCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalListingCategory'>
    


  /**
   * Reference to a field of type 'ExternalListingCategory[]'
   */
  export type ListEnumExternalListingCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalListingCategory[]'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'PropertyOrientation'
   */
  export type EnumPropertyOrientationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyOrientation'>
    


  /**
   * Reference to a field of type 'PropertyOrientation[]'
   */
  export type ListEnumPropertyOrientationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyOrientation[]'>
    


  /**
   * Reference to a field of type 'EngagementType'
   */
  export type EnumEngagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementType'>
    


  /**
   * Reference to a field of type 'EngagementType[]'
   */
  export type ListEnumEngagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementType[]'>
    


  /**
   * Reference to a field of type 'ProposalStatus'
   */
  export type EnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus'>
    


  /**
   * Reference to a field of type 'ProposalStatus[]'
   */
  export type ListEnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus[]'>
    


  /**
   * Reference to a field of type 'UserLanguage'
   */
  export type EnumUserLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLanguage'>
    


  /**
   * Reference to a field of type 'UserLanguage[]'
   */
  export type ListEnumUserLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLanguage[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    status?: EnumAgencyApprovalStatusFilter<"Agency"> | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFilter<"Agency"> | boolean
    plan?: EnumAgencyPlanFilter<"Agency"> | $Enums.AgencyPlan
    planUntil?: DateTimeNullableFilter<"Agency"> | Date | string | null
    email?: StringNullableFilter<"Agency"> | string | null
    taxNumber?: StringNullableFilter<"Agency"> | string | null
    name?: StringFilter<"Agency"> | string
    description?: JsonNullableFilter<"Agency">
    slug?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    phone?: StringNullableFilter<"Agency"> | string | null
    location?: StringNullableFilter<"Agency"> | string | null
    social?: JsonNullableFilter<"Agency">
    logo?: JsonNullableFilter<"Agency">
    credits?: IntFilter<"Agency"> | number
    owner?: StringFilter<"Agency"> | string
    ownerId?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    users?: UserListRelationFilter
    ratings?: AgencyReviewListRelationFilter
    properties?: PropertyListRelationFilter
    propertySale?: PropertySaleListRelationFilter
    agencyView?: AgencyViewListRelationFilter
    proposalOffer?: ProposalOfferListRelationFilter
    AgencySubmissionReview?: XOR<AgencySubmissionReviewNullableScalarRelationFilter, AgencySubmissionReviewWhereInput> | null
    agencyOwner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agencyMembers?: AgencyMemberListRelationFilter
    agencyInvitation?: AgencyInvitationListRelationFilter
    agencyClient?: AgencyClientListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    imotkoApproved?: SortOrder
    plan?: SortOrder
    planUntil?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    social?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    credits?: SortOrder
    owner?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    ratings?: AgencyReviewOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    propertySale?: PropertySaleOrderByRelationAggregateInput
    agencyView?: AgencyViewOrderByRelationAggregateInput
    proposalOffer?: ProposalOfferOrderByRelationAggregateInput
    AgencySubmissionReview?: AgencySubmissionReviewOrderByWithRelationInput
    agencyOwner?: UserOrderByWithRelationInput
    agencyMembers?: AgencyMemberOrderByRelationAggregateInput
    agencyInvitation?: AgencyInvitationOrderByRelationAggregateInput
    agencyClient?: AgencyClientOrderByRelationAggregateInput
    _relevance?: AgencyOrderByRelevanceInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    status?: EnumAgencyApprovalStatusFilter<"Agency"> | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFilter<"Agency"> | boolean
    plan?: EnumAgencyPlanFilter<"Agency"> | $Enums.AgencyPlan
    planUntil?: DateTimeNullableFilter<"Agency"> | Date | string | null
    email?: StringNullableFilter<"Agency"> | string | null
    taxNumber?: StringNullableFilter<"Agency"> | string | null
    name?: StringFilter<"Agency"> | string
    description?: JsonNullableFilter<"Agency">
    slug?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    phone?: StringNullableFilter<"Agency"> | string | null
    location?: StringNullableFilter<"Agency"> | string | null
    social?: JsonNullableFilter<"Agency">
    logo?: JsonNullableFilter<"Agency">
    credits?: IntFilter<"Agency"> | number
    owner?: StringFilter<"Agency"> | string
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    users?: UserListRelationFilter
    ratings?: AgencyReviewListRelationFilter
    properties?: PropertyListRelationFilter
    propertySale?: PropertySaleListRelationFilter
    agencyView?: AgencyViewListRelationFilter
    proposalOffer?: ProposalOfferListRelationFilter
    AgencySubmissionReview?: XOR<AgencySubmissionReviewNullableScalarRelationFilter, AgencySubmissionReviewWhereInput> | null
    agencyOwner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agencyMembers?: AgencyMemberListRelationFilter
    agencyInvitation?: AgencyInvitationListRelationFilter
    agencyClient?: AgencyClientListRelationFilter
  }, "id" | "ownerId">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    imotkoApproved?: SortOrder
    plan?: SortOrder
    planUntil?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    social?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    credits?: SortOrder
    owner?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    status?: EnumAgencyApprovalStatusWithAggregatesFilter<"Agency"> | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolWithAggregatesFilter<"Agency"> | boolean
    plan?: EnumAgencyPlanWithAggregatesFilter<"Agency"> | $Enums.AgencyPlan
    planUntil?: DateTimeNullableWithAggregatesFilter<"Agency"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    name?: StringWithAggregatesFilter<"Agency"> | string
    description?: JsonNullableWithAggregatesFilter<"Agency">
    slug?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    address?: StringWithAggregatesFilter<"Agency"> | string
    phone?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    location?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    social?: JsonNullableWithAggregatesFilter<"Agency">
    logo?: JsonNullableWithAggregatesFilter<"Agency">
    credits?: IntWithAggregatesFilter<"Agency"> | number
    owner?: StringWithAggregatesFilter<"Agency"> | string
    ownerId?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AgencyClientNotesWhereInput = {
    AND?: AgencyClientNotesWhereInput | AgencyClientNotesWhereInput[]
    OR?: AgencyClientNotesWhereInput[]
    NOT?: AgencyClientNotesWhereInput | AgencyClientNotesWhereInput[]
    id?: StringFilter<"AgencyClientNotes"> | string
    title?: StringFilter<"AgencyClientNotes"> | string
    description?: StringFilter<"AgencyClientNotes"> | string
    agencyClientId?: StringFilter<"AgencyClientNotes"> | string
    createdById?: StringFilter<"AgencyClientNotes"> | string
    createdAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
    agencyClient?: XOR<AgencyClientScalarRelationFilter, AgencyClientWhereInput>
    createdByMember?: XOR<AgencyMemberScalarRelationFilter, AgencyMemberWhereInput>
  }

  export type AgencyClientNotesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agencyClientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyClient?: AgencyClientOrderByWithRelationInput
    createdByMember?: AgencyMemberOrderByWithRelationInput
    _relevance?: AgencyClientNotesOrderByRelevanceInput
  }

  export type AgencyClientNotesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyClientNotesWhereInput | AgencyClientNotesWhereInput[]
    OR?: AgencyClientNotesWhereInput[]
    NOT?: AgencyClientNotesWhereInput | AgencyClientNotesWhereInput[]
    title?: StringFilter<"AgencyClientNotes"> | string
    description?: StringFilter<"AgencyClientNotes"> | string
    agencyClientId?: StringFilter<"AgencyClientNotes"> | string
    createdById?: StringFilter<"AgencyClientNotes"> | string
    createdAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
    agencyClient?: XOR<AgencyClientScalarRelationFilter, AgencyClientWhereInput>
    createdByMember?: XOR<AgencyMemberScalarRelationFilter, AgencyMemberWhereInput>
  }, "id">

  export type AgencyClientNotesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agencyClientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyClientNotesCountOrderByAggregateInput
    _max?: AgencyClientNotesMaxOrderByAggregateInput
    _min?: AgencyClientNotesMinOrderByAggregateInput
  }

  export type AgencyClientNotesScalarWhereWithAggregatesInput = {
    AND?: AgencyClientNotesScalarWhereWithAggregatesInput | AgencyClientNotesScalarWhereWithAggregatesInput[]
    OR?: AgencyClientNotesScalarWhereWithAggregatesInput[]
    NOT?: AgencyClientNotesScalarWhereWithAggregatesInput | AgencyClientNotesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyClientNotes"> | string
    title?: StringWithAggregatesFilter<"AgencyClientNotes"> | string
    description?: StringWithAggregatesFilter<"AgencyClientNotes"> | string
    agencyClientId?: StringWithAggregatesFilter<"AgencyClientNotes"> | string
    createdById?: StringWithAggregatesFilter<"AgencyClientNotes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgencyClientNotes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyClientNotes"> | Date | string
  }

  export type AgencyClientWhereInput = {
    AND?: AgencyClientWhereInput | AgencyClientWhereInput[]
    OR?: AgencyClientWhereInput[]
    NOT?: AgencyClientWhereInput | AgencyClientWhereInput[]
    id?: StringFilter<"AgencyClient"> | string
    name?: StringFilter<"AgencyClient"> | string
    lastName?: StringNullableFilter<"AgencyClient"> | string | null
    email?: StringNullableFilter<"AgencyClient"> | string | null
    phone?: StringNullableFilter<"AgencyClient"> | string | null
    status?: EnumAgencyClientStatusNullableFilter<"AgencyClient"> | $Enums.AgencyClientStatus | null
    location?: StringNullableFilter<"AgencyClient"> | string | null
    agencyId?: StringFilter<"AgencyClient"> | string
    createdById?: StringNullableFilter<"AgencyClient"> | string | null
    createdAt?: DateTimeFilter<"AgencyClient"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClient"> | Date | string
    memberNotes?: AgencyClientNotesListRelationFilter
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    createdBy?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    preferences?: AgencyClientPreferenceListRelationFilter
    ownedProperties?: PropertyListRelationFilter
    rentedProperties?: PropertyListRelationFilter
  }

  export type AgencyClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberNotes?: AgencyClientNotesOrderByRelationAggregateInput
    agency?: AgencyOrderByWithRelationInput
    createdBy?: AgencyMemberOrderByWithRelationInput
    preferences?: AgencyClientPreferenceOrderByRelationAggregateInput
    ownedProperties?: PropertyOrderByRelationAggregateInput
    rentedProperties?: PropertyOrderByRelationAggregateInput
    _relevance?: AgencyClientOrderByRelevanceInput
  }

  export type AgencyClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyClientWhereInput | AgencyClientWhereInput[]
    OR?: AgencyClientWhereInput[]
    NOT?: AgencyClientWhereInput | AgencyClientWhereInput[]
    name?: StringFilter<"AgencyClient"> | string
    lastName?: StringNullableFilter<"AgencyClient"> | string | null
    email?: StringNullableFilter<"AgencyClient"> | string | null
    phone?: StringNullableFilter<"AgencyClient"> | string | null
    status?: EnumAgencyClientStatusNullableFilter<"AgencyClient"> | $Enums.AgencyClientStatus | null
    location?: StringNullableFilter<"AgencyClient"> | string | null
    agencyId?: StringFilter<"AgencyClient"> | string
    createdById?: StringNullableFilter<"AgencyClient"> | string | null
    createdAt?: DateTimeFilter<"AgencyClient"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClient"> | Date | string
    memberNotes?: AgencyClientNotesListRelationFilter
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    createdBy?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    preferences?: AgencyClientPreferenceListRelationFilter
    ownedProperties?: PropertyListRelationFilter
    rentedProperties?: PropertyListRelationFilter
  }, "id">

  export type AgencyClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyClientCountOrderByAggregateInput
    _max?: AgencyClientMaxOrderByAggregateInput
    _min?: AgencyClientMinOrderByAggregateInput
  }

  export type AgencyClientScalarWhereWithAggregatesInput = {
    AND?: AgencyClientScalarWhereWithAggregatesInput | AgencyClientScalarWhereWithAggregatesInput[]
    OR?: AgencyClientScalarWhereWithAggregatesInput[]
    NOT?: AgencyClientScalarWhereWithAggregatesInput | AgencyClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyClient"> | string
    name?: StringWithAggregatesFilter<"AgencyClient"> | string
    lastName?: StringNullableWithAggregatesFilter<"AgencyClient"> | string | null
    email?: StringNullableWithAggregatesFilter<"AgencyClient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"AgencyClient"> | string | null
    status?: EnumAgencyClientStatusNullableWithAggregatesFilter<"AgencyClient"> | $Enums.AgencyClientStatus | null
    location?: StringNullableWithAggregatesFilter<"AgencyClient"> | string | null
    agencyId?: StringWithAggregatesFilter<"AgencyClient"> | string
    createdById?: StringNullableWithAggregatesFilter<"AgencyClient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgencyClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyClient"> | Date | string
  }

  export type AgencyClientPreferenceWhereInput = {
    AND?: AgencyClientPreferenceWhereInput | AgencyClientPreferenceWhereInput[]
    OR?: AgencyClientPreferenceWhereInput[]
    NOT?: AgencyClientPreferenceWhereInput | AgencyClientPreferenceWhereInput[]
    id?: StringFilter<"AgencyClientPreference"> | string
    propertyType?: EnumPropertyTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyType | null
    listingType?: EnumPropertyListingTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyListingType | null
    minPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    minSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    categoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    subcategoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    locationId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    location?: StringNullableFilter<"AgencyClientPreference"> | string | null
    createdById?: StringNullableFilter<"AgencyClientPreference"> | string | null
    agencyClientId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    offeredPropertyIds?: StringNullableListFilter<"AgencyClientPreference">
    createdAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    status?: EnumAgencyClientPreferenceStatusFilter<"AgencyClientPreference"> | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: DateTimeNullableFilter<"AgencyClientPreference"> | Date | string | null
    createdBy?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    agencyClient?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
  }

  export type AgencyClientPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    propertyType?: SortOrderInput | SortOrder
    listingType?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minSize?: SortOrderInput | SortOrder
    maxSize?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    agencyClientId?: SortOrderInput | SortOrder
    offeredPropertyIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastOfferSentAt?: SortOrderInput | SortOrder
    createdBy?: AgencyMemberOrderByWithRelationInput
    agencyClient?: AgencyClientOrderByWithRelationInput
    _relevance?: AgencyClientPreferenceOrderByRelevanceInput
  }

  export type AgencyClientPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyClientPreferenceWhereInput | AgencyClientPreferenceWhereInput[]
    OR?: AgencyClientPreferenceWhereInput[]
    NOT?: AgencyClientPreferenceWhereInput | AgencyClientPreferenceWhereInput[]
    propertyType?: EnumPropertyTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyType | null
    listingType?: EnumPropertyListingTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyListingType | null
    minPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    minSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    categoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    subcategoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    locationId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    location?: StringNullableFilter<"AgencyClientPreference"> | string | null
    createdById?: StringNullableFilter<"AgencyClientPreference"> | string | null
    agencyClientId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    offeredPropertyIds?: StringNullableListFilter<"AgencyClientPreference">
    createdAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    status?: EnumAgencyClientPreferenceStatusFilter<"AgencyClientPreference"> | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: DateTimeNullableFilter<"AgencyClientPreference"> | Date | string | null
    createdBy?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    agencyClient?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
  }, "id">

  export type AgencyClientPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    propertyType?: SortOrderInput | SortOrder
    listingType?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minSize?: SortOrderInput | SortOrder
    maxSize?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    agencyClientId?: SortOrderInput | SortOrder
    offeredPropertyIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastOfferSentAt?: SortOrderInput | SortOrder
    _count?: AgencyClientPreferenceCountOrderByAggregateInput
    _avg?: AgencyClientPreferenceAvgOrderByAggregateInput
    _max?: AgencyClientPreferenceMaxOrderByAggregateInput
    _min?: AgencyClientPreferenceMinOrderByAggregateInput
    _sum?: AgencyClientPreferenceSumOrderByAggregateInput
  }

  export type AgencyClientPreferenceScalarWhereWithAggregatesInput = {
    AND?: AgencyClientPreferenceScalarWhereWithAggregatesInput | AgencyClientPreferenceScalarWhereWithAggregatesInput[]
    OR?: AgencyClientPreferenceScalarWhereWithAggregatesInput[]
    NOT?: AgencyClientPreferenceScalarWhereWithAggregatesInput | AgencyClientPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyClientPreference"> | string
    propertyType?: EnumPropertyTypeNullableWithAggregatesFilter<"AgencyClientPreference"> | $Enums.PropertyType | null
    listingType?: EnumPropertyListingTypeNullableWithAggregatesFilter<"AgencyClientPreference"> | $Enums.PropertyListingType | null
    minPrice?: IntNullableWithAggregatesFilter<"AgencyClientPreference"> | number | null
    maxPrice?: IntNullableWithAggregatesFilter<"AgencyClientPreference"> | number | null
    minSize?: IntNullableWithAggregatesFilter<"AgencyClientPreference"> | number | null
    maxSize?: IntNullableWithAggregatesFilter<"AgencyClientPreference"> | number | null
    categoryId?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    subcategoryId?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    location?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    agencyClientId?: StringNullableWithAggregatesFilter<"AgencyClientPreference"> | string | null
    offeredPropertyIds?: StringNullableListFilter<"AgencyClientPreference">
    createdAt?: DateTimeWithAggregatesFilter<"AgencyClientPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyClientPreference"> | Date | string
    status?: EnumAgencyClientPreferenceStatusWithAggregatesFilter<"AgencyClientPreference"> | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: DateTimeNullableWithAggregatesFilter<"AgencyClientPreference"> | Date | string | null
  }

  export type AgencyMemberWhereInput = {
    AND?: AgencyMemberWhereInput | AgencyMemberWhereInput[]
    OR?: AgencyMemberWhereInput[]
    NOT?: AgencyMemberWhereInput | AgencyMemberWhereInput[]
    id?: StringFilter<"AgencyMember"> | string
    userId?: StringFilter<"AgencyMember"> | string
    agencyId?: StringNullableFilter<"AgencyMember"> | string | null
    status?: EnumAgencyMemberStatusNullableFilter<"AgencyMember"> | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFilter<"AgencyMember"> | $Enums.AgencyMemberRole
    createdAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    createdProperties?: PropertyListRelationFilter
    agencyClientNotes?: AgencyClientNotesListRelationFilter
    agencyClient?: AgencyClientListRelationFilter
    AgencyClientPreference?: AgencyClientPreferenceListRelationFilter
    reminders?: AgentReminderListRelationFilter
  }

  export type AgencyMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    createdProperties?: PropertyOrderByRelationAggregateInput
    agencyClientNotes?: AgencyClientNotesOrderByRelationAggregateInput
    agencyClient?: AgencyClientOrderByRelationAggregateInput
    AgencyClientPreference?: AgencyClientPreferenceOrderByRelationAggregateInput
    reminders?: AgentReminderOrderByRelationAggregateInput
    _relevance?: AgencyMemberOrderByRelevanceInput
  }

  export type AgencyMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AgencyMemberWhereInput | AgencyMemberWhereInput[]
    OR?: AgencyMemberWhereInput[]
    NOT?: AgencyMemberWhereInput | AgencyMemberWhereInput[]
    agencyId?: StringNullableFilter<"AgencyMember"> | string | null
    status?: EnumAgencyMemberStatusNullableFilter<"AgencyMember"> | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFilter<"AgencyMember"> | $Enums.AgencyMemberRole
    createdAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    createdProperties?: PropertyListRelationFilter
    agencyClientNotes?: AgencyClientNotesListRelationFilter
    agencyClient?: AgencyClientListRelationFilter
    AgencyClientPreference?: AgencyClientPreferenceListRelationFilter
    reminders?: AgentReminderListRelationFilter
  }, "id" | "userId">

  export type AgencyMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AgencyMemberCountOrderByAggregateInput
    _max?: AgencyMemberMaxOrderByAggregateInput
    _min?: AgencyMemberMinOrderByAggregateInput
  }

  export type AgencyMemberScalarWhereWithAggregatesInput = {
    AND?: AgencyMemberScalarWhereWithAggregatesInput | AgencyMemberScalarWhereWithAggregatesInput[]
    OR?: AgencyMemberScalarWhereWithAggregatesInput[]
    NOT?: AgencyMemberScalarWhereWithAggregatesInput | AgencyMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyMember"> | string
    userId?: StringWithAggregatesFilter<"AgencyMember"> | string
    agencyId?: StringNullableWithAggregatesFilter<"AgencyMember"> | string | null
    status?: EnumAgencyMemberStatusNullableWithAggregatesFilter<"AgencyMember"> | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleWithAggregatesFilter<"AgencyMember"> | $Enums.AgencyMemberRole
    createdAt?: DateTimeNullableWithAggregatesFilter<"AgencyMember"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AgencyMember"> | Date | string | null
  }

  export type AgencyInvitationWhereInput = {
    AND?: AgencyInvitationWhereInput | AgencyInvitationWhereInput[]
    OR?: AgencyInvitationWhereInput[]
    NOT?: AgencyInvitationWhereInput | AgencyInvitationWhereInput[]
    id?: StringFilter<"AgencyInvitation"> | string
    token?: StringFilter<"AgencyInvitation"> | string
    agencyId?: StringFilter<"AgencyInvitation"> | string
    email?: StringFilter<"AgencyInvitation"> | string
    senderId?: StringFilter<"AgencyInvitation"> | string
    status?: EnumAgencyInvitationStatusFilter<"AgencyInvitation"> | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AgencyInvitationOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    agencyId?: SortOrder
    email?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    _relevance?: AgencyInvitationOrderByRelevanceInput
  }

  export type AgencyInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AgencyInvitationWhereInput | AgencyInvitationWhereInput[]
    OR?: AgencyInvitationWhereInput[]
    NOT?: AgencyInvitationWhereInput | AgencyInvitationWhereInput[]
    agencyId?: StringFilter<"AgencyInvitation"> | string
    email?: StringFilter<"AgencyInvitation"> | string
    senderId?: StringFilter<"AgencyInvitation"> | string
    status?: EnumAgencyInvitationStatusFilter<"AgencyInvitation"> | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type AgencyInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    agencyId?: SortOrder
    email?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyInvitationCountOrderByAggregateInput
    _max?: AgencyInvitationMaxOrderByAggregateInput
    _min?: AgencyInvitationMinOrderByAggregateInput
  }

  export type AgencyInvitationScalarWhereWithAggregatesInput = {
    AND?: AgencyInvitationScalarWhereWithAggregatesInput | AgencyInvitationScalarWhereWithAggregatesInput[]
    OR?: AgencyInvitationScalarWhereWithAggregatesInput[]
    NOT?: AgencyInvitationScalarWhereWithAggregatesInput | AgencyInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyInvitation"> | string
    token?: StringWithAggregatesFilter<"AgencyInvitation"> | string
    agencyId?: StringWithAggregatesFilter<"AgencyInvitation"> | string
    email?: StringWithAggregatesFilter<"AgencyInvitation"> | string
    senderId?: StringWithAggregatesFilter<"AgencyInvitation"> | string
    status?: EnumAgencyInvitationStatusWithAggregatesFilter<"AgencyInvitation"> | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeWithAggregatesFilter<"AgencyInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AgencyInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyInvitation"> | Date | string
  }

  export type AgencySubmissionReviewWhereInput = {
    AND?: AgencySubmissionReviewWhereInput | AgencySubmissionReviewWhereInput[]
    OR?: AgencySubmissionReviewWhereInput[]
    NOT?: AgencySubmissionReviewWhereInput | AgencySubmissionReviewWhereInput[]
    id?: StringFilter<"AgencySubmissionReview"> | string
    agencyId?: StringFilter<"AgencySubmissionReview"> | string
    title?: JsonFilter<"AgencySubmissionReview">
    description?: JsonFilter<"AgencySubmissionReview">
    createdAt?: DateTimeFilter<"AgencySubmissionReview"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySubmissionReview"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type AgencySubmissionReviewOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    _relevance?: AgencySubmissionReviewOrderByRelevanceInput
  }

  export type AgencySubmissionReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agencyId?: string
    AND?: AgencySubmissionReviewWhereInput | AgencySubmissionReviewWhereInput[]
    OR?: AgencySubmissionReviewWhereInput[]
    NOT?: AgencySubmissionReviewWhereInput | AgencySubmissionReviewWhereInput[]
    title?: JsonFilter<"AgencySubmissionReview">
    description?: JsonFilter<"AgencySubmissionReview">
    createdAt?: DateTimeFilter<"AgencySubmissionReview"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySubmissionReview"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "agencyId">

  export type AgencySubmissionReviewOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencySubmissionReviewCountOrderByAggregateInput
    _max?: AgencySubmissionReviewMaxOrderByAggregateInput
    _min?: AgencySubmissionReviewMinOrderByAggregateInput
  }

  export type AgencySubmissionReviewScalarWhereWithAggregatesInput = {
    AND?: AgencySubmissionReviewScalarWhereWithAggregatesInput | AgencySubmissionReviewScalarWhereWithAggregatesInput[]
    OR?: AgencySubmissionReviewScalarWhereWithAggregatesInput[]
    NOT?: AgencySubmissionReviewScalarWhereWithAggregatesInput | AgencySubmissionReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencySubmissionReview"> | string
    agencyId?: StringWithAggregatesFilter<"AgencySubmissionReview"> | string
    title?: JsonWithAggregatesFilter<"AgencySubmissionReview">
    description?: JsonWithAggregatesFilter<"AgencySubmissionReview">
    createdAt?: DateTimeWithAggregatesFilter<"AgencySubmissionReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencySubmissionReview"> | Date | string
  }

  export type AgencyViewWhereInput = {
    AND?: AgencyViewWhereInput | AgencyViewWhereInput[]
    OR?: AgencyViewWhereInput[]
    NOT?: AgencyViewWhereInput | AgencyViewWhereInput[]
    id?: StringFilter<"AgencyView"> | string
    agencyId?: StringFilter<"AgencyView"> | string
    clientId?: StringNullableFilter<"AgencyView"> | string | null
    additionalInfo?: JsonNullableFilter<"AgencyView">
    viewDate?: DateTimeFilter<"AgencyView"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyView"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type AgencyViewOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    viewDate?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    _relevance?: AgencyViewOrderByRelevanceInput
  }

  export type AgencyViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyViewWhereInput | AgencyViewWhereInput[]
    OR?: AgencyViewWhereInput[]
    NOT?: AgencyViewWhereInput | AgencyViewWhereInput[]
    agencyId?: StringFilter<"AgencyView"> | string
    clientId?: StringNullableFilter<"AgencyView"> | string | null
    additionalInfo?: JsonNullableFilter<"AgencyView">
    viewDate?: DateTimeFilter<"AgencyView"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyView"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type AgencyViewOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    viewDate?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyViewCountOrderByAggregateInput
    _max?: AgencyViewMaxOrderByAggregateInput
    _min?: AgencyViewMinOrderByAggregateInput
  }

  export type AgencyViewScalarWhereWithAggregatesInput = {
    AND?: AgencyViewScalarWhereWithAggregatesInput | AgencyViewScalarWhereWithAggregatesInput[]
    OR?: AgencyViewScalarWhereWithAggregatesInput[]
    NOT?: AgencyViewScalarWhereWithAggregatesInput | AgencyViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyView"> | string
    agencyId?: StringWithAggregatesFilter<"AgencyView"> | string
    clientId?: StringNullableWithAggregatesFilter<"AgencyView"> | string | null
    additionalInfo?: JsonNullableWithAggregatesFilter<"AgencyView">
    viewDate?: DateTimeWithAggregatesFilter<"AgencyView"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyView"> | Date | string
  }

  export type AgencyReviewWhereInput = {
    AND?: AgencyReviewWhereInput | AgencyReviewWhereInput[]
    OR?: AgencyReviewWhereInput[]
    NOT?: AgencyReviewWhereInput | AgencyReviewWhereInput[]
    id?: StringFilter<"AgencyReview"> | string
    approved?: BoolFilter<"AgencyReview"> | boolean
    rating?: FloatFilter<"AgencyReview"> | number
    comment?: StringNullableFilter<"AgencyReview"> | string | null
    createdAt?: DateTimeFilter<"AgencyReview"> | Date | string
    attributes?: JsonNullableFilter<"AgencyReview">
    agencyId?: StringFilter<"AgencyReview"> | string
    clientId?: StringFilter<"AgencyReview"> | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type AgencyReviewOrderByWithRelationInput = {
    id?: SortOrder
    approved?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attributes?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    _relevance?: AgencyReviewOrderByRelevanceInput
  }

  export type AgencyReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyReviewWhereInput | AgencyReviewWhereInput[]
    OR?: AgencyReviewWhereInput[]
    NOT?: AgencyReviewWhereInput | AgencyReviewWhereInput[]
    approved?: BoolFilter<"AgencyReview"> | boolean
    rating?: FloatFilter<"AgencyReview"> | number
    comment?: StringNullableFilter<"AgencyReview"> | string | null
    createdAt?: DateTimeFilter<"AgencyReview"> | Date | string
    attributes?: JsonNullableFilter<"AgencyReview">
    agencyId?: StringFilter<"AgencyReview"> | string
    clientId?: StringFilter<"AgencyReview"> | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type AgencyReviewOrderByWithAggregationInput = {
    id?: SortOrder
    approved?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attributes?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
    _count?: AgencyReviewCountOrderByAggregateInput
    _avg?: AgencyReviewAvgOrderByAggregateInput
    _max?: AgencyReviewMaxOrderByAggregateInput
    _min?: AgencyReviewMinOrderByAggregateInput
    _sum?: AgencyReviewSumOrderByAggregateInput
  }

  export type AgencyReviewScalarWhereWithAggregatesInput = {
    AND?: AgencyReviewScalarWhereWithAggregatesInput | AgencyReviewScalarWhereWithAggregatesInput[]
    OR?: AgencyReviewScalarWhereWithAggregatesInput[]
    NOT?: AgencyReviewScalarWhereWithAggregatesInput | AgencyReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyReview"> | string
    approved?: BoolWithAggregatesFilter<"AgencyReview"> | boolean
    rating?: FloatWithAggregatesFilter<"AgencyReview"> | number
    comment?: StringNullableWithAggregatesFilter<"AgencyReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgencyReview"> | Date | string
    attributes?: JsonNullableWithAggregatesFilter<"AgencyReview">
    agencyId?: StringWithAggregatesFilter<"AgencyReview"> | string
    clientId?: StringWithAggregatesFilter<"AgencyReview"> | string
  }

  export type AgentReminderWhereInput = {
    AND?: AgentReminderWhereInput | AgentReminderWhereInput[]
    OR?: AgentReminderWhereInput[]
    NOT?: AgentReminderWhereInput | AgentReminderWhereInput[]
    id?: StringFilter<"AgentReminder"> | string
    title?: StringFilter<"AgentReminder"> | string
    description?: StringFilter<"AgentReminder"> | string
    status?: EnumReminderStatusFilter<"AgentReminder"> | $Enums.ReminderStatus
    agencyMemberId?: StringFilter<"AgentReminder"> | string
    startDate?: DateTimeFilter<"AgentReminder"> | Date | string
    isRecurring?: BoolFilter<"AgentReminder"> | boolean
    endDate?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    lastSentAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    agencyMember?: XOR<AgencyMemberScalarRelationFilter, AgencyMemberWhereInput>
  }

  export type AgentReminderOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    agencyMemberId?: SortOrder
    startDate?: SortOrder
    isRecurring?: SortOrder
    endDate?: SortOrderInput | SortOrder
    lastSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    agencyMember?: AgencyMemberOrderByWithRelationInput
    _relevance?: AgentReminderOrderByRelevanceInput
  }

  export type AgentReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentReminderWhereInput | AgentReminderWhereInput[]
    OR?: AgentReminderWhereInput[]
    NOT?: AgentReminderWhereInput | AgentReminderWhereInput[]
    title?: StringFilter<"AgentReminder"> | string
    description?: StringFilter<"AgentReminder"> | string
    status?: EnumReminderStatusFilter<"AgentReminder"> | $Enums.ReminderStatus
    agencyMemberId?: StringFilter<"AgentReminder"> | string
    startDate?: DateTimeFilter<"AgentReminder"> | Date | string
    isRecurring?: BoolFilter<"AgentReminder"> | boolean
    endDate?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    lastSentAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    agencyMember?: XOR<AgencyMemberScalarRelationFilter, AgencyMemberWhereInput>
  }, "id">

  export type AgentReminderOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    agencyMemberId?: SortOrder
    startDate?: SortOrder
    isRecurring?: SortOrder
    endDate?: SortOrderInput | SortOrder
    lastSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AgentReminderCountOrderByAggregateInput
    _max?: AgentReminderMaxOrderByAggregateInput
    _min?: AgentReminderMinOrderByAggregateInput
  }

  export type AgentReminderScalarWhereWithAggregatesInput = {
    AND?: AgentReminderScalarWhereWithAggregatesInput | AgentReminderScalarWhereWithAggregatesInput[]
    OR?: AgentReminderScalarWhereWithAggregatesInput[]
    NOT?: AgentReminderScalarWhereWithAggregatesInput | AgentReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentReminder"> | string
    title?: StringWithAggregatesFilter<"AgentReminder"> | string
    description?: StringWithAggregatesFilter<"AgentReminder"> | string
    status?: EnumReminderStatusWithAggregatesFilter<"AgentReminder"> | $Enums.ReminderStatus
    agencyMemberId?: StringWithAggregatesFilter<"AgentReminder"> | string
    startDate?: DateTimeWithAggregatesFilter<"AgentReminder"> | Date | string
    isRecurring?: BoolWithAggregatesFilter<"AgentReminder"> | boolean
    endDate?: DateTimeNullableWithAggregatesFilter<"AgentReminder"> | Date | string | null
    lastSentAt?: DateTimeNullableWithAggregatesFilter<"AgentReminder"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AgentReminder"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AgentReminder"> | Date | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    receiveCompanyEmail?: BoolNullableFilter<"Client"> | boolean | null
    receiveCompanySMS?: BoolNullableFilter<"Client"> | boolean | null
    receiveAgentEmail?: BoolNullableFilter<"Client"> | boolean | null
    receiveAgentSMS?: BoolNullableFilter<"Client"> | boolean | null
    userId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    preferences?: JsonNullableFilter<"Client">
    clientSubscription?: ClientPropertySubscriptionListRelationFilter
    favorites?: PropertyFavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    clientSearches?: ClientSearchListRelationFilter
    reviews?: AgencyReviewListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    AgencyView?: AgencyViewListRelationFilter
    PropertyEngagement?: PropertyEngagementListRelationFilter
    Proposal?: ProposalListRelationFilter
    ProposalCollaboration?: ProposalCollaborationListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    receiveCompanyEmail?: SortOrderInput | SortOrder
    receiveCompanySMS?: SortOrderInput | SortOrder
    receiveAgentEmail?: SortOrderInput | SortOrder
    receiveAgentSMS?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferences?: SortOrderInput | SortOrder
    clientSubscription?: ClientPropertySubscriptionOrderByRelationAggregateInput
    favorites?: PropertyFavoriteOrderByRelationAggregateInput
    propertyViews?: PropertyViewOrderByRelationAggregateInput
    clientSearches?: ClientSearchOrderByRelationAggregateInput
    reviews?: AgencyReviewOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    AgencyView?: AgencyViewOrderByRelationAggregateInput
    PropertyEngagement?: PropertyEngagementOrderByRelationAggregateInput
    Proposal?: ProposalOrderByRelationAggregateInput
    ProposalCollaboration?: ProposalCollaborationOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    receiveCompanyEmail?: BoolNullableFilter<"Client"> | boolean | null
    receiveCompanySMS?: BoolNullableFilter<"Client"> | boolean | null
    receiveAgentEmail?: BoolNullableFilter<"Client"> | boolean | null
    receiveAgentSMS?: BoolNullableFilter<"Client"> | boolean | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    preferences?: JsonNullableFilter<"Client">
    clientSubscription?: ClientPropertySubscriptionListRelationFilter
    favorites?: PropertyFavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    clientSearches?: ClientSearchListRelationFilter
    reviews?: AgencyReviewListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    AgencyView?: AgencyViewListRelationFilter
    PropertyEngagement?: PropertyEngagementListRelationFilter
    Proposal?: ProposalListRelationFilter
    ProposalCollaboration?: ProposalCollaborationListRelationFilter
  }, "id" | "userId">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    receiveCompanyEmail?: SortOrderInput | SortOrder
    receiveCompanySMS?: SortOrderInput | SortOrder
    receiveAgentEmail?: SortOrderInput | SortOrder
    receiveAgentSMS?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferences?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    receiveCompanyEmail?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    receiveCompanySMS?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    receiveAgentEmail?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    receiveAgentSMS?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    userId?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    preferences?: JsonNullableWithAggregatesFilter<"Client">
  }

  export type ClientSearchWhereInput = {
    AND?: ClientSearchWhereInput | ClientSearchWhereInput[]
    OR?: ClientSearchWhereInput[]
    NOT?: ClientSearchWhereInput | ClientSearchWhereInput[]
    id?: StringFilter<"ClientSearch"> | string
    createdAt?: DateTimeFilter<"ClientSearch"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSearch"> | Date | string
    clientId?: StringFilter<"ClientSearch"> | string
    title?: JsonFilter<"ClientSearch">
    link?: StringFilter<"ClientSearch"> | string
    filters?: JsonFilter<"ClientSearch">
    receiveOffers?: BoolFilter<"ClientSearch"> | boolean
    agencyIdsJson?: JsonNullableFilter<"ClientSearch">
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    clientPropertySubscription?: XOR<ClientPropertySubscriptionNullableScalarRelationFilter, ClientPropertySubscriptionWhereInput> | null
  }

  export type ClientSearchOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    link?: SortOrder
    filters?: SortOrder
    receiveOffers?: SortOrder
    agencyIdsJson?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    clientPropertySubscription?: ClientPropertySubscriptionOrderByWithRelationInput
    _relevance?: ClientSearchOrderByRelevanceInput
  }

  export type ClientSearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientSearchWhereInput | ClientSearchWhereInput[]
    OR?: ClientSearchWhereInput[]
    NOT?: ClientSearchWhereInput | ClientSearchWhereInput[]
    createdAt?: DateTimeFilter<"ClientSearch"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSearch"> | Date | string
    clientId?: StringFilter<"ClientSearch"> | string
    title?: JsonFilter<"ClientSearch">
    link?: StringFilter<"ClientSearch"> | string
    filters?: JsonFilter<"ClientSearch">
    receiveOffers?: BoolFilter<"ClientSearch"> | boolean
    agencyIdsJson?: JsonNullableFilter<"ClientSearch">
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    clientPropertySubscription?: XOR<ClientPropertySubscriptionNullableScalarRelationFilter, ClientPropertySubscriptionWhereInput> | null
  }, "id">

  export type ClientSearchOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    link?: SortOrder
    filters?: SortOrder
    receiveOffers?: SortOrder
    agencyIdsJson?: SortOrderInput | SortOrder
    _count?: ClientSearchCountOrderByAggregateInput
    _max?: ClientSearchMaxOrderByAggregateInput
    _min?: ClientSearchMinOrderByAggregateInput
  }

  export type ClientSearchScalarWhereWithAggregatesInput = {
    AND?: ClientSearchScalarWhereWithAggregatesInput | ClientSearchScalarWhereWithAggregatesInput[]
    OR?: ClientSearchScalarWhereWithAggregatesInput[]
    NOT?: ClientSearchScalarWhereWithAggregatesInput | ClientSearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientSearch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientSearch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientSearch"> | Date | string
    clientId?: StringWithAggregatesFilter<"ClientSearch"> | string
    title?: JsonWithAggregatesFilter<"ClientSearch">
    link?: StringWithAggregatesFilter<"ClientSearch"> | string
    filters?: JsonWithAggregatesFilter<"ClientSearch">
    receiveOffers?: BoolWithAggregatesFilter<"ClientSearch"> | boolean
    agencyIdsJson?: JsonNullableWithAggregatesFilter<"ClientSearch">
  }

  export type ClientPropertySubscriptionWhereInput = {
    AND?: ClientPropertySubscriptionWhereInput | ClientPropertySubscriptionWhereInput[]
    OR?: ClientPropertySubscriptionWhereInput[]
    NOT?: ClientPropertySubscriptionWhereInput | ClientPropertySubscriptionWhereInput[]
    id?: StringFilter<"ClientPropertySubscription"> | string
    minSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    minPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    location?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    listingType?: EnumPropertyListingTypeNullableFilter<"ClientPropertySubscription"> | $Enums.PropertyListingType | null
    category?: StringFilter<"ClientPropertySubscription"> | string
    subCategory?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    createdAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    clientId?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    clientSearchId?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    clientSearch?: XOR<ClientSearchNullableScalarRelationFilter, ClientSearchWhereInput> | null
  }

  export type ClientPropertySubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    minSize?: SortOrderInput | SortOrder
    maxSize?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    listingType?: SortOrderInput | SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSearchId?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    clientSearch?: ClientSearchOrderByWithRelationInput
    _relevance?: ClientPropertySubscriptionOrderByRelevanceInput
  }

  export type ClientPropertySubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientSearchId?: string
    AND?: ClientPropertySubscriptionWhereInput | ClientPropertySubscriptionWhereInput[]
    OR?: ClientPropertySubscriptionWhereInput[]
    NOT?: ClientPropertySubscriptionWhereInput | ClientPropertySubscriptionWhereInput[]
    minSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    minPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    location?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    listingType?: EnumPropertyListingTypeNullableFilter<"ClientPropertySubscription"> | $Enums.PropertyListingType | null
    category?: StringFilter<"ClientPropertySubscription"> | string
    subCategory?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    createdAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    clientId?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    clientSearch?: XOR<ClientSearchNullableScalarRelationFilter, ClientSearchWhereInput> | null
  }, "id" | "clientSearchId">

  export type ClientPropertySubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    minSize?: SortOrderInput | SortOrder
    maxSize?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    listingType?: SortOrderInput | SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSearchId?: SortOrderInput | SortOrder
    _count?: ClientPropertySubscriptionCountOrderByAggregateInput
    _avg?: ClientPropertySubscriptionAvgOrderByAggregateInput
    _max?: ClientPropertySubscriptionMaxOrderByAggregateInput
    _min?: ClientPropertySubscriptionMinOrderByAggregateInput
    _sum?: ClientPropertySubscriptionSumOrderByAggregateInput
  }

  export type ClientPropertySubscriptionScalarWhereWithAggregatesInput = {
    AND?: ClientPropertySubscriptionScalarWhereWithAggregatesInput | ClientPropertySubscriptionScalarWhereWithAggregatesInput[]
    OR?: ClientPropertySubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ClientPropertySubscriptionScalarWhereWithAggregatesInput | ClientPropertySubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientPropertySubscription"> | string
    minSize?: IntNullableWithAggregatesFilter<"ClientPropertySubscription"> | number | null
    maxSize?: IntNullableWithAggregatesFilter<"ClientPropertySubscription"> | number | null
    minPrice?: IntNullableWithAggregatesFilter<"ClientPropertySubscription"> | number | null
    maxPrice?: IntNullableWithAggregatesFilter<"ClientPropertySubscription"> | number | null
    location?: StringNullableWithAggregatesFilter<"ClientPropertySubscription"> | string | null
    listingType?: EnumPropertyListingTypeNullableWithAggregatesFilter<"ClientPropertySubscription"> | $Enums.PropertyListingType | null
    category?: StringWithAggregatesFilter<"ClientPropertySubscription"> | string
    subCategory?: StringNullableWithAggregatesFilter<"ClientPropertySubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientPropertySubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientPropertySubscription"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"ClientPropertySubscription"> | string | null
    clientSearchId?: StringNullableWithAggregatesFilter<"ClientPropertySubscription"> | string | null
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    location?: StringFilter<"SearchQuery"> | string
    listingType?: EnumPropertyListingTypeFilter<"SearchQuery"> | $Enums.PropertyListingType
    category?: StringFilter<"SearchQuery"> | string
    subCategory?: StringNullableFilter<"SearchQuery"> | string | null
    priceFrom?: IntNullableFilter<"SearchQuery"> | number | null
    priceTo?: IntNullableFilter<"SearchQuery"> | number | null
    sizeFrom?: IntNullableFilter<"SearchQuery"> | number | null
    sizeTo?: IntNullableFilter<"SearchQuery"> | number | null
    clientId?: StringNullableFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    priceFrom?: SortOrderInput | SortOrder
    priceTo?: SortOrderInput | SortOrder
    sizeFrom?: SortOrderInput | SortOrder
    sizeTo?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SearchQueryOrderByRelevanceInput
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    location?: StringFilter<"SearchQuery"> | string
    listingType?: EnumPropertyListingTypeFilter<"SearchQuery"> | $Enums.PropertyListingType
    category?: StringFilter<"SearchQuery"> | string
    subCategory?: StringNullableFilter<"SearchQuery"> | string | null
    priceFrom?: IntNullableFilter<"SearchQuery"> | number | null
    priceTo?: IntNullableFilter<"SearchQuery"> | number | null
    sizeFrom?: IntNullableFilter<"SearchQuery"> | number | null
    sizeTo?: IntNullableFilter<"SearchQuery"> | number | null
    clientId?: StringNullableFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }, "id">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    priceFrom?: SortOrderInput | SortOrder
    priceTo?: SortOrderInput | SortOrder
    sizeFrom?: SortOrderInput | SortOrder
    sizeTo?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _avg?: SearchQueryAvgOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
    _sum?: SearchQuerySumOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchQuery"> | string
    location?: StringWithAggregatesFilter<"SearchQuery"> | string
    listingType?: EnumPropertyListingTypeWithAggregatesFilter<"SearchQuery"> | $Enums.PropertyListingType
    category?: StringWithAggregatesFilter<"SearchQuery"> | string
    subCategory?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    priceFrom?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    priceTo?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    sizeFrom?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    sizeTo?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    clientId?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
  }

  export type ExternalListingWhereInput = {
    AND?: ExternalListingWhereInput | ExternalListingWhereInput[]
    OR?: ExternalListingWhereInput[]
    NOT?: ExternalListingWhereInput | ExternalListingWhereInput[]
    id?: StringFilter<"ExternalListing"> | string
    category?: EnumExternalListingCategoryFilter<"ExternalListing"> | $Enums.ExternalListingCategory
    fullName?: StringFilter<"ExternalListing"> | string
    type?: StringFilter<"ExternalListing"> | string
    title?: StringFilter<"ExternalListing"> | string
    description?: StringFilter<"ExternalListing"> | string
    price?: StringFilter<"ExternalListing"> | string
    attributes?: StringNullableFilter<"ExternalListing"> | string | null
    location?: StringFilter<"ExternalListing"> | string
    phoneNumber?: StringNullableFilter<"ExternalListing"> | string | null
    email?: StringNullableFilter<"ExternalListing"> | string | null
    sourceId?: StringFilter<"ExternalListing"> | string
    sourceName?: StringFilter<"ExternalListing"> | string
    url?: StringFilter<"ExternalListing"> | string
    createdAt?: DateTimeFilter<"ExternalListing"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalListing"> | Date | string
  }

  export type ExternalListingOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    fullName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    attributes?: SortOrderInput | SortOrder
    location?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    sourceId?: SortOrder
    sourceName?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ExternalListingOrderByRelevanceInput
  }

  export type ExternalListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExternalListingWhereInput | ExternalListingWhereInput[]
    OR?: ExternalListingWhereInput[]
    NOT?: ExternalListingWhereInput | ExternalListingWhereInput[]
    category?: EnumExternalListingCategoryFilter<"ExternalListing"> | $Enums.ExternalListingCategory
    fullName?: StringFilter<"ExternalListing"> | string
    type?: StringFilter<"ExternalListing"> | string
    title?: StringFilter<"ExternalListing"> | string
    description?: StringFilter<"ExternalListing"> | string
    price?: StringFilter<"ExternalListing"> | string
    attributes?: StringNullableFilter<"ExternalListing"> | string | null
    location?: StringFilter<"ExternalListing"> | string
    phoneNumber?: StringNullableFilter<"ExternalListing"> | string | null
    email?: StringNullableFilter<"ExternalListing"> | string | null
    sourceId?: StringFilter<"ExternalListing"> | string
    sourceName?: StringFilter<"ExternalListing"> | string
    url?: StringFilter<"ExternalListing"> | string
    createdAt?: DateTimeFilter<"ExternalListing"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalListing"> | Date | string
  }, "id">

  export type ExternalListingOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    fullName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    attributes?: SortOrderInput | SortOrder
    location?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    sourceId?: SortOrder
    sourceName?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalListingCountOrderByAggregateInput
    _max?: ExternalListingMaxOrderByAggregateInput
    _min?: ExternalListingMinOrderByAggregateInput
  }

  export type ExternalListingScalarWhereWithAggregatesInput = {
    AND?: ExternalListingScalarWhereWithAggregatesInput | ExternalListingScalarWhereWithAggregatesInput[]
    OR?: ExternalListingScalarWhereWithAggregatesInput[]
    NOT?: ExternalListingScalarWhereWithAggregatesInput | ExternalListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalListing"> | string
    category?: EnumExternalListingCategoryWithAggregatesFilter<"ExternalListing"> | $Enums.ExternalListingCategory
    fullName?: StringWithAggregatesFilter<"ExternalListing"> | string
    type?: StringWithAggregatesFilter<"ExternalListing"> | string
    title?: StringWithAggregatesFilter<"ExternalListing"> | string
    description?: StringWithAggregatesFilter<"ExternalListing"> | string
    price?: StringWithAggregatesFilter<"ExternalListing"> | string
    attributes?: StringNullableWithAggregatesFilter<"ExternalListing"> | string | null
    location?: StringWithAggregatesFilter<"ExternalListing"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"ExternalListing"> | string | null
    email?: StringNullableWithAggregatesFilter<"ExternalListing"> | string | null
    sourceId?: StringWithAggregatesFilter<"ExternalListing"> | string
    sourceName?: StringWithAggregatesFilter<"ExternalListing"> | string
    url?: StringWithAggregatesFilter<"ExternalListing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExternalListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalListing"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: JsonFilter<"Property">
    latitude?: FloatFilter<"Property"> | number
    address?: StringFilter<"Property"> | string
    longitude?: FloatFilter<"Property"> | number
    agencyId?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    price?: IntFilter<"Property"> | number
    hasApproximatePrice?: BoolNullableFilter<"Property"> | boolean | null
    approximatePrice?: IntNullableFilter<"Property"> | number | null
    estimationPrice?: IntNullableFilter<"Property"> | number | null
    size?: IntFilter<"Property"> | number
    description?: JsonFilter<"Property">
    slug?: StringNullableFilter<"Property"> | string | null
    photos?: JsonNullableFilter<"Property">
    video?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    createdBy?: StringFilter<"Property"> | string
    createdByMemberId?: StringNullableFilter<"Property"> | string | null
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    attributes?: JsonNullableFilter<"Property">
    yearBuilt?: DateTimeNullableFilter<"Property"> | Date | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    builder?: StringNullableFilter<"Property"> | string | null
    propertyCadastralMunicipality?: StringNullableFilter<"Property"> | string | null
    propertyDeed?: StringNullableFilter<"Property"> | string | null
    inDevelopment?: BoolNullableFilter<"Property"> | boolean | null
    inDevelopmentUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyPlan?: JsonNullableFilter<"Property">
    poi?: JsonNullableFilter<"Property">
    featured?: BoolFilter<"Property"> | boolean
    featuredUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    orientation?: EnumPropertyOrientationNullableFilter<"Property"> | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Property"> | $Enums.PropertyListingType
    propertyLocationId?: StringNullableFilter<"Property"> | string | null
    modifications?: JsonNullableFilter<"Property">
    categoryId?: StringNullableFilter<"Property"> | string | null
    subcategoryId?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringNullableFilter<"Property"> | string | null
    renterId?: StringNullableFilter<"Property"> | string | null
    externalId?: StringNullableFilter<"Property"> | string | null
    autoRenewEnabled?: BoolFilter<"Property"> | boolean
    autoRenewStartDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    autoRenewEndDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    lastAutoRenewedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    bumpedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdByMember?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    views?: PropertyViewListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    PropertyFavorite?: PropertyFavoriteListRelationFilter
    PropertySale?: XOR<PropertySaleNullableScalarRelationFilter, PropertySaleWhereInput> | null
    PropertyEngagement?: PropertyEngagementListRelationFilter
    propertyReview?: PropertySubmissionReviewListRelationFilter
    propertyLocation?: XOR<PropertyLocationNullableScalarRelationFilter, PropertyLocationWhereInput> | null
    category?: XOR<PropertyCategoryNullableScalarRelationFilter, PropertyCategoryWhereInput> | null
    subcategory?: XOR<PropertySubcategoryNullableScalarRelationFilter, PropertySubcategoryWhereInput> | null
    owner?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
    renter?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrder
    hasApproximatePrice?: SortOrderInput | SortOrder
    approximatePrice?: SortOrderInput | SortOrder
    estimationPrice?: SortOrderInput | SortOrder
    size?: SortOrder
    description?: SortOrder
    slug?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByMemberId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    attributes?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    builder?: SortOrderInput | SortOrder
    propertyCadastralMunicipality?: SortOrderInput | SortOrder
    propertyDeed?: SortOrderInput | SortOrder
    inDevelopment?: SortOrderInput | SortOrder
    inDevelopmentUntil?: SortOrderInput | SortOrder
    propertyPlan?: SortOrderInput | SortOrder
    poi?: SortOrderInput | SortOrder
    featured?: SortOrder
    featuredUntil?: SortOrderInput | SortOrder
    orientation?: SortOrderInput | SortOrder
    type?: SortOrder
    listingType?: SortOrder
    propertyLocationId?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    renterId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    autoRenewEnabled?: SortOrder
    autoRenewStartDate?: SortOrderInput | SortOrder
    autoRenewEndDate?: SortOrderInput | SortOrder
    lastAutoRenewedAt?: SortOrderInput | SortOrder
    bumpedAt?: SortOrderInput | SortOrder
    createdByMember?: AgencyMemberOrderByWithRelationInput
    views?: PropertyViewOrderByRelationAggregateInput
    agency?: AgencyOrderByWithRelationInput
    PropertyFavorite?: PropertyFavoriteOrderByRelationAggregateInput
    PropertySale?: PropertySaleOrderByWithRelationInput
    PropertyEngagement?: PropertyEngagementOrderByRelationAggregateInput
    propertyReview?: PropertySubmissionReviewOrderByRelationAggregateInput
    propertyLocation?: PropertyLocationOrderByWithRelationInput
    category?: PropertyCategoryOrderByWithRelationInput
    subcategory?: PropertySubcategoryOrderByWithRelationInput
    owner?: AgencyClientOrderByWithRelationInput
    renter?: AgencyClientOrderByWithRelationInput
    _relevance?: PropertyOrderByRelevanceInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: JsonFilter<"Property">
    latitude?: FloatFilter<"Property"> | number
    address?: StringFilter<"Property"> | string
    longitude?: FloatFilter<"Property"> | number
    agencyId?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    price?: IntFilter<"Property"> | number
    hasApproximatePrice?: BoolNullableFilter<"Property"> | boolean | null
    approximatePrice?: IntNullableFilter<"Property"> | number | null
    estimationPrice?: IntNullableFilter<"Property"> | number | null
    size?: IntFilter<"Property"> | number
    description?: JsonFilter<"Property">
    slug?: StringNullableFilter<"Property"> | string | null
    photos?: JsonNullableFilter<"Property">
    video?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    createdBy?: StringFilter<"Property"> | string
    createdByMemberId?: StringNullableFilter<"Property"> | string | null
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    attributes?: JsonNullableFilter<"Property">
    yearBuilt?: DateTimeNullableFilter<"Property"> | Date | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    builder?: StringNullableFilter<"Property"> | string | null
    propertyCadastralMunicipality?: StringNullableFilter<"Property"> | string | null
    propertyDeed?: StringNullableFilter<"Property"> | string | null
    inDevelopment?: BoolNullableFilter<"Property"> | boolean | null
    inDevelopmentUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyPlan?: JsonNullableFilter<"Property">
    poi?: JsonNullableFilter<"Property">
    featured?: BoolFilter<"Property"> | boolean
    featuredUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    orientation?: EnumPropertyOrientationNullableFilter<"Property"> | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Property"> | $Enums.PropertyListingType
    propertyLocationId?: StringNullableFilter<"Property"> | string | null
    modifications?: JsonNullableFilter<"Property">
    categoryId?: StringNullableFilter<"Property"> | string | null
    subcategoryId?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringNullableFilter<"Property"> | string | null
    renterId?: StringNullableFilter<"Property"> | string | null
    externalId?: StringNullableFilter<"Property"> | string | null
    autoRenewEnabled?: BoolFilter<"Property"> | boolean
    autoRenewStartDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    autoRenewEndDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    lastAutoRenewedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    bumpedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdByMember?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    views?: PropertyViewListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    PropertyFavorite?: PropertyFavoriteListRelationFilter
    PropertySale?: XOR<PropertySaleNullableScalarRelationFilter, PropertySaleWhereInput> | null
    PropertyEngagement?: PropertyEngagementListRelationFilter
    propertyReview?: PropertySubmissionReviewListRelationFilter
    propertyLocation?: XOR<PropertyLocationNullableScalarRelationFilter, PropertyLocationWhereInput> | null
    category?: XOR<PropertyCategoryNullableScalarRelationFilter, PropertyCategoryWhereInput> | null
    subcategory?: XOR<PropertySubcategoryNullableScalarRelationFilter, PropertySubcategoryWhereInput> | null
    owner?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
    renter?: XOR<AgencyClientNullableScalarRelationFilter, AgencyClientWhereInput> | null
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrder
    hasApproximatePrice?: SortOrderInput | SortOrder
    approximatePrice?: SortOrderInput | SortOrder
    estimationPrice?: SortOrderInput | SortOrder
    size?: SortOrder
    description?: SortOrder
    slug?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByMemberId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    attributes?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    builder?: SortOrderInput | SortOrder
    propertyCadastralMunicipality?: SortOrderInput | SortOrder
    propertyDeed?: SortOrderInput | SortOrder
    inDevelopment?: SortOrderInput | SortOrder
    inDevelopmentUntil?: SortOrderInput | SortOrder
    propertyPlan?: SortOrderInput | SortOrder
    poi?: SortOrderInput | SortOrder
    featured?: SortOrder
    featuredUntil?: SortOrderInput | SortOrder
    orientation?: SortOrderInput | SortOrder
    type?: SortOrder
    listingType?: SortOrder
    propertyLocationId?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    renterId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    autoRenewEnabled?: SortOrder
    autoRenewStartDate?: SortOrderInput | SortOrder
    autoRenewEndDate?: SortOrderInput | SortOrder
    lastAutoRenewedAt?: SortOrderInput | SortOrder
    bumpedAt?: SortOrderInput | SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: JsonWithAggregatesFilter<"Property">
    latitude?: FloatWithAggregatesFilter<"Property"> | number
    address?: StringWithAggregatesFilter<"Property"> | string
    longitude?: FloatWithAggregatesFilter<"Property"> | number
    agencyId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    status?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    price?: IntWithAggregatesFilter<"Property"> | number
    hasApproximatePrice?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    approximatePrice?: IntNullableWithAggregatesFilter<"Property"> | number | null
    estimationPrice?: IntNullableWithAggregatesFilter<"Property"> | number | null
    size?: IntWithAggregatesFilter<"Property"> | number
    description?: JsonWithAggregatesFilter<"Property">
    slug?: StringNullableWithAggregatesFilter<"Property"> | string | null
    photos?: JsonNullableWithAggregatesFilter<"Property">
    video?: StringNullableWithAggregatesFilter<"Property"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Property"> | string
    createdByMemberId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    attributes?: JsonNullableWithAggregatesFilter<"Property">
    yearBuilt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"Property"> | string | null
    builder?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyCadastralMunicipality?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyDeed?: StringNullableWithAggregatesFilter<"Property"> | string | null
    inDevelopment?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    inDevelopmentUntil?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    propertyPlan?: JsonNullableWithAggregatesFilter<"Property">
    poi?: JsonNullableWithAggregatesFilter<"Property">
    featured?: BoolWithAggregatesFilter<"Property"> | boolean
    featuredUntil?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    orientation?: EnumPropertyOrientationNullableWithAggregatesFilter<"Property"> | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeWithAggregatesFilter<"Property"> | $Enums.PropertyListingType
    propertyLocationId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    modifications?: JsonNullableWithAggregatesFilter<"Property">
    categoryId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    subcategoryId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    renterId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    autoRenewEnabled?: BoolWithAggregatesFilter<"Property"> | boolean
    autoRenewStartDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    autoRenewEndDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    lastAutoRenewedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    bumpedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
  }

  export type PropertyCategoryWhereInput = {
    AND?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    OR?: PropertyCategoryWhereInput[]
    NOT?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    id?: StringFilter<"PropertyCategory"> | string
    value?: StringFilter<"PropertyCategory"> | string
    createdAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    properties?: PropertyListRelationFilter
    subcategories?: PropertySubcategoryListRelationFilter
  }

  export type PropertyCategoryOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
    subcategories?: PropertySubcategoryOrderByRelationAggregateInput
    _relevance?: PropertyCategoryOrderByRelevanceInput
  }

  export type PropertyCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    OR?: PropertyCategoryWhereInput[]
    NOT?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    value?: StringFilter<"PropertyCategory"> | string
    createdAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    properties?: PropertyListRelationFilter
    subcategories?: PropertySubcategoryListRelationFilter
  }, "id">

  export type PropertyCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCategoryCountOrderByAggregateInput
    _max?: PropertyCategoryMaxOrderByAggregateInput
    _min?: PropertyCategoryMinOrderByAggregateInput
  }

  export type PropertyCategoryScalarWhereWithAggregatesInput = {
    AND?: PropertyCategoryScalarWhereWithAggregatesInput | PropertyCategoryScalarWhereWithAggregatesInput[]
    OR?: PropertyCategoryScalarWhereWithAggregatesInput[]
    NOT?: PropertyCategoryScalarWhereWithAggregatesInput | PropertyCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyCategory"> | string
    value?: StringWithAggregatesFilter<"PropertyCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyCategory"> | Date | string
  }

  export type PropertySubcategoryWhereInput = {
    AND?: PropertySubcategoryWhereInput | PropertySubcategoryWhereInput[]
    OR?: PropertySubcategoryWhereInput[]
    NOT?: PropertySubcategoryWhereInput | PropertySubcategoryWhereInput[]
    id?: StringFilter<"PropertySubcategory"> | string
    value?: StringFilter<"PropertySubcategory"> | string
    categoryId?: StringFilter<"PropertySubcategory"> | string
    createdAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
    category?: XOR<PropertyCategoryScalarRelationFilter, PropertyCategoryWhereInput>
    properties?: PropertyListRelationFilter
  }

  export type PropertySubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: PropertyCategoryOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    _relevance?: PropertySubcategoryOrderByRelevanceInput
  }

  export type PropertySubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value_categoryId?: PropertySubcategoryValueCategoryIdCompoundUniqueInput
    AND?: PropertySubcategoryWhereInput | PropertySubcategoryWhereInput[]
    OR?: PropertySubcategoryWhereInput[]
    NOT?: PropertySubcategoryWhereInput | PropertySubcategoryWhereInput[]
    value?: StringFilter<"PropertySubcategory"> | string
    categoryId?: StringFilter<"PropertySubcategory"> | string
    createdAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
    category?: XOR<PropertyCategoryScalarRelationFilter, PropertyCategoryWhereInput>
    properties?: PropertyListRelationFilter
  }, "id" | "value_categoryId">

  export type PropertySubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertySubcategoryCountOrderByAggregateInput
    _max?: PropertySubcategoryMaxOrderByAggregateInput
    _min?: PropertySubcategoryMinOrderByAggregateInput
  }

  export type PropertySubcategoryScalarWhereWithAggregatesInput = {
    AND?: PropertySubcategoryScalarWhereWithAggregatesInput | PropertySubcategoryScalarWhereWithAggregatesInput[]
    OR?: PropertySubcategoryScalarWhereWithAggregatesInput[]
    NOT?: PropertySubcategoryScalarWhereWithAggregatesInput | PropertySubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertySubcategory"> | string
    value?: StringWithAggregatesFilter<"PropertySubcategory"> | string
    categoryId?: StringWithAggregatesFilter<"PropertySubcategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertySubcategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertySubcategory"> | Date | string
  }

  export type PropertyLocationWhereInput = {
    AND?: PropertyLocationWhereInput | PropertyLocationWhereInput[]
    OR?: PropertyLocationWhereInput[]
    NOT?: PropertyLocationWhereInput | PropertyLocationWhereInput[]
    id?: StringFilter<"PropertyLocation"> | string
    name?: StringFilter<"PropertyLocation"> | string
    parentId?: StringNullableFilter<"PropertyLocation"> | string | null
    parent?: XOR<PropertyLocationNullableScalarRelationFilter, PropertyLocationWhereInput> | null
    children?: PropertyLocationListRelationFilter
    properties?: PropertyListRelationFilter
  }

  export type PropertyLocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    parent?: PropertyLocationOrderByWithRelationInput
    children?: PropertyLocationOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    _relevance?: PropertyLocationOrderByRelevanceInput
  }

  export type PropertyLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PropertyLocationWhereInput | PropertyLocationWhereInput[]
    OR?: PropertyLocationWhereInput[]
    NOT?: PropertyLocationWhereInput | PropertyLocationWhereInput[]
    parentId?: StringNullableFilter<"PropertyLocation"> | string | null
    parent?: XOR<PropertyLocationNullableScalarRelationFilter, PropertyLocationWhereInput> | null
    children?: PropertyLocationListRelationFilter
    properties?: PropertyListRelationFilter
  }, "id" | "name">

  export type PropertyLocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: PropertyLocationCountOrderByAggregateInput
    _max?: PropertyLocationMaxOrderByAggregateInput
    _min?: PropertyLocationMinOrderByAggregateInput
  }

  export type PropertyLocationScalarWhereWithAggregatesInput = {
    AND?: PropertyLocationScalarWhereWithAggregatesInput | PropertyLocationScalarWhereWithAggregatesInput[]
    OR?: PropertyLocationScalarWhereWithAggregatesInput[]
    NOT?: PropertyLocationScalarWhereWithAggregatesInput | PropertyLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyLocation"> | string
    name?: StringWithAggregatesFilter<"PropertyLocation"> | string
    parentId?: StringNullableWithAggregatesFilter<"PropertyLocation"> | string | null
  }

  export type PropertySubmissionReviewWhereInput = {
    AND?: PropertySubmissionReviewWhereInput | PropertySubmissionReviewWhereInput[]
    OR?: PropertySubmissionReviewWhereInput[]
    NOT?: PropertySubmissionReviewWhereInput | PropertySubmissionReviewWhereInput[]
    id?: StringFilter<"PropertySubmissionReview"> | string
    propertyId?: StringFilter<"PropertySubmissionReview"> | string
    title?: JsonFilter<"PropertySubmissionReview">
    description?: JsonFilter<"PropertySubmissionReview">
    createdAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertySubmissionReviewOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    _relevance?: PropertySubmissionReviewOrderByRelevanceInput
  }

  export type PropertySubmissionReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertySubmissionReviewWhereInput | PropertySubmissionReviewWhereInput[]
    OR?: PropertySubmissionReviewWhereInput[]
    NOT?: PropertySubmissionReviewWhereInput | PropertySubmissionReviewWhereInput[]
    propertyId?: StringFilter<"PropertySubmissionReview"> | string
    title?: JsonFilter<"PropertySubmissionReview">
    description?: JsonFilter<"PropertySubmissionReview">
    createdAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertySubmissionReviewOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertySubmissionReviewCountOrderByAggregateInput
    _max?: PropertySubmissionReviewMaxOrderByAggregateInput
    _min?: PropertySubmissionReviewMinOrderByAggregateInput
  }

  export type PropertySubmissionReviewScalarWhereWithAggregatesInput = {
    AND?: PropertySubmissionReviewScalarWhereWithAggregatesInput | PropertySubmissionReviewScalarWhereWithAggregatesInput[]
    OR?: PropertySubmissionReviewScalarWhereWithAggregatesInput[]
    NOT?: PropertySubmissionReviewScalarWhereWithAggregatesInput | PropertySubmissionReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertySubmissionReview"> | string
    propertyId?: StringWithAggregatesFilter<"PropertySubmissionReview"> | string
    title?: JsonWithAggregatesFilter<"PropertySubmissionReview">
    description?: JsonWithAggregatesFilter<"PropertySubmissionReview">
    createdAt?: DateTimeWithAggregatesFilter<"PropertySubmissionReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertySubmissionReview"> | Date | string
  }

  export type PropertySaleWhereInput = {
    AND?: PropertySaleWhereInput | PropertySaleWhereInput[]
    OR?: PropertySaleWhereInput[]
    NOT?: PropertySaleWhereInput | PropertySaleWhereInput[]
    id?: StringFilter<"PropertySale"> | string
    propertyId?: StringFilter<"PropertySale"> | string
    agencyId?: StringFilter<"PropertySale"> | string
    propertyDeed?: StringFilter<"PropertySale"> | string
    soldAt?: DateTimeFilter<"PropertySale"> | Date | string
    soldFor?: IntFilter<"PropertySale"> | number
    visibility?: BoolFilter<"PropertySale"> | boolean
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type PropertySaleOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agencyId?: SortOrder
    propertyDeed?: SortOrder
    soldAt?: SortOrder
    soldFor?: SortOrder
    visibility?: SortOrder
    property?: PropertyOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    _relevance?: PropertySaleOrderByRelevanceInput
  }

  export type PropertySaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId?: string
    AND?: PropertySaleWhereInput | PropertySaleWhereInput[]
    OR?: PropertySaleWhereInput[]
    NOT?: PropertySaleWhereInput | PropertySaleWhereInput[]
    agencyId?: StringFilter<"PropertySale"> | string
    propertyDeed?: StringFilter<"PropertySale"> | string
    soldAt?: DateTimeFilter<"PropertySale"> | Date | string
    soldFor?: IntFilter<"PropertySale"> | number
    visibility?: BoolFilter<"PropertySale"> | boolean
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "propertyId">

  export type PropertySaleOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agencyId?: SortOrder
    propertyDeed?: SortOrder
    soldAt?: SortOrder
    soldFor?: SortOrder
    visibility?: SortOrder
    _count?: PropertySaleCountOrderByAggregateInput
    _avg?: PropertySaleAvgOrderByAggregateInput
    _max?: PropertySaleMaxOrderByAggregateInput
    _min?: PropertySaleMinOrderByAggregateInput
    _sum?: PropertySaleSumOrderByAggregateInput
  }

  export type PropertySaleScalarWhereWithAggregatesInput = {
    AND?: PropertySaleScalarWhereWithAggregatesInput | PropertySaleScalarWhereWithAggregatesInput[]
    OR?: PropertySaleScalarWhereWithAggregatesInput[]
    NOT?: PropertySaleScalarWhereWithAggregatesInput | PropertySaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertySale"> | string
    propertyId?: StringWithAggregatesFilter<"PropertySale"> | string
    agencyId?: StringWithAggregatesFilter<"PropertySale"> | string
    propertyDeed?: StringWithAggregatesFilter<"PropertySale"> | string
    soldAt?: DateTimeWithAggregatesFilter<"PropertySale"> | Date | string
    soldFor?: IntWithAggregatesFilter<"PropertySale"> | number
    visibility?: BoolWithAggregatesFilter<"PropertySale"> | boolean
  }

  export type PropertyViewWhereInput = {
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    viewDate?: DateTimeFilter<"PropertyView"> | Date | string
    propertyId?: StringFilter<"PropertyView"> | string
    clientId?: StringNullableFilter<"PropertyView"> | string | null
    additionalInfo?: JsonNullableFilter<"PropertyView">
    createdAt?: DateTimeFilter<"PropertyView"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyView"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type PropertyViewOrderByWithRelationInput = {
    id?: SortOrder
    viewDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    _relevance?: PropertyViewOrderByRelevanceInput
  }

  export type PropertyViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    viewDate?: DateTimeFilter<"PropertyView"> | Date | string
    propertyId?: StringFilter<"PropertyView"> | string
    clientId?: StringNullableFilter<"PropertyView"> | string | null
    additionalInfo?: JsonNullableFilter<"PropertyView">
    createdAt?: DateTimeFilter<"PropertyView"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyView"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type PropertyViewOrderByWithAggregationInput = {
    id?: SortOrder
    viewDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyViewCountOrderByAggregateInput
    _max?: PropertyViewMaxOrderByAggregateInput
    _min?: PropertyViewMinOrderByAggregateInput
  }

  export type PropertyViewScalarWhereWithAggregatesInput = {
    AND?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    OR?: PropertyViewScalarWhereWithAggregatesInput[]
    NOT?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyView"> | string
    viewDate?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
    propertyId?: StringWithAggregatesFilter<"PropertyView"> | string
    clientId?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    additionalInfo?: JsonNullableWithAggregatesFilter<"PropertyView">
    createdAt?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
  }

  export type PropertyFavoriteWhereInput = {
    AND?: PropertyFavoriteWhereInput | PropertyFavoriteWhereInput[]
    OR?: PropertyFavoriteWhereInput[]
    NOT?: PropertyFavoriteWhereInput | PropertyFavoriteWhereInput[]
    id?: StringFilter<"PropertyFavorite"> | string
    favoriteDate?: DateTimeFilter<"PropertyFavorite"> | Date | string
    propertyId?: StringNullableFilter<"PropertyFavorite"> | string | null
    clientId?: StringNullableFilter<"PropertyFavorite"> | string | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type PropertyFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    favoriteDate?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    _relevance?: PropertyFavoriteOrderByRelevanceInput
  }

  export type PropertyFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyFavoriteWhereInput | PropertyFavoriteWhereInput[]
    OR?: PropertyFavoriteWhereInput[]
    NOT?: PropertyFavoriteWhereInput | PropertyFavoriteWhereInput[]
    favoriteDate?: DateTimeFilter<"PropertyFavorite"> | Date | string
    propertyId?: StringNullableFilter<"PropertyFavorite"> | string | null
    clientId?: StringNullableFilter<"PropertyFavorite"> | string | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type PropertyFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    favoriteDate?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    _count?: PropertyFavoriteCountOrderByAggregateInput
    _max?: PropertyFavoriteMaxOrderByAggregateInput
    _min?: PropertyFavoriteMinOrderByAggregateInput
  }

  export type PropertyFavoriteScalarWhereWithAggregatesInput = {
    AND?: PropertyFavoriteScalarWhereWithAggregatesInput | PropertyFavoriteScalarWhereWithAggregatesInput[]
    OR?: PropertyFavoriteScalarWhereWithAggregatesInput[]
    NOT?: PropertyFavoriteScalarWhereWithAggregatesInput | PropertyFavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyFavorite"> | string
    favoriteDate?: DateTimeWithAggregatesFilter<"PropertyFavorite"> | Date | string
    propertyId?: StringNullableWithAggregatesFilter<"PropertyFavorite"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"PropertyFavorite"> | string | null
  }

  export type PropertyEngagementWhereInput = {
    AND?: PropertyEngagementWhereInput | PropertyEngagementWhereInput[]
    OR?: PropertyEngagementWhereInput[]
    NOT?: PropertyEngagementWhereInput | PropertyEngagementWhereInput[]
    id?: StringFilter<"PropertyEngagement"> | string
    propertyId?: StringFilter<"PropertyEngagement"> | string
    type?: EnumEngagementTypeFilter<"PropertyEngagement"> | $Enums.EngagementType
    clientId?: StringNullableFilter<"PropertyEngagement"> | string | null
    createdAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    additionalInfo?: JsonNullableFilter<"PropertyEngagement">
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type PropertyEngagementOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    _relevance?: PropertyEngagementOrderByRelevanceInput
  }

  export type PropertyEngagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyEngagementWhereInput | PropertyEngagementWhereInput[]
    OR?: PropertyEngagementWhereInput[]
    NOT?: PropertyEngagementWhereInput | PropertyEngagementWhereInput[]
    propertyId?: StringFilter<"PropertyEngagement"> | string
    type?: EnumEngagementTypeFilter<"PropertyEngagement"> | $Enums.EngagementType
    clientId?: StringNullableFilter<"PropertyEngagement"> | string | null
    createdAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    additionalInfo?: JsonNullableFilter<"PropertyEngagement">
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type PropertyEngagementOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    _count?: PropertyEngagementCountOrderByAggregateInput
    _max?: PropertyEngagementMaxOrderByAggregateInput
    _min?: PropertyEngagementMinOrderByAggregateInput
  }

  export type PropertyEngagementScalarWhereWithAggregatesInput = {
    AND?: PropertyEngagementScalarWhereWithAggregatesInput | PropertyEngagementScalarWhereWithAggregatesInput[]
    OR?: PropertyEngagementScalarWhereWithAggregatesInput[]
    NOT?: PropertyEngagementScalarWhereWithAggregatesInput | PropertyEngagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyEngagement"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyEngagement"> | string
    type?: EnumEngagementTypeWithAggregatesFilter<"PropertyEngagement"> | $Enums.EngagementType
    clientId?: StringNullableWithAggregatesFilter<"PropertyEngagement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyEngagement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyEngagement"> | Date | string
    additionalInfo?: JsonNullableWithAggregatesFilter<"PropertyEngagement">
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    location?: StringFilter<"Proposal"> | string
    size?: IntNullableFilter<"Proposal"> | number | null
    category?: EnumPropertyTypeFilter<"Proposal"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Proposal"> | $Enums.PropertyListingType
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    photos?: JsonNullableFilter<"Proposal">
    clientId?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    offers?: ProposalOfferListRelationFilter
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    size?: SortOrderInput | SortOrder
    category?: SortOrder
    listingType?: SortOrder
    status?: SortOrder
    photos?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    offers?: ProposalOfferOrderByRelationAggregateInput
    _relevance?: ProposalOrderByRelevanceInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    location?: StringFilter<"Proposal"> | string
    size?: IntNullableFilter<"Proposal"> | number | null
    category?: EnumPropertyTypeFilter<"Proposal"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Proposal"> | $Enums.PropertyListingType
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    photos?: JsonNullableFilter<"Proposal">
    clientId?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    offers?: ProposalOfferListRelationFilter
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    size?: SortOrderInput | SortOrder
    category?: SortOrder
    listingType?: SortOrder
    status?: SortOrder
    photos?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    title?: StringWithAggregatesFilter<"Proposal"> | string
    description?: StringWithAggregatesFilter<"Proposal"> | string
    location?: StringWithAggregatesFilter<"Proposal"> | string
    size?: IntNullableWithAggregatesFilter<"Proposal"> | number | null
    category?: EnumPropertyTypeWithAggregatesFilter<"Proposal"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeWithAggregatesFilter<"Proposal"> | $Enums.PropertyListingType
    status?: EnumProposalStatusWithAggregatesFilter<"Proposal"> | $Enums.ProposalStatus
    photos?: JsonNullableWithAggregatesFilter<"Proposal">
    clientId?: StringWithAggregatesFilter<"Proposal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
  }

  export type ProposalOfferWhereInput = {
    AND?: ProposalOfferWhereInput | ProposalOfferWhereInput[]
    OR?: ProposalOfferWhereInput[]
    NOT?: ProposalOfferWhereInput | ProposalOfferWhereInput[]
    id?: StringFilter<"ProposalOffer"> | string
    title?: StringFilter<"ProposalOffer"> | string
    price?: IntFilter<"ProposalOffer"> | number
    description?: StringFilter<"ProposalOffer"> | string
    saleTimeline?: DateTimeFilter<"ProposalOffer"> | Date | string
    proposalId?: StringFilter<"ProposalOffer"> | string
    agencyId?: StringFilter<"ProposalOffer"> | string
    createdAt?: DateTimeFilter<"ProposalOffer"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalOffer"> | Date | string
    proposal?: XOR<ProposalScalarRelationFilter, ProposalWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    proposalCollaboration?: XOR<ProposalCollaborationNullableScalarRelationFilter, ProposalCollaborationWhereInput> | null
  }

  export type ProposalOfferOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    saleTimeline?: SortOrder
    proposalId?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposal?: ProposalOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    proposalCollaboration?: ProposalCollaborationOrderByWithRelationInput
    _relevance?: ProposalOfferOrderByRelevanceInput
  }

  export type ProposalOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalOfferWhereInput | ProposalOfferWhereInput[]
    OR?: ProposalOfferWhereInput[]
    NOT?: ProposalOfferWhereInput | ProposalOfferWhereInput[]
    title?: StringFilter<"ProposalOffer"> | string
    price?: IntFilter<"ProposalOffer"> | number
    description?: StringFilter<"ProposalOffer"> | string
    saleTimeline?: DateTimeFilter<"ProposalOffer"> | Date | string
    proposalId?: StringFilter<"ProposalOffer"> | string
    agencyId?: StringFilter<"ProposalOffer"> | string
    createdAt?: DateTimeFilter<"ProposalOffer"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalOffer"> | Date | string
    proposal?: XOR<ProposalScalarRelationFilter, ProposalWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    proposalCollaboration?: XOR<ProposalCollaborationNullableScalarRelationFilter, ProposalCollaborationWhereInput> | null
  }, "id">

  export type ProposalOfferOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    saleTimeline?: SortOrder
    proposalId?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalOfferCountOrderByAggregateInput
    _avg?: ProposalOfferAvgOrderByAggregateInput
    _max?: ProposalOfferMaxOrderByAggregateInput
    _min?: ProposalOfferMinOrderByAggregateInput
    _sum?: ProposalOfferSumOrderByAggregateInput
  }

  export type ProposalOfferScalarWhereWithAggregatesInput = {
    AND?: ProposalOfferScalarWhereWithAggregatesInput | ProposalOfferScalarWhereWithAggregatesInput[]
    OR?: ProposalOfferScalarWhereWithAggregatesInput[]
    NOT?: ProposalOfferScalarWhereWithAggregatesInput | ProposalOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalOffer"> | string
    title?: StringWithAggregatesFilter<"ProposalOffer"> | string
    price?: IntWithAggregatesFilter<"ProposalOffer"> | number
    description?: StringWithAggregatesFilter<"ProposalOffer"> | string
    saleTimeline?: DateTimeWithAggregatesFilter<"ProposalOffer"> | Date | string
    proposalId?: StringWithAggregatesFilter<"ProposalOffer"> | string
    agencyId?: StringWithAggregatesFilter<"ProposalOffer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProposalOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProposalOffer"> | Date | string
  }

  export type ProposalCollaborationWhereInput = {
    AND?: ProposalCollaborationWhereInput | ProposalCollaborationWhereInput[]
    OR?: ProposalCollaborationWhereInput[]
    NOT?: ProposalCollaborationWhereInput | ProposalCollaborationWhereInput[]
    id?: StringFilter<"ProposalCollaboration"> | string
    clientId?: StringFilter<"ProposalCollaboration"> | string
    title?: StringFilter<"ProposalCollaboration"> | string
    description?: StringFilter<"ProposalCollaboration"> | string
    email?: StringFilter<"ProposalCollaboration"> | string
    phone?: StringNullableFilter<"ProposalCollaboration"> | string | null
    agencyId?: StringFilter<"ProposalCollaboration"> | string
    proposalOfferId?: StringFilter<"ProposalCollaboration"> | string
    createdAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    proposalOffer?: XOR<ProposalOfferNullableScalarRelationFilter, ProposalOfferWhereInput> | null
  }

  export type ProposalCollaborationOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    proposalOfferId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    proposalOffer?: ProposalOfferOrderByWithRelationInput
    _relevance?: ProposalCollaborationOrderByRelevanceInput
  }

  export type ProposalCollaborationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proposalOfferId?: string
    AND?: ProposalCollaborationWhereInput | ProposalCollaborationWhereInput[]
    OR?: ProposalCollaborationWhereInput[]
    NOT?: ProposalCollaborationWhereInput | ProposalCollaborationWhereInput[]
    clientId?: StringFilter<"ProposalCollaboration"> | string
    title?: StringFilter<"ProposalCollaboration"> | string
    description?: StringFilter<"ProposalCollaboration"> | string
    email?: StringFilter<"ProposalCollaboration"> | string
    phone?: StringNullableFilter<"ProposalCollaboration"> | string | null
    agencyId?: StringFilter<"ProposalCollaboration"> | string
    createdAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    proposalOffer?: XOR<ProposalOfferNullableScalarRelationFilter, ProposalOfferWhereInput> | null
  }, "id" | "proposalOfferId">

  export type ProposalCollaborationOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    proposalOfferId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalCollaborationCountOrderByAggregateInput
    _max?: ProposalCollaborationMaxOrderByAggregateInput
    _min?: ProposalCollaborationMinOrderByAggregateInput
  }

  export type ProposalCollaborationScalarWhereWithAggregatesInput = {
    AND?: ProposalCollaborationScalarWhereWithAggregatesInput | ProposalCollaborationScalarWhereWithAggregatesInput[]
    OR?: ProposalCollaborationScalarWhereWithAggregatesInput[]
    NOT?: ProposalCollaborationScalarWhereWithAggregatesInput | ProposalCollaborationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    clientId?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    title?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    description?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    email?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    phone?: StringNullableWithAggregatesFilter<"ProposalCollaboration"> | string | null
    agencyId?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    proposalOfferId?: StringWithAggregatesFilter<"ProposalCollaboration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProposalCollaboration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProposalCollaboration"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    userId?: StringFilter<"Admin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    location?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    accessToken?: StringNullableFilter<"User"> | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    language?: EnumUserLanguageNullableFilter<"User"> | $Enums.UserLanguage | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clientId?: StringNullableFilter<"User"> | string | null
    agencyId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    ipAddress?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    notifications?: NotificationListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    UserFeatureRequest?: UserFeatureRequestListRelationFilter
    agencyMember?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    ownedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    agencyInvitationSender?: AgencyInvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    location?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrderInput | SortOrder
    agencyId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    agency?: AgencyOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    UserFeatureRequest?: UserFeatureRequestOrderByRelationAggregateInput
    agencyMember?: AgencyMemberOrderByWithRelationInput
    ownedAgency?: AgencyOrderByWithRelationInput
    agencyInvitationSender?: AgencyInvitationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    lastName?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    accessToken?: StringNullableFilter<"User"> | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    language?: EnumUserLanguageNullableFilter<"User"> | $Enums.UserLanguage | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clientId?: StringNullableFilter<"User"> | string | null
    agencyId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    ipAddress?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    notifications?: NotificationListRelationFilter
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    UserFeatureRequest?: UserFeatureRequestListRelationFilter
    agencyMember?: XOR<AgencyMemberNullableScalarRelationFilter, AgencyMemberWhereInput> | null
    ownedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    agencyInvitationSender?: AgencyInvitationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    location?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrderInput | SortOrder
    agencyId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    language?: EnumUserLanguageNullableWithAggregatesFilter<"User"> | $Enums.UserLanguage | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    clientId?: StringNullableWithAggregatesFilter<"User"> | string | null
    agencyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    description?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    recipient?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    description?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    description?: StringWithAggregatesFilter<"Notification"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
  }

  export type UserFeatureRequestWhereInput = {
    AND?: UserFeatureRequestWhereInput | UserFeatureRequestWhereInput[]
    OR?: UserFeatureRequestWhereInput[]
    NOT?: UserFeatureRequestWhereInput | UserFeatureRequestWhereInput[]
    id?: StringFilter<"UserFeatureRequest"> | string
    featureName?: StringFilter<"UserFeatureRequest"> | string
    userId?: StringNullableFilter<"UserFeatureRequest"> | string | null
    createdAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserFeatureRequestOrderByWithRelationInput = {
    id?: SortOrder
    featureName?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserFeatureRequestOrderByRelevanceInput
  }

  export type UserFeatureRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserFeatureRequestWhereInput | UserFeatureRequestWhereInput[]
    OR?: UserFeatureRequestWhereInput[]
    NOT?: UserFeatureRequestWhereInput | UserFeatureRequestWhereInput[]
    featureName?: StringFilter<"UserFeatureRequest"> | string
    userId?: StringNullableFilter<"UserFeatureRequest"> | string | null
    createdAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UserFeatureRequestOrderByWithAggregationInput = {
    id?: SortOrder
    featureName?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserFeatureRequestCountOrderByAggregateInput
    _max?: UserFeatureRequestMaxOrderByAggregateInput
    _min?: UserFeatureRequestMinOrderByAggregateInput
  }

  export type UserFeatureRequestScalarWhereWithAggregatesInput = {
    AND?: UserFeatureRequestScalarWhereWithAggregatesInput | UserFeatureRequestScalarWhereWithAggregatesInput[]
    OR?: UserFeatureRequestScalarWhereWithAggregatesInput[]
    NOT?: UserFeatureRequestScalarWhereWithAggregatesInput | UserFeatureRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFeatureRequest"> | string
    featureName?: StringWithAggregatesFilter<"UserFeatureRequest"> | string
    userId?: StringNullableWithAggregatesFilter<"UserFeatureRequest"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"UserFeatureRequest"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserFeatureRequest"> | Date | string | null
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: PasswordResetTokenOrderByRelevanceInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "email" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AgencyCreateInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesCreateInput = {
    id?: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyClient: AgencyClientCreateNestedOneWithoutMemberNotesInput
    createdByMember: AgencyMemberCreateNestedOneWithoutAgencyClientNotesInput
  }

  export type AgencyClientNotesUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    agencyClientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientNotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyClient?: AgencyClientUpdateOneRequiredWithoutMemberNotesNestedInput
    createdByMember?: AgencyMemberUpdateOneRequiredWithoutAgencyClientNotesNestedInput
  }

  export type AgencyClientNotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    agencyClientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesCreateManyInput = {
    id?: string
    title: string
    description: string
    agencyClientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientNotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    agencyClientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientCreateInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientCreateManyInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientPreferenceCreateInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientPreferenceInput
    agencyClient?: AgencyClientCreateNestedOneWithoutPreferencesInput
  }

  export type AgencyClientPreferenceUncheckedCreateInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    createdById?: string | null
    agencyClientId?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type AgencyClientPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientPreferenceNestedInput
    agencyClient?: AgencyClientUpdateOneWithoutPreferencesNestedInput
  }

  export type AgencyClientPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    agencyClientId?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyClientPreferenceCreateManyInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    createdById?: string | null
    agencyClientId?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type AgencyClientPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyClientPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    agencyClientId?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyMemberCreateInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberCreateManyInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgencyMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyInvitationCreateInput = {
    id?: string
    token: string
    email: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyInvitationInput
    sender: UserCreateNestedOneWithoutAgencyInvitationSenderInput
  }

  export type AgencyInvitationUncheckedCreateInput = {
    id?: string
    token: string
    agencyId: string
    email: string
    senderId: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyInvitationNestedInput
    sender?: UserUpdateOneRequiredWithoutAgencyInvitationSenderNestedInput
  }

  export type AgencyInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyInvitationCreateManyInput = {
    id?: string
    token: string
    agencyId: string
    email: string
    senderId: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySubmissionReviewCreateInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencySubmissionReviewInput
  }

  export type AgencySubmissionReviewUncheckedCreateInput = {
    id?: string
    agencyId: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySubmissionReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencySubmissionReviewNestedInput
  }

  export type AgencySubmissionReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySubmissionReviewCreateManyInput = {
    id?: string
    agencyId: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySubmissionReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySubmissionReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyViewCreateInput = {
    id?: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyViewInput
    client?: ClientCreateNestedOneWithoutAgencyViewInput
  }

  export type AgencyViewUncheckedCreateInput = {
    id?: string
    agencyId: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyViewNestedInput
    client?: ClientUpdateOneWithoutAgencyViewNestedInput
  }

  export type AgencyViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyViewCreateManyInput = {
    id?: string
    agencyId: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyReviewCreateInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agency: AgencyCreateNestedOneWithoutRatingsInput
    client: ClientCreateNestedOneWithoutReviewsInput
  }

  export type AgencyReviewUncheckedCreateInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId: string
    clientId: string
  }

  export type AgencyReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agency?: AgencyUpdateOneRequiredWithoutRatingsNestedInput
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type AgencyReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencyReviewCreateManyInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId: string
    clientId: string
  }

  export type AgencyReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgencyReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentReminderCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    agencyMember: AgencyMemberCreateNestedOneWithoutRemindersInput
  }

  export type AgentReminderUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    agencyMemberId: string
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgentReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyMember?: AgencyMemberUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type AgentReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    agencyMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentReminderCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    agencyMemberId: string
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgentReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    agencyMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientCreateInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientSearchCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    client: ClientCreateNestedOneWithoutClientSearchesInput
    clientPropertySubscription?: ClientPropertySubscriptionCreateNestedOneWithoutClientSearchInput
  }

  export type ClientSearchUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionUncheckedCreateNestedOneWithoutClientSearchInput
  }

  export type ClientSearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientUpdateOneRequiredWithoutClientSearchesNestedInput
    clientPropertySubscription?: ClientPropertySubscriptionUpdateOneWithoutClientSearchNestedInput
  }

  export type ClientSearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionUncheckedUpdateOneWithoutClientSearchNestedInput
  }

  export type ClientSearchCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientSearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientSearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPropertySubscriptionCreateInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientSubscriptionInput
    clientSearch?: ClientSearchCreateNestedOneWithoutClientPropertySubscriptionInput
  }

  export type ClientPropertySubscriptionUncheckedCreateInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    clientSearchId?: string | null
  }

  export type ClientPropertySubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientSubscriptionNestedInput
    clientSearch?: ClientSearchUpdateOneWithoutClientPropertySubscriptionNestedInput
  }

  export type ClientPropertySubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSearchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientPropertySubscriptionCreateManyInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    clientSearchId?: string | null
  }

  export type ClientPropertySubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPropertySubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSearchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SearchQueryCreateInput = {
    id?: string
    location: string
    listingType: $Enums.PropertyListingType
    category: string
    subCategory?: string | null
    priceFrom?: number | null
    priceTo?: number | null
    sizeFrom?: number | null
    sizeTo?: number | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUncheckedCreateInput = {
    id?: string
    location: string
    listingType: $Enums.PropertyListingType
    category: string
    subCategory?: string | null
    priceFrom?: number | null
    priceTo?: number | null
    sizeFrom?: number | null
    sizeTo?: number | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceTo?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFrom?: NullableIntFieldUpdateOperationsInput | number | null
    sizeTo?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceTo?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFrom?: NullableIntFieldUpdateOperationsInput | number | null
    sizeTo?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateManyInput = {
    id?: string
    location: string
    listingType: $Enums.PropertyListingType
    category: string
    subCategory?: string | null
    priceFrom?: number | null
    priceTo?: number | null
    sizeFrom?: number | null
    sizeTo?: number | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceTo?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFrom?: NullableIntFieldUpdateOperationsInput | number | null
    sizeTo?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceTo?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFrom?: NullableIntFieldUpdateOperationsInput | number | null
    sizeTo?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalListingCreateInput = {
    id?: string
    category: $Enums.ExternalListingCategory
    fullName: string
    type: string
    title: string
    description: string
    price: string
    attributes?: string | null
    location: string
    phoneNumber?: string | null
    email?: string | null
    sourceId: string
    sourceName: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalListingUncheckedCreateInput = {
    id?: string
    category: $Enums.ExternalListingCategory
    fullName: string
    type: string
    title: string
    description: string
    price: string
    attributes?: string | null
    location: string
    phoneNumber?: string | null
    email?: string | null
    sourceId: string
    sourceName: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExternalListingCategoryFieldUpdateOperationsInput | $Enums.ExternalListingCategory
    fullName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    attributes?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: StringFieldUpdateOperationsInput | string
    sourceName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExternalListingCategoryFieldUpdateOperationsInput | $Enums.ExternalListingCategory
    fullName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    attributes?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: StringFieldUpdateOperationsInput | string
    sourceName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalListingCreateManyInput = {
    id?: string
    category: $Enums.ExternalListingCategory
    fullName: string
    type: string
    title: string
    description: string
    price: string
    attributes?: string | null
    location: string
    phoneNumber?: string | null
    email?: string | null
    sourceId: string
    sourceName: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExternalListingCategoryFieldUpdateOperationsInput | $Enums.ExternalListingCategory
    fullName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    attributes?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: StringFieldUpdateOperationsInput | string
    sourceName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExternalListingCategoryFieldUpdateOperationsInput | $Enums.ExternalListingCategory
    fullName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    attributes?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: StringFieldUpdateOperationsInput | string
    sourceName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCategoryCreateInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutCategoryInput
    subcategories?: PropertySubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUncheckedCreateInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: PropertySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutCategoryNestedInput
    subcategories?: PropertySubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: PropertySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryCreateManyInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubcategoryCreateInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: PropertyCategoryCreateNestedOneWithoutSubcategoriesInput
    properties?: PropertyCreateNestedManyWithoutSubcategoryInput
  }

  export type PropertySubcategoryUncheckedCreateInput = {
    id: string
    value: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type PropertySubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: PropertyCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    properties?: PropertyUpdateManyWithoutSubcategoryNestedInput
  }

  export type PropertySubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type PropertySubcategoryCreateManyInput = {
    id: string
    value: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyLocationCreateInput = {
    id?: string
    name: string
    parent?: PropertyLocationCreateNestedOneWithoutChildrenInput
    children?: PropertyLocationCreateNestedManyWithoutParentInput
    properties?: PropertyCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationUncheckedCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    children?: PropertyLocationUncheckedCreateNestedManyWithoutParentInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: PropertyLocationUpdateOneWithoutChildrenNestedInput
    children?: PropertyLocationUpdateManyWithoutParentNestedInput
    properties?: PropertyUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: PropertyLocationUncheckedUpdateManyWithoutParentNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationCreateManyInput = {
    id?: string
    name: string
    parentId?: string | null
  }

  export type PropertyLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertySubmissionReviewCreateInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyReviewInput
  }

  export type PropertySubmissionReviewUncheckedCreateInput = {
    id?: string
    propertyId: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyReviewNestedInput
  }

  export type PropertySubmissionReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionReviewCreateManyInput = {
    id?: string
    propertyId: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySaleCreateInput = {
    id?: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
    property: PropertyCreateNestedOneWithoutPropertySaleInput
    agency: AgencyCreateNestedOneWithoutPropertySaleInput
  }

  export type PropertySaleUncheckedCreateInput = {
    id?: string
    propertyId: string
    agencyId: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
  }

  export type PropertySaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
    property?: PropertyUpdateOneRequiredWithoutPropertySaleNestedInput
    agency?: AgencyUpdateOneRequiredWithoutPropertySaleNestedInput
  }

  export type PropertySaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertySaleCreateManyInput = {
    id?: string
    propertyId: string
    agencyId: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
  }

  export type PropertySaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertySaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyViewCreateInput = {
    id?: string
    viewDate?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutViewsInput
    client?: ClientCreateNestedOneWithoutPropertyViewsInput
  }

  export type PropertyViewUncheckedCreateInput = {
    id?: string
    viewDate?: Date | string
    propertyId: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutViewsNestedInput
    client?: ClientUpdateOneWithoutPropertyViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateManyInput = {
    id?: string
    viewDate?: Date | string
    propertyId: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFavoriteCreateInput = {
    id?: string
    favoriteDate: Date | string
    property?: PropertyCreateNestedOneWithoutPropertyFavoriteInput
    client?: ClientCreateNestedOneWithoutFavoritesInput
  }

  export type PropertyFavoriteUncheckedCreateInput = {
    id?: string
    favoriteDate: Date | string
    propertyId?: string | null
    clientId?: string | null
  }

  export type PropertyFavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutPropertyFavoriteNestedInput
    client?: ClientUpdateOneWithoutFavoritesNestedInput
  }

  export type PropertyFavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFavoriteCreateManyInput = {
    id?: string
    favoriteDate: Date | string
    propertyId?: string | null
    clientId?: string | null
  }

  export type PropertyFavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyEngagementCreateInput = {
    id?: string
    type: $Enums.EngagementType
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    property: PropertyCreateNestedOneWithoutPropertyEngagementInput
    client?: ClientCreateNestedOneWithoutPropertyEngagementInput
  }

  export type PropertyEngagementUncheckedCreateInput = {
    id?: string
    propertyId: string
    type: $Enums.EngagementType
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    property?: PropertyUpdateOneRequiredWithoutPropertyEngagementNestedInput
    client?: ClientUpdateOneWithoutPropertyEngagementNestedInput
  }

  export type PropertyEngagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementCreateManyInput = {
    id?: string
    propertyId: string
    type: $Enums.EngagementType
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProposalCreateInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProposalInput
    offers?: ProposalOfferCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: ProposalOfferUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProposalNestedInput
    offers?: ProposalOfferUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: ProposalOfferUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalCreateManyInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalOfferCreateInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutOffersInput
    agency: AgencyCreateNestedOneWithoutProposalOfferInput
    proposalCollaboration?: ProposalCollaborationCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferUncheckedCreateInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    proposalId: string
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutOffersNestedInput
    agency?: AgencyUpdateOneRequiredWithoutProposalOfferNestedInput
    proposalCollaboration?: ProposalCollaborationUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferCreateManyInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    proposalId: string
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCollaborationCreateInput = {
    id?: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProposalCollaborationInput
    proposalOffer?: ProposalOfferCreateNestedOneWithoutProposalCollaborationInput
  }

  export type ProposalCollaborationUncheckedCreateInput = {
    id?: string
    clientId: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    proposalOfferId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCollaborationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProposalCollaborationNestedInput
    proposalOffer?: ProposalOfferUpdateOneWithoutProposalCollaborationNestedInput
  }

  export type ProposalCollaborationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    proposalOfferId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCollaborationCreateManyInput = {
    id?: string
    clientId: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    proposalOfferId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCollaborationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCollaborationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    proposalOfferId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    recipientId: string
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    recipientId: string
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserFeatureRequestCreateInput = {
    id?: string
    featureName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutUserFeatureRequestInput
  }

  export type UserFeatureRequestUncheckedCreateInput = {
    id?: string
    featureName: string
    userId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserFeatureRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutUserFeatureRequestNestedInput
  }

  export type UserFeatureRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeatureRequestCreateManyInput = {
    id?: string
    featureName: string
    userId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserFeatureRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeatureRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    userId: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    userId: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    userId: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAgencyApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyApprovalStatus | EnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel> | $Enums.AgencyApprovalStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAgencyPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyPlan | EnumAgencyPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyPlanFilter<$PrismaModel> | $Enums.AgencyPlan
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AgencyReviewListRelationFilter = {
    every?: AgencyReviewWhereInput
    some?: AgencyReviewWhereInput
    none?: AgencyReviewWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type PropertySaleListRelationFilter = {
    every?: PropertySaleWhereInput
    some?: PropertySaleWhereInput
    none?: PropertySaleWhereInput
  }

  export type AgencyViewListRelationFilter = {
    every?: AgencyViewWhereInput
    some?: AgencyViewWhereInput
    none?: AgencyViewWhereInput
  }

  export type ProposalOfferListRelationFilter = {
    every?: ProposalOfferWhereInput
    some?: ProposalOfferWhereInput
    none?: ProposalOfferWhereInput
  }

  export type AgencySubmissionReviewNullableScalarRelationFilter = {
    is?: AgencySubmissionReviewWhereInput | null
    isNot?: AgencySubmissionReviewWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AgencyMemberListRelationFilter = {
    every?: AgencyMemberWhereInput
    some?: AgencyMemberWhereInput
    none?: AgencyMemberWhereInput
  }

  export type AgencyInvitationListRelationFilter = {
    every?: AgencyInvitationWhereInput
    some?: AgencyInvitationWhereInput
    none?: AgencyInvitationWhereInput
  }

  export type AgencyClientListRelationFilter = {
    every?: AgencyClientWhereInput
    some?: AgencyClientWhereInput
    none?: AgencyClientWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertySaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyOrderByRelevanceInput = {
    fields: AgencyOrderByRelevanceFieldEnum | AgencyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    imotkoApproved?: SortOrder
    plan?: SortOrder
    planUntil?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    social?: SortOrder
    logo?: SortOrder
    credits?: SortOrder
    owner?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    imotkoApproved?: SortOrder
    plan?: SortOrder
    planUntil?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    credits?: SortOrder
    owner?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    imotkoApproved?: SortOrder
    plan?: SortOrder
    planUntil?: SortOrder
    email?: SortOrder
    taxNumber?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    credits?: SortOrder
    owner?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAgencyApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyApprovalStatus | EnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAgencyPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyPlan | EnumAgencyPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyPlanWithAggregatesFilter<$PrismaModel> | $Enums.AgencyPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyPlanFilter<$PrismaModel>
    _max?: NestedEnumAgencyPlanFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AgencyClientScalarRelationFilter = {
    is?: AgencyClientWhereInput
    isNot?: AgencyClientWhereInput
  }

  export type AgencyMemberScalarRelationFilter = {
    is?: AgencyMemberWhereInput
    isNot?: AgencyMemberWhereInput
  }

  export type AgencyClientNotesOrderByRelevanceInput = {
    fields: AgencyClientNotesOrderByRelevanceFieldEnum | AgencyClientNotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyClientNotesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agencyClientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyClientNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agencyClientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyClientNotesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agencyClientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgencyClientStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientStatus | EnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel> | $Enums.AgencyClientStatus | null
  }

  export type AgencyClientNotesListRelationFilter = {
    every?: AgencyClientNotesWhereInput
    some?: AgencyClientNotesWhereInput
    none?: AgencyClientNotesWhereInput
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type AgencyMemberNullableScalarRelationFilter = {
    is?: AgencyMemberWhereInput | null
    isNot?: AgencyMemberWhereInput | null
  }

  export type AgencyClientPreferenceListRelationFilter = {
    every?: AgencyClientPreferenceWhereInput
    some?: AgencyClientPreferenceWhereInput
    none?: AgencyClientPreferenceWhereInput
  }

  export type AgencyClientNotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyClientPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyClientOrderByRelevanceInput = {
    fields: AgencyClientOrderByRelevanceFieldEnum | AgencyClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    location?: SortOrder
    agencyId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    location?: SortOrder
    agencyId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    location?: SortOrder
    agencyId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgencyClientStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientStatus | EnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyClientStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgencyClientStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel>
  }

  export type EnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type EnumPropertyListingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel> | $Enums.PropertyListingType | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAgencyClientPreferenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientPreferenceStatus | EnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel> | $Enums.AgencyClientPreferenceStatus
  }

  export type AgencyClientNullableScalarRelationFilter = {
    is?: AgencyClientWhereInput | null
    isNot?: AgencyClientWhereInput | null
  }

  export type AgencyClientPreferenceOrderByRelevanceInput = {
    fields: AgencyClientPreferenceOrderByRelevanceFieldEnum | AgencyClientPreferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyClientPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    propertyType?: SortOrder
    listingType?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    createdById?: SortOrder
    agencyClientId?: SortOrder
    offeredPropertyIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastOfferSentAt?: SortOrder
  }

  export type AgencyClientPreferenceAvgOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
  }

  export type AgencyClientPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyType?: SortOrder
    listingType?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    createdById?: SortOrder
    agencyClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastOfferSentAt?: SortOrder
  }

  export type AgencyClientPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    propertyType?: SortOrder
    listingType?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    createdById?: SortOrder
    agencyClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastOfferSentAt?: SortOrder
  }

  export type AgencyClientPreferenceSumOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
  }

  export type EnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type EnumPropertyListingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyListingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyListingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAgencyClientPreferenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientPreferenceStatus | EnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyClientPreferenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyClientPreferenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel>
  }

  export type EnumAgencyMemberStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberStatus | EnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel> | $Enums.AgencyMemberStatus | null
  }

  export type EnumAgencyMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberRole | EnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyMemberRoleFilter<$PrismaModel> | $Enums.AgencyMemberRole
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type AgentReminderListRelationFilter = {
    every?: AgentReminderWhereInput
    some?: AgentReminderWhereInput
    none?: AgentReminderWhereInput
  }

  export type AgentReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyMemberOrderByRelevanceInput = {
    fields: AgencyMemberOrderByRelevanceFieldEnum | AgencyMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgencyMemberStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberStatus | EnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyMemberStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgencyMemberStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel>
  }

  export type EnumAgencyMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberRole | EnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.AgencyMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumAgencyMemberRoleFilter<$PrismaModel>
  }

  export type EnumAgencyInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyInvitationStatus | EnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel> | $Enums.AgencyInvitationStatus
  }

  export type AgencyInvitationOrderByRelevanceInput = {
    fields: AgencyInvitationOrderByRelevanceFieldEnum | AgencyInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    agencyId?: SortOrder
    email?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    agencyId?: SortOrder
    email?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    agencyId?: SortOrder
    email?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgencyInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyInvitationStatus | EnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyInvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AgencySubmissionReviewOrderByRelevanceInput = {
    fields: AgencySubmissionReviewOrderByRelevanceFieldEnum | AgencySubmissionReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencySubmissionReviewCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySubmissionReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySubmissionReviewMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type AgencyViewOrderByRelevanceInput = {
    fields: AgencyViewOrderByRelevanceFieldEnum | AgencyViewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyViewCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
    additionalInfo?: SortOrder
    viewDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyViewMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
    viewDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyViewMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
    viewDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type AgencyReviewOrderByRelevanceInput = {
    fields: AgencyReviewOrderByRelevanceFieldEnum | AgencyReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyReviewCountOrderByAggregateInput = {
    id?: SortOrder
    approved?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    attributes?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
  }

  export type AgencyReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AgencyReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    approved?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
  }

  export type AgencyReviewMinOrderByAggregateInput = {
    id?: SortOrder
    approved?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    agencyId?: SortOrder
    clientId?: SortOrder
  }

  export type AgencyReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type AgentReminderOrderByRelevanceInput = {
    fields: AgentReminderOrderByRelevanceFieldEnum | AgentReminderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgentReminderCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    agencyMemberId?: SortOrder
    startDate?: SortOrder
    isRecurring?: SortOrder
    endDate?: SortOrder
    lastSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    agencyMemberId?: SortOrder
    startDate?: SortOrder
    isRecurring?: SortOrder
    endDate?: SortOrder
    lastSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentReminderMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    agencyMemberId?: SortOrder
    startDate?: SortOrder
    isRecurring?: SortOrder
    endDate?: SortOrder
    lastSentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ClientPropertySubscriptionListRelationFilter = {
    every?: ClientPropertySubscriptionWhereInput
    some?: ClientPropertySubscriptionWhereInput
    none?: ClientPropertySubscriptionWhereInput
  }

  export type PropertyFavoriteListRelationFilter = {
    every?: PropertyFavoriteWhereInput
    some?: PropertyFavoriteWhereInput
    none?: PropertyFavoriteWhereInput
  }

  export type PropertyViewListRelationFilter = {
    every?: PropertyViewWhereInput
    some?: PropertyViewWhereInput
    none?: PropertyViewWhereInput
  }

  export type ClientSearchListRelationFilter = {
    every?: ClientSearchWhereInput
    some?: ClientSearchWhereInput
    none?: ClientSearchWhereInput
  }

  export type PropertyEngagementListRelationFilter = {
    every?: PropertyEngagementWhereInput
    some?: PropertyEngagementWhereInput
    none?: PropertyEngagementWhereInput
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type ProposalCollaborationListRelationFilter = {
    every?: ProposalCollaborationWhereInput
    some?: ProposalCollaborationWhereInput
    none?: ProposalCollaborationWhereInput
  }

  export type ClientPropertySubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientSearchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyEngagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalCollaborationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    receiveCompanyEmail?: SortOrder
    receiveCompanySMS?: SortOrder
    receiveAgentEmail?: SortOrder
    receiveAgentSMS?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferences?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    receiveCompanyEmail?: SortOrder
    receiveCompanySMS?: SortOrder
    receiveAgentEmail?: SortOrder
    receiveAgentSMS?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    receiveCompanyEmail?: SortOrder
    receiveCompanySMS?: SortOrder
    receiveAgentEmail?: SortOrder
    receiveAgentSMS?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ClientPropertySubscriptionNullableScalarRelationFilter = {
    is?: ClientPropertySubscriptionWhereInput | null
    isNot?: ClientPropertySubscriptionWhereInput | null
  }

  export type ClientSearchOrderByRelevanceInput = {
    fields: ClientSearchOrderByRelevanceFieldEnum | ClientSearchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientSearchCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    link?: SortOrder
    filters?: SortOrder
    receiveOffers?: SortOrder
    agencyIdsJson?: SortOrder
  }

  export type ClientSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    link?: SortOrder
    receiveOffers?: SortOrder
  }

  export type ClientSearchMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    link?: SortOrder
    receiveOffers?: SortOrder
  }

  export type ClientSearchNullableScalarRelationFilter = {
    is?: ClientSearchWhereInput | null
    isNot?: ClientSearchWhereInput | null
  }

  export type ClientPropertySubscriptionOrderByRelevanceInput = {
    fields: ClientPropertySubscriptionOrderByRelevanceFieldEnum | ClientPropertySubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientPropertySubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    clientSearchId?: SortOrder
  }

  export type ClientPropertySubscriptionAvgOrderByAggregateInput = {
    minSize?: SortOrder
    maxSize?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
  }

  export type ClientPropertySubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    clientSearchId?: SortOrder
  }

  export type ClientPropertySubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    minSize?: SortOrder
    maxSize?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    clientSearchId?: SortOrder
  }

  export type ClientPropertySubscriptionSumOrderByAggregateInput = {
    minSize?: SortOrder
    maxSize?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
  }

  export type EnumPropertyListingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyListingTypeFilter<$PrismaModel> | $Enums.PropertyListingType
  }

  export type SearchQueryOrderByRelevanceInput = {
    fields: SearchQueryOrderByRelevanceFieldEnum | SearchQueryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    priceFrom?: SortOrder
    priceTo?: SortOrder
    sizeFrom?: SortOrder
    sizeTo?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryAvgOrderByAggregateInput = {
    priceFrom?: SortOrder
    priceTo?: SortOrder
    sizeFrom?: SortOrder
    sizeTo?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    priceFrom?: SortOrder
    priceTo?: SortOrder
    sizeFrom?: SortOrder
    sizeTo?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    listingType?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    priceFrom?: SortOrder
    priceTo?: SortOrder
    sizeFrom?: SortOrder
    sizeTo?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQuerySumOrderByAggregateInput = {
    priceFrom?: SortOrder
    priceTo?: SortOrder
    sizeFrom?: SortOrder
    sizeTo?: SortOrder
  }

  export type EnumPropertyListingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyListingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyListingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyListingTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyListingTypeFilter<$PrismaModel>
  }

  export type EnumExternalListingCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalListingCategory | EnumExternalListingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalListingCategoryFilter<$PrismaModel> | $Enums.ExternalListingCategory
  }

  export type ExternalListingOrderByRelevanceInput = {
    fields: ExternalListingOrderByRelevanceFieldEnum | ExternalListingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExternalListingCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    fullName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    attributes?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    sourceId?: SortOrder
    sourceName?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalListingMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    fullName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    attributes?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    sourceId?: SortOrder
    sourceName?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalListingMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    fullName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    attributes?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    sourceId?: SortOrder
    sourceName?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExternalListingCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalListingCategory | EnumExternalListingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalListingCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExternalListingCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalListingCategoryFilter<$PrismaModel>
    _max?: NestedEnumExternalListingCategoryFilter<$PrismaModel>
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type EnumPropertyOrientationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyOrientation | EnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel> | $Enums.PropertyOrientation | null
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type PropertySaleNullableScalarRelationFilter = {
    is?: PropertySaleWhereInput | null
    isNot?: PropertySaleWhereInput | null
  }

  export type PropertySubmissionReviewListRelationFilter = {
    every?: PropertySubmissionReviewWhereInput
    some?: PropertySubmissionReviewWhereInput
    none?: PropertySubmissionReviewWhereInput
  }

  export type PropertyLocationNullableScalarRelationFilter = {
    is?: PropertyLocationWhereInput | null
    isNot?: PropertyLocationWhereInput | null
  }

  export type PropertyCategoryNullableScalarRelationFilter = {
    is?: PropertyCategoryWhereInput | null
    isNot?: PropertyCategoryWhereInput | null
  }

  export type PropertySubcategoryNullableScalarRelationFilter = {
    is?: PropertySubcategoryWhereInput | null
    isNot?: PropertySubcategoryWhereInput | null
  }

  export type PropertySubmissionReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelevanceInput = {
    fields: PropertyOrderByRelevanceFieldEnum | PropertyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    hasApproximatePrice?: SortOrder
    approximatePrice?: SortOrder
    estimationPrice?: SortOrder
    size?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    photos?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByMemberId?: SortOrder
    updatedAt?: SortOrder
    attributes?: SortOrder
    yearBuilt?: SortOrder
    remarks?: SortOrder
    builder?: SortOrder
    propertyCadastralMunicipality?: SortOrder
    propertyDeed?: SortOrder
    inDevelopment?: SortOrder
    inDevelopmentUntil?: SortOrder
    propertyPlan?: SortOrder
    poi?: SortOrder
    featured?: SortOrder
    featuredUntil?: SortOrder
    orientation?: SortOrder
    type?: SortOrder
    listingType?: SortOrder
    propertyLocationId?: SortOrder
    modifications?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    ownerId?: SortOrder
    renterId?: SortOrder
    externalId?: SortOrder
    autoRenewEnabled?: SortOrder
    autoRenewStartDate?: SortOrder
    autoRenewEndDate?: SortOrder
    lastAutoRenewedAt?: SortOrder
    bumpedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    price?: SortOrder
    approximatePrice?: SortOrder
    estimationPrice?: SortOrder
    size?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    hasApproximatePrice?: SortOrder
    approximatePrice?: SortOrder
    estimationPrice?: SortOrder
    size?: SortOrder
    slug?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByMemberId?: SortOrder
    updatedAt?: SortOrder
    yearBuilt?: SortOrder
    remarks?: SortOrder
    builder?: SortOrder
    propertyCadastralMunicipality?: SortOrder
    propertyDeed?: SortOrder
    inDevelopment?: SortOrder
    inDevelopmentUntil?: SortOrder
    featured?: SortOrder
    featuredUntil?: SortOrder
    orientation?: SortOrder
    type?: SortOrder
    listingType?: SortOrder
    propertyLocationId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    ownerId?: SortOrder
    renterId?: SortOrder
    externalId?: SortOrder
    autoRenewEnabled?: SortOrder
    autoRenewStartDate?: SortOrder
    autoRenewEndDate?: SortOrder
    lastAutoRenewedAt?: SortOrder
    bumpedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    hasApproximatePrice?: SortOrder
    approximatePrice?: SortOrder
    estimationPrice?: SortOrder
    size?: SortOrder
    slug?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByMemberId?: SortOrder
    updatedAt?: SortOrder
    yearBuilt?: SortOrder
    remarks?: SortOrder
    builder?: SortOrder
    propertyCadastralMunicipality?: SortOrder
    propertyDeed?: SortOrder
    inDevelopment?: SortOrder
    inDevelopmentUntil?: SortOrder
    featured?: SortOrder
    featuredUntil?: SortOrder
    orientation?: SortOrder
    type?: SortOrder
    listingType?: SortOrder
    propertyLocationId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    ownerId?: SortOrder
    renterId?: SortOrder
    externalId?: SortOrder
    autoRenewEnabled?: SortOrder
    autoRenewStartDate?: SortOrder
    autoRenewEndDate?: SortOrder
    lastAutoRenewedAt?: SortOrder
    bumpedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    price?: SortOrder
    approximatePrice?: SortOrder
    estimationPrice?: SortOrder
    size?: SortOrder
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type EnumPropertyOrientationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyOrientation | EnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyOrientationNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyOrientation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel>
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type PropertySubcategoryListRelationFilter = {
    every?: PropertySubcategoryWhereInput
    some?: PropertySubcategoryWhereInput
    none?: PropertySubcategoryWhereInput
  }

  export type PropertySubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCategoryOrderByRelevanceInput = {
    fields: PropertyCategoryOrderByRelevanceFieldEnum | PropertyCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyCategoryScalarRelationFilter = {
    is?: PropertyCategoryWhereInput
    isNot?: PropertyCategoryWhereInput
  }

  export type PropertySubcategoryOrderByRelevanceInput = {
    fields: PropertySubcategoryOrderByRelevanceFieldEnum | PropertySubcategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertySubcategoryValueCategoryIdCompoundUniqueInput = {
    value: string
    categoryId: string
  }

  export type PropertySubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyLocationListRelationFilter = {
    every?: PropertyLocationWhereInput
    some?: PropertyLocationWhereInput
    none?: PropertyLocationWhereInput
  }

  export type PropertyLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyLocationOrderByRelevanceInput = {
    fields: PropertyLocationOrderByRelevanceFieldEnum | PropertyLocationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyLocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type PropertyLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type PropertyLocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PropertySubmissionReviewOrderByRelevanceInput = {
    fields: PropertySubmissionReviewOrderByRelevanceFieldEnum | PropertySubmissionReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertySubmissionReviewCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionReviewMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySaleOrderByRelevanceInput = {
    fields: PropertySaleOrderByRelevanceFieldEnum | PropertySaleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertySaleCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agencyId?: SortOrder
    propertyDeed?: SortOrder
    soldAt?: SortOrder
    soldFor?: SortOrder
    visibility?: SortOrder
  }

  export type PropertySaleAvgOrderByAggregateInput = {
    soldFor?: SortOrder
  }

  export type PropertySaleMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agencyId?: SortOrder
    propertyDeed?: SortOrder
    soldAt?: SortOrder
    soldFor?: SortOrder
    visibility?: SortOrder
  }

  export type PropertySaleMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agencyId?: SortOrder
    propertyDeed?: SortOrder
    soldAt?: SortOrder
    soldFor?: SortOrder
    visibility?: SortOrder
  }

  export type PropertySaleSumOrderByAggregateInput = {
    soldFor?: SortOrder
  }

  export type PropertyViewOrderByRelevanceInput = {
    fields: PropertyViewOrderByRelevanceFieldEnum | PropertyViewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyViewCountOrderByAggregateInput = {
    id?: SortOrder
    viewDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
    additionalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyViewMaxOrderByAggregateInput = {
    id?: SortOrder
    viewDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyViewMinOrderByAggregateInput = {
    id?: SortOrder
    viewDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type PropertyFavoriteOrderByRelevanceInput = {
    fields: PropertyFavoriteOrderByRelevanceFieldEnum | PropertyFavoriteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    favoriteDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
  }

  export type PropertyFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    favoriteDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
  }

  export type PropertyFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    favoriteDate?: SortOrder
    propertyId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumEngagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeFilter<$PrismaModel> | $Enums.EngagementType
  }

  export type PropertyEngagementOrderByRelevanceInput = {
    fields: PropertyEngagementOrderByRelevanceFieldEnum | PropertyEngagementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyEngagementCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    additionalInfo?: SortOrder
  }

  export type PropertyEngagementMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyEngagementMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEngagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementTypeFilter<$PrismaModel>
  }

  export type EnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type ProposalOrderByRelevanceInput = {
    fields: ProposalOrderByRelevanceFieldEnum | ProposalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    size?: SortOrder
    category?: SortOrder
    listingType?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    size?: SortOrder
    category?: SortOrder
    listingType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    size?: SortOrder
    category?: SortOrder
    listingType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type ProposalScalarRelationFilter = {
    is?: ProposalWhereInput
    isNot?: ProposalWhereInput
  }

  export type ProposalCollaborationNullableScalarRelationFilter = {
    is?: ProposalCollaborationWhereInput | null
    isNot?: ProposalCollaborationWhereInput | null
  }

  export type ProposalOfferOrderByRelevanceInput = {
    fields: ProposalOfferOrderByRelevanceFieldEnum | ProposalOfferOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProposalOfferCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    saleTimeline?: SortOrder
    proposalId?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalOfferAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProposalOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    saleTimeline?: SortOrder
    proposalId?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalOfferMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    saleTimeline?: SortOrder
    proposalId?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalOfferSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProposalOfferNullableScalarRelationFilter = {
    is?: ProposalOfferWhereInput | null
    isNot?: ProposalOfferWhereInput | null
  }

  export type ProposalCollaborationOrderByRelevanceInput = {
    fields: ProposalCollaborationOrderByRelevanceFieldEnum | ProposalCollaborationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProposalCollaborationCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    agencyId?: SortOrder
    proposalOfferId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalCollaborationMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    agencyId?: SortOrder
    proposalOfferId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalCollaborationMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    agencyId?: SortOrder
    proposalOfferId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumUserLanguageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLanguage | EnumUserLanguageFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLanguageNullableFilter<$PrismaModel> | $Enums.UserLanguage | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type UserFeatureRequestListRelationFilter = {
    every?: UserFeatureRequestWhereInput
    some?: UserFeatureRequestWhereInput
    none?: UserFeatureRequestWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFeatureRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    location?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    phone?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    language?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    agencyId?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    location?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    phone?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    language?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    agencyId?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    location?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    phone?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    language?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    agencyId?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserLanguageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLanguage | EnumUserLanguageFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLanguageNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserLanguage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserLanguageNullableFilter<$PrismaModel>
    _max?: NestedEnumUserLanguageNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type UserFeatureRequestOrderByRelevanceInput = {
    fields: UserFeatureRequestOrderByRelevanceFieldEnum | UserFeatureRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserFeatureRequestCountOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFeatureRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFeatureRequestMinOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetTokenOrderByRelevanceInput = {
    fields: PasswordResetTokenOrderByRelevanceFieldEnum | PasswordResetTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type UserCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AgencyReviewCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput> | AgencyReviewCreateWithoutAgencyInput[] | AgencyReviewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutAgencyInput | AgencyReviewCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyReviewCreateManyAgencyInputEnvelope
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutAgencyInput = {
    create?: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput> | PropertyCreateWithoutAgencyInput[] | PropertyUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgencyInput | PropertyCreateOrConnectWithoutAgencyInput[]
    createMany?: PropertyCreateManyAgencyInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertySaleCreateNestedManyWithoutAgencyInput = {
    create?: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput> | PropertySaleCreateWithoutAgencyInput[] | PropertySaleUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertySaleCreateOrConnectWithoutAgencyInput | PropertySaleCreateOrConnectWithoutAgencyInput[]
    createMany?: PropertySaleCreateManyAgencyInputEnvelope
    connect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
  }

  export type AgencyViewCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput> | AgencyViewCreateWithoutAgencyInput[] | AgencyViewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutAgencyInput | AgencyViewCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyViewCreateManyAgencyInputEnvelope
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
  }

  export type ProposalOfferCreateNestedManyWithoutAgencyInput = {
    create?: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput> | ProposalOfferCreateWithoutAgencyInput[] | ProposalOfferUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutAgencyInput | ProposalOfferCreateOrConnectWithoutAgencyInput[]
    createMany?: ProposalOfferCreateManyAgencyInputEnvelope
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
  }

  export type AgencySubmissionReviewCreateNestedOneWithoutAgencyInput = {
    create?: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AgencySubmissionReviewCreateOrConnectWithoutAgencyInput
    connect?: AgencySubmissionReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedAgencyInput = {
    create?: XOR<UserCreateWithoutOwnedAgencyInput, UserUncheckedCreateWithoutOwnedAgencyInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAgencyInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyMemberCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput> | AgencyMemberCreateWithoutAgencyInput[] | AgencyMemberUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyInput | AgencyMemberCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyMemberCreateManyAgencyInputEnvelope
    connect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
  }

  export type AgencyInvitationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput> | AgencyInvitationCreateWithoutAgencyInput[] | AgencyInvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutAgencyInput | AgencyInvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyInvitationCreateManyAgencyInputEnvelope
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
  }

  export type AgencyClientCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput> | AgencyClientCreateWithoutAgencyInput[] | AgencyClientUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutAgencyInput | AgencyClientCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyClientCreateManyAgencyInputEnvelope
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput> | AgencyReviewCreateWithoutAgencyInput[] | AgencyReviewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutAgencyInput | AgencyReviewCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyReviewCreateManyAgencyInputEnvelope
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput> | PropertyCreateWithoutAgencyInput[] | PropertyUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgencyInput | PropertyCreateOrConnectWithoutAgencyInput[]
    createMany?: PropertyCreateManyAgencyInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertySaleUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput> | PropertySaleCreateWithoutAgencyInput[] | PropertySaleUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertySaleCreateOrConnectWithoutAgencyInput | PropertySaleCreateOrConnectWithoutAgencyInput[]
    createMany?: PropertySaleCreateManyAgencyInputEnvelope
    connect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
  }

  export type AgencyViewUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput> | AgencyViewCreateWithoutAgencyInput[] | AgencyViewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutAgencyInput | AgencyViewCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyViewCreateManyAgencyInputEnvelope
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
  }

  export type ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput> | ProposalOfferCreateWithoutAgencyInput[] | ProposalOfferUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutAgencyInput | ProposalOfferCreateOrConnectWithoutAgencyInput[]
    createMany?: ProposalOfferCreateManyAgencyInputEnvelope
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
  }

  export type AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput = {
    create?: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AgencySubmissionReviewCreateOrConnectWithoutAgencyInput
    connect?: AgencySubmissionReviewWhereUniqueInput
  }

  export type AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput> | AgencyMemberCreateWithoutAgencyInput[] | AgencyMemberUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyInput | AgencyMemberCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyMemberCreateManyAgencyInputEnvelope
    connect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
  }

  export type AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput> | AgencyInvitationCreateWithoutAgencyInput[] | AgencyInvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutAgencyInput | AgencyInvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyInvitationCreateManyAgencyInputEnvelope
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
  }

  export type AgencyClientUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput> | AgencyClientCreateWithoutAgencyInput[] | AgencyClientUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutAgencyInput | AgencyClientCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyClientCreateManyAgencyInputEnvelope
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAgencyApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgencyApprovalStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAgencyPlanFieldUpdateOperationsInput = {
    set?: $Enums.AgencyPlan
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AgencyReviewUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput> | AgencyReviewCreateWithoutAgencyInput[] | AgencyReviewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutAgencyInput | AgencyReviewCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyReviewUpsertWithWhereUniqueWithoutAgencyInput | AgencyReviewUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyReviewCreateManyAgencyInputEnvelope
    set?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    disconnect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    delete?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    update?: AgencyReviewUpdateWithWhereUniqueWithoutAgencyInput | AgencyReviewUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyReviewUpdateManyWithWhereWithoutAgencyInput | AgencyReviewUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput> | PropertyCreateWithoutAgencyInput[] | PropertyUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgencyInput | PropertyCreateOrConnectWithoutAgencyInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAgencyInput | PropertyUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: PropertyCreateManyAgencyInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAgencyInput | PropertyUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAgencyInput | PropertyUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertySaleUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput> | PropertySaleCreateWithoutAgencyInput[] | PropertySaleUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertySaleCreateOrConnectWithoutAgencyInput | PropertySaleCreateOrConnectWithoutAgencyInput[]
    upsert?: PropertySaleUpsertWithWhereUniqueWithoutAgencyInput | PropertySaleUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: PropertySaleCreateManyAgencyInputEnvelope
    set?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    disconnect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    delete?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    connect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    update?: PropertySaleUpdateWithWhereUniqueWithoutAgencyInput | PropertySaleUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: PropertySaleUpdateManyWithWhereWithoutAgencyInput | PropertySaleUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: PropertySaleScalarWhereInput | PropertySaleScalarWhereInput[]
  }

  export type AgencyViewUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput> | AgencyViewCreateWithoutAgencyInput[] | AgencyViewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutAgencyInput | AgencyViewCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyViewUpsertWithWhereUniqueWithoutAgencyInput | AgencyViewUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyViewCreateManyAgencyInputEnvelope
    set?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    disconnect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    delete?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    update?: AgencyViewUpdateWithWhereUniqueWithoutAgencyInput | AgencyViewUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyViewUpdateManyWithWhereWithoutAgencyInput | AgencyViewUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
  }

  export type ProposalOfferUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput> | ProposalOfferCreateWithoutAgencyInput[] | ProposalOfferUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutAgencyInput | ProposalOfferCreateOrConnectWithoutAgencyInput[]
    upsert?: ProposalOfferUpsertWithWhereUniqueWithoutAgencyInput | ProposalOfferUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: ProposalOfferCreateManyAgencyInputEnvelope
    set?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    disconnect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    delete?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    update?: ProposalOfferUpdateWithWhereUniqueWithoutAgencyInput | ProposalOfferUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: ProposalOfferUpdateManyWithWhereWithoutAgencyInput | ProposalOfferUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
  }

  export type AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AgencySubmissionReviewCreateOrConnectWithoutAgencyInput
    upsert?: AgencySubmissionReviewUpsertWithoutAgencyInput
    disconnect?: AgencySubmissionReviewWhereInput | boolean
    delete?: AgencySubmissionReviewWhereInput | boolean
    connect?: AgencySubmissionReviewWhereUniqueInput
    update?: XOR<XOR<AgencySubmissionReviewUpdateToOneWithWhereWithoutAgencyInput, AgencySubmissionReviewUpdateWithoutAgencyInput>, AgencySubmissionReviewUncheckedUpdateWithoutAgencyInput>
  }

  export type UserUpdateOneWithoutOwnedAgencyNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAgencyInput, UserUncheckedCreateWithoutOwnedAgencyInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAgencyInput
    upsert?: UserUpsertWithoutOwnedAgencyInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedAgencyInput, UserUpdateWithoutOwnedAgencyInput>, UserUncheckedUpdateWithoutOwnedAgencyInput>
  }

  export type AgencyMemberUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput> | AgencyMemberCreateWithoutAgencyInput[] | AgencyMemberUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyInput | AgencyMemberCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyMemberUpsertWithWhereUniqueWithoutAgencyInput | AgencyMemberUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyMemberCreateManyAgencyInputEnvelope
    set?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    disconnect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    delete?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    connect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    update?: AgencyMemberUpdateWithWhereUniqueWithoutAgencyInput | AgencyMemberUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyMemberUpdateManyWithWhereWithoutAgencyInput | AgencyMemberUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyMemberScalarWhereInput | AgencyMemberScalarWhereInput[]
  }

  export type AgencyInvitationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput> | AgencyInvitationCreateWithoutAgencyInput[] | AgencyInvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutAgencyInput | AgencyInvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyInvitationUpsertWithWhereUniqueWithoutAgencyInput | AgencyInvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyInvitationCreateManyAgencyInputEnvelope
    set?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    disconnect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    delete?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    update?: AgencyInvitationUpdateWithWhereUniqueWithoutAgencyInput | AgencyInvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyInvitationUpdateManyWithWhereWithoutAgencyInput | AgencyInvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
  }

  export type AgencyClientUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput> | AgencyClientCreateWithoutAgencyInput[] | AgencyClientUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutAgencyInput | AgencyClientCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyClientUpsertWithWhereUniqueWithoutAgencyInput | AgencyClientUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyClientCreateManyAgencyInputEnvelope
    set?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    disconnect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    delete?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    update?: AgencyClientUpdateWithWhereUniqueWithoutAgencyInput | AgencyClientUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyClientUpdateManyWithWhereWithoutAgencyInput | AgencyClientUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput> | AgencyReviewCreateWithoutAgencyInput[] | AgencyReviewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutAgencyInput | AgencyReviewCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyReviewUpsertWithWhereUniqueWithoutAgencyInput | AgencyReviewUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyReviewCreateManyAgencyInputEnvelope
    set?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    disconnect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    delete?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    update?: AgencyReviewUpdateWithWhereUniqueWithoutAgencyInput | AgencyReviewUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyReviewUpdateManyWithWhereWithoutAgencyInput | AgencyReviewUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput> | PropertyCreateWithoutAgencyInput[] | PropertyUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgencyInput | PropertyCreateOrConnectWithoutAgencyInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAgencyInput | PropertyUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: PropertyCreateManyAgencyInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAgencyInput | PropertyUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAgencyInput | PropertyUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput> | PropertySaleCreateWithoutAgencyInput[] | PropertySaleUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: PropertySaleCreateOrConnectWithoutAgencyInput | PropertySaleCreateOrConnectWithoutAgencyInput[]
    upsert?: PropertySaleUpsertWithWhereUniqueWithoutAgencyInput | PropertySaleUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: PropertySaleCreateManyAgencyInputEnvelope
    set?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    disconnect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    delete?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    connect?: PropertySaleWhereUniqueInput | PropertySaleWhereUniqueInput[]
    update?: PropertySaleUpdateWithWhereUniqueWithoutAgencyInput | PropertySaleUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: PropertySaleUpdateManyWithWhereWithoutAgencyInput | PropertySaleUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: PropertySaleScalarWhereInput | PropertySaleScalarWhereInput[]
  }

  export type AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput> | AgencyViewCreateWithoutAgencyInput[] | AgencyViewUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutAgencyInput | AgencyViewCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyViewUpsertWithWhereUniqueWithoutAgencyInput | AgencyViewUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyViewCreateManyAgencyInputEnvelope
    set?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    disconnect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    delete?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    update?: AgencyViewUpdateWithWhereUniqueWithoutAgencyInput | AgencyViewUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyViewUpdateManyWithWhereWithoutAgencyInput | AgencyViewUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
  }

  export type ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput> | ProposalOfferCreateWithoutAgencyInput[] | ProposalOfferUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutAgencyInput | ProposalOfferCreateOrConnectWithoutAgencyInput[]
    upsert?: ProposalOfferUpsertWithWhereUniqueWithoutAgencyInput | ProposalOfferUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: ProposalOfferCreateManyAgencyInputEnvelope
    set?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    disconnect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    delete?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    update?: ProposalOfferUpdateWithWhereUniqueWithoutAgencyInput | ProposalOfferUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: ProposalOfferUpdateManyWithWhereWithoutAgencyInput | ProposalOfferUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
  }

  export type AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: AgencySubmissionReviewCreateOrConnectWithoutAgencyInput
    upsert?: AgencySubmissionReviewUpsertWithoutAgencyInput
    disconnect?: AgencySubmissionReviewWhereInput | boolean
    delete?: AgencySubmissionReviewWhereInput | boolean
    connect?: AgencySubmissionReviewWhereUniqueInput
    update?: XOR<XOR<AgencySubmissionReviewUpdateToOneWithWhereWithoutAgencyInput, AgencySubmissionReviewUpdateWithoutAgencyInput>, AgencySubmissionReviewUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput> | AgencyMemberCreateWithoutAgencyInput[] | AgencyMemberUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyInput | AgencyMemberCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyMemberUpsertWithWhereUniqueWithoutAgencyInput | AgencyMemberUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyMemberCreateManyAgencyInputEnvelope
    set?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    disconnect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    delete?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    connect?: AgencyMemberWhereUniqueInput | AgencyMemberWhereUniqueInput[]
    update?: AgencyMemberUpdateWithWhereUniqueWithoutAgencyInput | AgencyMemberUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyMemberUpdateManyWithWhereWithoutAgencyInput | AgencyMemberUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyMemberScalarWhereInput | AgencyMemberScalarWhereInput[]
  }

  export type AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput> | AgencyInvitationCreateWithoutAgencyInput[] | AgencyInvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutAgencyInput | AgencyInvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyInvitationUpsertWithWhereUniqueWithoutAgencyInput | AgencyInvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyInvitationCreateManyAgencyInputEnvelope
    set?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    disconnect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    delete?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    update?: AgencyInvitationUpdateWithWhereUniqueWithoutAgencyInput | AgencyInvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyInvitationUpdateManyWithWhereWithoutAgencyInput | AgencyInvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
  }

  export type AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput> | AgencyClientCreateWithoutAgencyInput[] | AgencyClientUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutAgencyInput | AgencyClientCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyClientUpsertWithWhereUniqueWithoutAgencyInput | AgencyClientUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyClientCreateManyAgencyInputEnvelope
    set?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    disconnect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    delete?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    update?: AgencyClientUpdateWithWhereUniqueWithoutAgencyInput | AgencyClientUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyClientUpdateManyWithWhereWithoutAgencyInput | AgencyClientUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
  }

  export type AgencyClientCreateNestedOneWithoutMemberNotesInput = {
    create?: XOR<AgencyClientCreateWithoutMemberNotesInput, AgencyClientUncheckedCreateWithoutMemberNotesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutMemberNotesInput
    connect?: AgencyClientWhereUniqueInput
  }

  export type AgencyMemberCreateNestedOneWithoutAgencyClientNotesInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientNotesInput, AgencyMemberUncheckedCreateWithoutAgencyClientNotesInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientNotesInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type AgencyClientUpdateOneRequiredWithoutMemberNotesNestedInput = {
    create?: XOR<AgencyClientCreateWithoutMemberNotesInput, AgencyClientUncheckedCreateWithoutMemberNotesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutMemberNotesInput
    upsert?: AgencyClientUpsertWithoutMemberNotesInput
    connect?: AgencyClientWhereUniqueInput
    update?: XOR<XOR<AgencyClientUpdateToOneWithWhereWithoutMemberNotesInput, AgencyClientUpdateWithoutMemberNotesInput>, AgencyClientUncheckedUpdateWithoutMemberNotesInput>
  }

  export type AgencyMemberUpdateOneRequiredWithoutAgencyClientNotesNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientNotesInput, AgencyMemberUncheckedCreateWithoutAgencyClientNotesInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientNotesInput
    upsert?: AgencyMemberUpsertWithoutAgencyClientNotesInput
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutAgencyClientNotesInput, AgencyMemberUpdateWithoutAgencyClientNotesInput>, AgencyMemberUncheckedUpdateWithoutAgencyClientNotesInput>
  }

  export type AgencyClientNotesCreateNestedManyWithoutAgencyClientInput = {
    create?: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput> | AgencyClientNotesCreateWithoutAgencyClientInput[] | AgencyClientNotesUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutAgencyClientInput | AgencyClientNotesCreateOrConnectWithoutAgencyClientInput[]
    createMany?: AgencyClientNotesCreateManyAgencyClientInputEnvelope
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
  }

  export type AgencyCreateNestedOneWithoutAgencyClientInput = {
    create?: XOR<AgencyCreateWithoutAgencyClientInput, AgencyUncheckedCreateWithoutAgencyClientInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyClientInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyMemberCreateNestedOneWithoutAgencyClientInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientInput, AgencyMemberUncheckedCreateWithoutAgencyClientInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput> | AgencyClientPreferenceCreateWithoutAgencyClientInput[] | AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput | AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput[]
    createMany?: AgencyClientPreferenceCreateManyAgencyClientInputEnvelope
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutRenterInput = {
    create?: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput> | PropertyCreateWithoutRenterInput[] | PropertyUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutRenterInput | PropertyCreateOrConnectWithoutRenterInput[]
    createMany?: PropertyCreateManyRenterInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput = {
    create?: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput> | AgencyClientNotesCreateWithoutAgencyClientInput[] | AgencyClientNotesUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutAgencyClientInput | AgencyClientNotesCreateOrConnectWithoutAgencyClientInput[]
    createMany?: AgencyClientNotesCreateManyAgencyClientInputEnvelope
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
  }

  export type AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput> | AgencyClientPreferenceCreateWithoutAgencyClientInput[] | AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput | AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput[]
    createMany?: AgencyClientPreferenceCreateManyAgencyClientInputEnvelope
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutRenterInput = {
    create?: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput> | PropertyCreateWithoutRenterInput[] | PropertyUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutRenterInput | PropertyCreateOrConnectWithoutRenterInput[]
    createMany?: PropertyCreateManyRenterInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type NullableEnumAgencyClientStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgencyClientStatus | null
  }

  export type AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput> | AgencyClientNotesCreateWithoutAgencyClientInput[] | AgencyClientNotesUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutAgencyClientInput | AgencyClientNotesCreateOrConnectWithoutAgencyClientInput[]
    upsert?: AgencyClientNotesUpsertWithWhereUniqueWithoutAgencyClientInput | AgencyClientNotesUpsertWithWhereUniqueWithoutAgencyClientInput[]
    createMany?: AgencyClientNotesCreateManyAgencyClientInputEnvelope
    set?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    disconnect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    delete?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    update?: AgencyClientNotesUpdateWithWhereUniqueWithoutAgencyClientInput | AgencyClientNotesUpdateWithWhereUniqueWithoutAgencyClientInput[]
    updateMany?: AgencyClientNotesUpdateManyWithWhereWithoutAgencyClientInput | AgencyClientNotesUpdateManyWithWhereWithoutAgencyClientInput[]
    deleteMany?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
  }

  export type AgencyUpdateOneRequiredWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyClientInput, AgencyUncheckedCreateWithoutAgencyClientInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyClientInput
    upsert?: AgencyUpsertWithoutAgencyClientInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyClientInput, AgencyUpdateWithoutAgencyClientInput>, AgencyUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyMemberUpdateOneWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientInput, AgencyMemberUncheckedCreateWithoutAgencyClientInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientInput
    upsert?: AgencyMemberUpsertWithoutAgencyClientInput
    disconnect?: AgencyMemberWhereInput | boolean
    delete?: AgencyMemberWhereInput | boolean
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutAgencyClientInput, AgencyMemberUpdateWithoutAgencyClientInput>, AgencyMemberUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput> | AgencyClientPreferenceCreateWithoutAgencyClientInput[] | AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput | AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput[]
    upsert?: AgencyClientPreferenceUpsertWithWhereUniqueWithoutAgencyClientInput | AgencyClientPreferenceUpsertWithWhereUniqueWithoutAgencyClientInput[]
    createMany?: AgencyClientPreferenceCreateManyAgencyClientInputEnvelope
    set?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    disconnect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    delete?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    update?: AgencyClientPreferenceUpdateWithWhereUniqueWithoutAgencyClientInput | AgencyClientPreferenceUpdateWithWhereUniqueWithoutAgencyClientInput[]
    updateMany?: AgencyClientPreferenceUpdateManyWithWhereWithoutAgencyClientInput | AgencyClientPreferenceUpdateManyWithWhereWithoutAgencyClientInput[]
    deleteMany?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutRenterNestedInput = {
    create?: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput> | PropertyCreateWithoutRenterInput[] | PropertyUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutRenterInput | PropertyCreateOrConnectWithoutRenterInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutRenterInput | PropertyUpsertWithWhereUniqueWithoutRenterInput[]
    createMany?: PropertyCreateManyRenterInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutRenterInput | PropertyUpdateWithWhereUniqueWithoutRenterInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutRenterInput | PropertyUpdateManyWithWhereWithoutRenterInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput> | AgencyClientNotesCreateWithoutAgencyClientInput[] | AgencyClientNotesUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutAgencyClientInput | AgencyClientNotesCreateOrConnectWithoutAgencyClientInput[]
    upsert?: AgencyClientNotesUpsertWithWhereUniqueWithoutAgencyClientInput | AgencyClientNotesUpsertWithWhereUniqueWithoutAgencyClientInput[]
    createMany?: AgencyClientNotesCreateManyAgencyClientInputEnvelope
    set?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    disconnect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    delete?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    update?: AgencyClientNotesUpdateWithWhereUniqueWithoutAgencyClientInput | AgencyClientNotesUpdateWithWhereUniqueWithoutAgencyClientInput[]
    updateMany?: AgencyClientNotesUpdateManyWithWhereWithoutAgencyClientInput | AgencyClientNotesUpdateManyWithWhereWithoutAgencyClientInput[]
    deleteMany?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
  }

  export type AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput> | AgencyClientPreferenceCreateWithoutAgencyClientInput[] | AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput | AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput[]
    upsert?: AgencyClientPreferenceUpsertWithWhereUniqueWithoutAgencyClientInput | AgencyClientPreferenceUpsertWithWhereUniqueWithoutAgencyClientInput[]
    createMany?: AgencyClientPreferenceCreateManyAgencyClientInputEnvelope
    set?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    disconnect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    delete?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    update?: AgencyClientPreferenceUpdateWithWhereUniqueWithoutAgencyClientInput | AgencyClientPreferenceUpdateWithWhereUniqueWithoutAgencyClientInput[]
    updateMany?: AgencyClientPreferenceUpdateManyWithWhereWithoutAgencyClientInput | AgencyClientPreferenceUpdateManyWithWhereWithoutAgencyClientInput[]
    deleteMany?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutRenterNestedInput = {
    create?: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput> | PropertyCreateWithoutRenterInput[] | PropertyUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutRenterInput | PropertyCreateOrConnectWithoutRenterInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutRenterInput | PropertyUpsertWithWhereUniqueWithoutRenterInput[]
    createMany?: PropertyCreateManyRenterInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutRenterInput | PropertyUpdateWithWhereUniqueWithoutRenterInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutRenterInput | PropertyUpdateManyWithWhereWithoutRenterInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgencyClientPreferenceCreateofferedPropertyIdsInput = {
    set: string[]
  }

  export type AgencyMemberCreateNestedOneWithoutAgencyClientPreferenceInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedCreateWithoutAgencyClientPreferenceInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientPreferenceInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type AgencyClientCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<AgencyClientCreateWithoutPreferencesInput, AgencyClientUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutPreferencesInput
    connect?: AgencyClientWhereUniqueInput
  }

  export type NullableEnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType | null
  }

  export type NullableEnumPropertyListingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyListingType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgencyClientPreferenceUpdateofferedPropertyIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgencyClientPreferenceStatus
  }

  export type AgencyMemberUpdateOneWithoutAgencyClientPreferenceNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedCreateWithoutAgencyClientPreferenceInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutAgencyClientPreferenceInput
    upsert?: AgencyMemberUpsertWithoutAgencyClientPreferenceInput
    disconnect?: AgencyMemberWhereInput | boolean
    delete?: AgencyMemberWhereInput | boolean
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutAgencyClientPreferenceInput, AgencyMemberUpdateWithoutAgencyClientPreferenceInput>, AgencyMemberUncheckedUpdateWithoutAgencyClientPreferenceInput>
  }

  export type AgencyClientUpdateOneWithoutPreferencesNestedInput = {
    create?: XOR<AgencyClientCreateWithoutPreferencesInput, AgencyClientUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutPreferencesInput
    upsert?: AgencyClientUpsertWithoutPreferencesInput
    disconnect?: AgencyClientWhereInput | boolean
    delete?: AgencyClientWhereInput | boolean
    connect?: AgencyClientWhereUniqueInput
    update?: XOR<XOR<AgencyClientUpdateToOneWithWhereWithoutPreferencesInput, AgencyClientUpdateWithoutPreferencesInput>, AgencyClientUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutAgencyMemberInput = {
    create?: XOR<UserCreateWithoutAgencyMemberInput, UserUncheckedCreateWithoutAgencyMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyMemberInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgencyMembersInput = {
    create?: XOR<AgencyCreateWithoutAgencyMembersInput, AgencyUncheckedCreateWithoutAgencyMembersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyMembersInput
    connect?: AgencyWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutCreatedByMemberInput = {
    create?: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput> | PropertyCreateWithoutCreatedByMemberInput[] | PropertyUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCreatedByMemberInput | PropertyCreateOrConnectWithoutCreatedByMemberInput[]
    createMany?: PropertyCreateManyCreatedByMemberInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput = {
    create?: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput> | AgencyClientNotesCreateWithoutCreatedByMemberInput[] | AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput | AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput[]
    createMany?: AgencyClientNotesCreateManyCreatedByMemberInputEnvelope
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
  }

  export type AgencyClientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput> | AgencyClientCreateWithoutCreatedByInput[] | AgencyClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutCreatedByInput | AgencyClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyClientCreateManyCreatedByInputEnvelope
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
  }

  export type AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput> | AgencyClientPreferenceCreateWithoutCreatedByInput[] | AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput | AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyClientPreferenceCreateManyCreatedByInputEnvelope
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
  }

  export type AgentReminderCreateNestedManyWithoutAgencyMemberInput = {
    create?: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput> | AgentReminderCreateWithoutAgencyMemberInput[] | AgentReminderUncheckedCreateWithoutAgencyMemberInput[]
    connectOrCreate?: AgentReminderCreateOrConnectWithoutAgencyMemberInput | AgentReminderCreateOrConnectWithoutAgencyMemberInput[]
    createMany?: AgentReminderCreateManyAgencyMemberInputEnvelope
    connect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput = {
    create?: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput> | PropertyCreateWithoutCreatedByMemberInput[] | PropertyUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCreatedByMemberInput | PropertyCreateOrConnectWithoutCreatedByMemberInput[]
    createMany?: PropertyCreateManyCreatedByMemberInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput = {
    create?: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput> | AgencyClientNotesCreateWithoutCreatedByMemberInput[] | AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput | AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput[]
    createMany?: AgencyClientNotesCreateManyCreatedByMemberInputEnvelope
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
  }

  export type AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput> | AgencyClientCreateWithoutCreatedByInput[] | AgencyClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutCreatedByInput | AgencyClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyClientCreateManyCreatedByInputEnvelope
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
  }

  export type AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput> | AgencyClientPreferenceCreateWithoutCreatedByInput[] | AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput | AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput[]
    createMany?: AgencyClientPreferenceCreateManyCreatedByInputEnvelope
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
  }

  export type AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput = {
    create?: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput> | AgentReminderCreateWithoutAgencyMemberInput[] | AgentReminderUncheckedCreateWithoutAgencyMemberInput[]
    connectOrCreate?: AgentReminderCreateOrConnectWithoutAgencyMemberInput | AgentReminderCreateOrConnectWithoutAgencyMemberInput[]
    createMany?: AgentReminderCreateManyAgencyMemberInputEnvelope
    connect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
  }

  export type NullableEnumAgencyMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgencyMemberStatus | null
  }

  export type EnumAgencyMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.AgencyMemberRole
  }

  export type UserUpdateOneRequiredWithoutAgencyMemberNestedInput = {
    create?: XOR<UserCreateWithoutAgencyMemberInput, UserUncheckedCreateWithoutAgencyMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyMemberInput
    upsert?: UserUpsertWithoutAgencyMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyMemberInput, UserUpdateWithoutAgencyMemberInput>, UserUncheckedUpdateWithoutAgencyMemberInput>
  }

  export type AgencyUpdateOneWithoutAgencyMembersNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyMembersInput, AgencyUncheckedCreateWithoutAgencyMembersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyMembersInput
    upsert?: AgencyUpsertWithoutAgencyMembersInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyMembersInput, AgencyUpdateWithoutAgencyMembersInput>, AgencyUncheckedUpdateWithoutAgencyMembersInput>
  }

  export type PropertyUpdateManyWithoutCreatedByMemberNestedInput = {
    create?: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput> | PropertyCreateWithoutCreatedByMemberInput[] | PropertyUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCreatedByMemberInput | PropertyCreateOrConnectWithoutCreatedByMemberInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCreatedByMemberInput | PropertyUpsertWithWhereUniqueWithoutCreatedByMemberInput[]
    createMany?: PropertyCreateManyCreatedByMemberInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCreatedByMemberInput | PropertyUpdateWithWhereUniqueWithoutCreatedByMemberInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCreatedByMemberInput | PropertyUpdateManyWithWhereWithoutCreatedByMemberInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput = {
    create?: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput> | AgencyClientNotesCreateWithoutCreatedByMemberInput[] | AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput | AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput[]
    upsert?: AgencyClientNotesUpsertWithWhereUniqueWithoutCreatedByMemberInput | AgencyClientNotesUpsertWithWhereUniqueWithoutCreatedByMemberInput[]
    createMany?: AgencyClientNotesCreateManyCreatedByMemberInputEnvelope
    set?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    disconnect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    delete?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    update?: AgencyClientNotesUpdateWithWhereUniqueWithoutCreatedByMemberInput | AgencyClientNotesUpdateWithWhereUniqueWithoutCreatedByMemberInput[]
    updateMany?: AgencyClientNotesUpdateManyWithWhereWithoutCreatedByMemberInput | AgencyClientNotesUpdateManyWithWhereWithoutCreatedByMemberInput[]
    deleteMany?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
  }

  export type AgencyClientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput> | AgencyClientCreateWithoutCreatedByInput[] | AgencyClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutCreatedByInput | AgencyClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyClientUpsertWithWhereUniqueWithoutCreatedByInput | AgencyClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyClientCreateManyCreatedByInputEnvelope
    set?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    disconnect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    delete?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    update?: AgencyClientUpdateWithWhereUniqueWithoutCreatedByInput | AgencyClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyClientUpdateManyWithWhereWithoutCreatedByInput | AgencyClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
  }

  export type AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput> | AgencyClientPreferenceCreateWithoutCreatedByInput[] | AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput | AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyClientPreferenceUpsertWithWhereUniqueWithoutCreatedByInput | AgencyClientPreferenceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyClientPreferenceCreateManyCreatedByInputEnvelope
    set?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    disconnect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    delete?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    update?: AgencyClientPreferenceUpdateWithWhereUniqueWithoutCreatedByInput | AgencyClientPreferenceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyClientPreferenceUpdateManyWithWhereWithoutCreatedByInput | AgencyClientPreferenceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
  }

  export type AgentReminderUpdateManyWithoutAgencyMemberNestedInput = {
    create?: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput> | AgentReminderCreateWithoutAgencyMemberInput[] | AgentReminderUncheckedCreateWithoutAgencyMemberInput[]
    connectOrCreate?: AgentReminderCreateOrConnectWithoutAgencyMemberInput | AgentReminderCreateOrConnectWithoutAgencyMemberInput[]
    upsert?: AgentReminderUpsertWithWhereUniqueWithoutAgencyMemberInput | AgentReminderUpsertWithWhereUniqueWithoutAgencyMemberInput[]
    createMany?: AgentReminderCreateManyAgencyMemberInputEnvelope
    set?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    disconnect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    delete?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    connect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    update?: AgentReminderUpdateWithWhereUniqueWithoutAgencyMemberInput | AgentReminderUpdateWithWhereUniqueWithoutAgencyMemberInput[]
    updateMany?: AgentReminderUpdateManyWithWhereWithoutAgencyMemberInput | AgentReminderUpdateManyWithWhereWithoutAgencyMemberInput[]
    deleteMany?: AgentReminderScalarWhereInput | AgentReminderScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput = {
    create?: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput> | PropertyCreateWithoutCreatedByMemberInput[] | PropertyUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCreatedByMemberInput | PropertyCreateOrConnectWithoutCreatedByMemberInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCreatedByMemberInput | PropertyUpsertWithWhereUniqueWithoutCreatedByMemberInput[]
    createMany?: PropertyCreateManyCreatedByMemberInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCreatedByMemberInput | PropertyUpdateWithWhereUniqueWithoutCreatedByMemberInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCreatedByMemberInput | PropertyUpdateManyWithWhereWithoutCreatedByMemberInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput = {
    create?: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput> | AgencyClientNotesCreateWithoutCreatedByMemberInput[] | AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput[]
    connectOrCreate?: AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput | AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput[]
    upsert?: AgencyClientNotesUpsertWithWhereUniqueWithoutCreatedByMemberInput | AgencyClientNotesUpsertWithWhereUniqueWithoutCreatedByMemberInput[]
    createMany?: AgencyClientNotesCreateManyCreatedByMemberInputEnvelope
    set?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    disconnect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    delete?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    connect?: AgencyClientNotesWhereUniqueInput | AgencyClientNotesWhereUniqueInput[]
    update?: AgencyClientNotesUpdateWithWhereUniqueWithoutCreatedByMemberInput | AgencyClientNotesUpdateWithWhereUniqueWithoutCreatedByMemberInput[]
    updateMany?: AgencyClientNotesUpdateManyWithWhereWithoutCreatedByMemberInput | AgencyClientNotesUpdateManyWithWhereWithoutCreatedByMemberInput[]
    deleteMany?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
  }

  export type AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput> | AgencyClientCreateWithoutCreatedByInput[] | AgencyClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientCreateOrConnectWithoutCreatedByInput | AgencyClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyClientUpsertWithWhereUniqueWithoutCreatedByInput | AgencyClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyClientCreateManyCreatedByInputEnvelope
    set?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    disconnect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    delete?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    connect?: AgencyClientWhereUniqueInput | AgencyClientWhereUniqueInput[]
    update?: AgencyClientUpdateWithWhereUniqueWithoutCreatedByInput | AgencyClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyClientUpdateManyWithWhereWithoutCreatedByInput | AgencyClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
  }

  export type AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput> | AgencyClientPreferenceCreateWithoutCreatedByInput[] | AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput | AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput[]
    upsert?: AgencyClientPreferenceUpsertWithWhereUniqueWithoutCreatedByInput | AgencyClientPreferenceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AgencyClientPreferenceCreateManyCreatedByInputEnvelope
    set?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    disconnect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    delete?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    connect?: AgencyClientPreferenceWhereUniqueInput | AgencyClientPreferenceWhereUniqueInput[]
    update?: AgencyClientPreferenceUpdateWithWhereUniqueWithoutCreatedByInput | AgencyClientPreferenceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AgencyClientPreferenceUpdateManyWithWhereWithoutCreatedByInput | AgencyClientPreferenceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
  }

  export type AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput = {
    create?: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput> | AgentReminderCreateWithoutAgencyMemberInput[] | AgentReminderUncheckedCreateWithoutAgencyMemberInput[]
    connectOrCreate?: AgentReminderCreateOrConnectWithoutAgencyMemberInput | AgentReminderCreateOrConnectWithoutAgencyMemberInput[]
    upsert?: AgentReminderUpsertWithWhereUniqueWithoutAgencyMemberInput | AgentReminderUpsertWithWhereUniqueWithoutAgencyMemberInput[]
    createMany?: AgentReminderCreateManyAgencyMemberInputEnvelope
    set?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    disconnect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    delete?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    connect?: AgentReminderWhereUniqueInput | AgentReminderWhereUniqueInput[]
    update?: AgentReminderUpdateWithWhereUniqueWithoutAgencyMemberInput | AgentReminderUpdateWithWhereUniqueWithoutAgencyMemberInput[]
    updateMany?: AgentReminderUpdateManyWithWhereWithoutAgencyMemberInput | AgentReminderUpdateManyWithWhereWithoutAgencyMemberInput[]
    deleteMany?: AgentReminderScalarWhereInput | AgentReminderScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutAgencyInvitationInput = {
    create?: XOR<AgencyCreateWithoutAgencyInvitationInput, AgencyUncheckedCreateWithoutAgencyInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyInvitationInput
    connect?: AgencyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgencyInvitationSenderInput = {
    create?: XOR<UserCreateWithoutAgencyInvitationSenderInput, UserUncheckedCreateWithoutAgencyInvitationSenderInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInvitationSenderInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAgencyInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgencyInvitationStatus
  }

  export type AgencyUpdateOneRequiredWithoutAgencyInvitationNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyInvitationInput, AgencyUncheckedCreateWithoutAgencyInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyInvitationInput
    upsert?: AgencyUpsertWithoutAgencyInvitationInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyInvitationInput, AgencyUpdateWithoutAgencyInvitationInput>, AgencyUncheckedUpdateWithoutAgencyInvitationInput>
  }

  export type UserUpdateOneRequiredWithoutAgencyInvitationSenderNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInvitationSenderInput, UserUncheckedCreateWithoutAgencyInvitationSenderInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInvitationSenderInput
    upsert?: UserUpsertWithoutAgencyInvitationSenderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyInvitationSenderInput, UserUpdateWithoutAgencyInvitationSenderInput>, UserUncheckedUpdateWithoutAgencyInvitationSenderInput>
  }

  export type AgencyCreateNestedOneWithoutAgencySubmissionReviewInput = {
    create?: XOR<AgencyCreateWithoutAgencySubmissionReviewInput, AgencyUncheckedCreateWithoutAgencySubmissionReviewInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencySubmissionReviewInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutAgencySubmissionReviewNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencySubmissionReviewInput, AgencyUncheckedCreateWithoutAgencySubmissionReviewInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencySubmissionReviewInput
    upsert?: AgencyUpsertWithoutAgencySubmissionReviewInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencySubmissionReviewInput, AgencyUpdateWithoutAgencySubmissionReviewInput>, AgencyUncheckedUpdateWithoutAgencySubmissionReviewInput>
  }

  export type AgencyCreateNestedOneWithoutAgencyViewInput = {
    create?: XOR<AgencyCreateWithoutAgencyViewInput, AgencyUncheckedCreateWithoutAgencyViewInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyViewInput
    connect?: AgencyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAgencyViewInput = {
    create?: XOR<ClientCreateWithoutAgencyViewInput, ClientUncheckedCreateWithoutAgencyViewInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAgencyViewInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutAgencyViewNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyViewInput, AgencyUncheckedCreateWithoutAgencyViewInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyViewInput
    upsert?: AgencyUpsertWithoutAgencyViewInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyViewInput, AgencyUpdateWithoutAgencyViewInput>, AgencyUncheckedUpdateWithoutAgencyViewInput>
  }

  export type ClientUpdateOneWithoutAgencyViewNestedInput = {
    create?: XOR<ClientCreateWithoutAgencyViewInput, ClientUncheckedCreateWithoutAgencyViewInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAgencyViewInput
    upsert?: ClientUpsertWithoutAgencyViewInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAgencyViewInput, ClientUpdateWithoutAgencyViewInput>, ClientUncheckedUpdateWithoutAgencyViewInput>
  }

  export type AgencyCreateNestedOneWithoutRatingsInput = {
    create?: XOR<AgencyCreateWithoutRatingsInput, AgencyUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRatingsInput
    connect?: AgencyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    connect?: ClientWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgencyUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<AgencyCreateWithoutRatingsInput, AgencyUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRatingsInput
    upsert?: AgencyUpsertWithoutRatingsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutRatingsInput, AgencyUpdateWithoutRatingsInput>, AgencyUncheckedUpdateWithoutRatingsInput>
  }

  export type ClientUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    upsert?: ClientUpsertWithoutReviewsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReviewsInput, ClientUpdateWithoutReviewsInput>, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type AgencyMemberCreateNestedOneWithoutRemindersInput = {
    create?: XOR<AgencyMemberCreateWithoutRemindersInput, AgencyMemberUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutRemindersInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type EnumReminderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReminderStatus
  }

  export type AgencyMemberUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutRemindersInput, AgencyMemberUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutRemindersInput
    upsert?: AgencyMemberUpsertWithoutRemindersInput
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutRemindersInput, AgencyMemberUpdateWithoutRemindersInput>, AgencyMemberUncheckedUpdateWithoutRemindersInput>
  }

  export type ClientPropertySubscriptionCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput> | ClientPropertySubscriptionCreateWithoutClientInput[] | ClientPropertySubscriptionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientInput | ClientPropertySubscriptionCreateOrConnectWithoutClientInput[]
    createMany?: ClientPropertySubscriptionCreateManyClientInputEnvelope
    connect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
  }

  export type PropertyFavoriteCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput> | PropertyFavoriteCreateWithoutClientInput[] | PropertyFavoriteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutClientInput | PropertyFavoriteCreateOrConnectWithoutClientInput[]
    createMany?: PropertyFavoriteCreateManyClientInputEnvelope
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput> | PropertyViewCreateWithoutClientInput[] | PropertyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutClientInput | PropertyViewCreateOrConnectWithoutClientInput[]
    createMany?: PropertyViewCreateManyClientInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type ClientSearchCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput> | ClientSearchCreateWithoutClientInput[] | ClientSearchUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientInput | ClientSearchCreateOrConnectWithoutClientInput[]
    createMany?: ClientSearchCreateManyClientInputEnvelope
    connect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
  }

  export type AgencyReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput> | AgencyReviewCreateWithoutClientInput[] | AgencyReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutClientInput | AgencyReviewCreateOrConnectWithoutClientInput[]
    createMany?: AgencyReviewCreateManyClientInputEnvelope
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyViewCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput> | AgencyViewCreateWithoutClientInput[] | AgencyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutClientInput | AgencyViewCreateOrConnectWithoutClientInput[]
    createMany?: AgencyViewCreateManyClientInputEnvelope
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
  }

  export type PropertyEngagementCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput> | PropertyEngagementCreateWithoutClientInput[] | PropertyEngagementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutClientInput | PropertyEngagementCreateOrConnectWithoutClientInput[]
    createMany?: PropertyEngagementCreateManyClientInputEnvelope
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutClientInput = {
    create?: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput> | ProposalCreateWithoutClientInput[] | ProposalUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutClientInput | ProposalCreateOrConnectWithoutClientInput[]
    createMany?: ProposalCreateManyClientInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProposalCollaborationCreateNestedManyWithoutClientInput = {
    create?: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput> | ProposalCollaborationCreateWithoutClientInput[] | ProposalCollaborationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutClientInput | ProposalCollaborationCreateOrConnectWithoutClientInput[]
    createMany?: ProposalCollaborationCreateManyClientInputEnvelope
    connect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
  }

  export type ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput> | ClientPropertySubscriptionCreateWithoutClientInput[] | ClientPropertySubscriptionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientInput | ClientPropertySubscriptionCreateOrConnectWithoutClientInput[]
    createMany?: ClientPropertySubscriptionCreateManyClientInputEnvelope
    connect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
  }

  export type PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput> | PropertyFavoriteCreateWithoutClientInput[] | PropertyFavoriteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutClientInput | PropertyFavoriteCreateOrConnectWithoutClientInput[]
    createMany?: PropertyFavoriteCreateManyClientInputEnvelope
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput> | PropertyViewCreateWithoutClientInput[] | PropertyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutClientInput | PropertyViewCreateOrConnectWithoutClientInput[]
    createMany?: PropertyViewCreateManyClientInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type ClientSearchUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput> | ClientSearchCreateWithoutClientInput[] | ClientSearchUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientInput | ClientSearchCreateOrConnectWithoutClientInput[]
    createMany?: ClientSearchCreateManyClientInputEnvelope
    connect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
  }

  export type AgencyReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput> | AgencyReviewCreateWithoutClientInput[] | AgencyReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutClientInput | AgencyReviewCreateOrConnectWithoutClientInput[]
    createMany?: AgencyReviewCreateManyClientInputEnvelope
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
  }

  export type AgencyViewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput> | AgencyViewCreateWithoutClientInput[] | AgencyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutClientInput | AgencyViewCreateOrConnectWithoutClientInput[]
    createMany?: AgencyViewCreateManyClientInputEnvelope
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
  }

  export type PropertyEngagementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput> | PropertyEngagementCreateWithoutClientInput[] | PropertyEngagementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutClientInput | PropertyEngagementCreateOrConnectWithoutClientInput[]
    createMany?: PropertyEngagementCreateManyClientInputEnvelope
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput> | ProposalCreateWithoutClientInput[] | ProposalUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutClientInput | ProposalCreateOrConnectWithoutClientInput[]
    createMany?: ProposalCreateManyClientInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput> | ProposalCollaborationCreateWithoutClientInput[] | ProposalCollaborationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutClientInput | ProposalCollaborationCreateOrConnectWithoutClientInput[]
    createMany?: ProposalCollaborationCreateManyClientInputEnvelope
    connect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ClientPropertySubscriptionUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput> | ClientPropertySubscriptionCreateWithoutClientInput[] | ClientPropertySubscriptionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientInput | ClientPropertySubscriptionCreateOrConnectWithoutClientInput[]
    upsert?: ClientPropertySubscriptionUpsertWithWhereUniqueWithoutClientInput | ClientPropertySubscriptionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPropertySubscriptionCreateManyClientInputEnvelope
    set?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    disconnect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    delete?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    connect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    update?: ClientPropertySubscriptionUpdateWithWhereUniqueWithoutClientInput | ClientPropertySubscriptionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPropertySubscriptionUpdateManyWithWhereWithoutClientInput | ClientPropertySubscriptionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPropertySubscriptionScalarWhereInput | ClientPropertySubscriptionScalarWhereInput[]
  }

  export type PropertyFavoriteUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput> | PropertyFavoriteCreateWithoutClientInput[] | PropertyFavoriteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutClientInput | PropertyFavoriteCreateOrConnectWithoutClientInput[]
    upsert?: PropertyFavoriteUpsertWithWhereUniqueWithoutClientInput | PropertyFavoriteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyFavoriteCreateManyClientInputEnvelope
    set?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    disconnect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    delete?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    update?: PropertyFavoriteUpdateWithWhereUniqueWithoutClientInput | PropertyFavoriteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyFavoriteUpdateManyWithWhereWithoutClientInput | PropertyFavoriteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput> | PropertyViewCreateWithoutClientInput[] | PropertyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutClientInput | PropertyViewCreateOrConnectWithoutClientInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutClientInput | PropertyViewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyViewCreateManyClientInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutClientInput | PropertyViewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutClientInput | PropertyViewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type ClientSearchUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput> | ClientSearchCreateWithoutClientInput[] | ClientSearchUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientInput | ClientSearchCreateOrConnectWithoutClientInput[]
    upsert?: ClientSearchUpsertWithWhereUniqueWithoutClientInput | ClientSearchUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSearchCreateManyClientInputEnvelope
    set?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    disconnect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    delete?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    connect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    update?: ClientSearchUpdateWithWhereUniqueWithoutClientInput | ClientSearchUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSearchUpdateManyWithWhereWithoutClientInput | ClientSearchUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSearchScalarWhereInput | ClientSearchScalarWhereInput[]
  }

  export type AgencyReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput> | AgencyReviewCreateWithoutClientInput[] | AgencyReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutClientInput | AgencyReviewCreateOrConnectWithoutClientInput[]
    upsert?: AgencyReviewUpsertWithWhereUniqueWithoutClientInput | AgencyReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyReviewCreateManyClientInputEnvelope
    set?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    disconnect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    delete?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    update?: AgencyReviewUpdateWithWhereUniqueWithoutClientInput | AgencyReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyReviewUpdateManyWithWhereWithoutClientInput | AgencyReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type AgencyViewUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput> | AgencyViewCreateWithoutClientInput[] | AgencyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutClientInput | AgencyViewCreateOrConnectWithoutClientInput[]
    upsert?: AgencyViewUpsertWithWhereUniqueWithoutClientInput | AgencyViewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyViewCreateManyClientInputEnvelope
    set?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    disconnect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    delete?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    update?: AgencyViewUpdateWithWhereUniqueWithoutClientInput | AgencyViewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyViewUpdateManyWithWhereWithoutClientInput | AgencyViewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
  }

  export type PropertyEngagementUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput> | PropertyEngagementCreateWithoutClientInput[] | PropertyEngagementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutClientInput | PropertyEngagementCreateOrConnectWithoutClientInput[]
    upsert?: PropertyEngagementUpsertWithWhereUniqueWithoutClientInput | PropertyEngagementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyEngagementCreateManyClientInputEnvelope
    set?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    disconnect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    delete?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    update?: PropertyEngagementUpdateWithWhereUniqueWithoutClientInput | PropertyEngagementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyEngagementUpdateManyWithWhereWithoutClientInput | PropertyEngagementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput> | ProposalCreateWithoutClientInput[] | ProposalUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutClientInput | ProposalCreateOrConnectWithoutClientInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutClientInput | ProposalUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProposalCreateManyClientInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutClientInput | ProposalUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutClientInput | ProposalUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProposalCollaborationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput> | ProposalCollaborationCreateWithoutClientInput[] | ProposalCollaborationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutClientInput | ProposalCollaborationCreateOrConnectWithoutClientInput[]
    upsert?: ProposalCollaborationUpsertWithWhereUniqueWithoutClientInput | ProposalCollaborationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProposalCollaborationCreateManyClientInputEnvelope
    set?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    disconnect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    delete?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    connect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    update?: ProposalCollaborationUpdateWithWhereUniqueWithoutClientInput | ProposalCollaborationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProposalCollaborationUpdateManyWithWhereWithoutClientInput | ProposalCollaborationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProposalCollaborationScalarWhereInput | ProposalCollaborationScalarWhereInput[]
  }

  export type ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput> | ClientPropertySubscriptionCreateWithoutClientInput[] | ClientPropertySubscriptionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientInput | ClientPropertySubscriptionCreateOrConnectWithoutClientInput[]
    upsert?: ClientPropertySubscriptionUpsertWithWhereUniqueWithoutClientInput | ClientPropertySubscriptionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPropertySubscriptionCreateManyClientInputEnvelope
    set?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    disconnect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    delete?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    connect?: ClientPropertySubscriptionWhereUniqueInput | ClientPropertySubscriptionWhereUniqueInput[]
    update?: ClientPropertySubscriptionUpdateWithWhereUniqueWithoutClientInput | ClientPropertySubscriptionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPropertySubscriptionUpdateManyWithWhereWithoutClientInput | ClientPropertySubscriptionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPropertySubscriptionScalarWhereInput | ClientPropertySubscriptionScalarWhereInput[]
  }

  export type PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput> | PropertyFavoriteCreateWithoutClientInput[] | PropertyFavoriteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutClientInput | PropertyFavoriteCreateOrConnectWithoutClientInput[]
    upsert?: PropertyFavoriteUpsertWithWhereUniqueWithoutClientInput | PropertyFavoriteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyFavoriteCreateManyClientInputEnvelope
    set?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    disconnect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    delete?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    update?: PropertyFavoriteUpdateWithWhereUniqueWithoutClientInput | PropertyFavoriteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyFavoriteUpdateManyWithWhereWithoutClientInput | PropertyFavoriteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput> | PropertyViewCreateWithoutClientInput[] | PropertyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutClientInput | PropertyViewCreateOrConnectWithoutClientInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutClientInput | PropertyViewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyViewCreateManyClientInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutClientInput | PropertyViewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutClientInput | PropertyViewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type ClientSearchUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput> | ClientSearchCreateWithoutClientInput[] | ClientSearchUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientInput | ClientSearchCreateOrConnectWithoutClientInput[]
    upsert?: ClientSearchUpsertWithWhereUniqueWithoutClientInput | ClientSearchUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSearchCreateManyClientInputEnvelope
    set?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    disconnect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    delete?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    connect?: ClientSearchWhereUniqueInput | ClientSearchWhereUniqueInput[]
    update?: ClientSearchUpdateWithWhereUniqueWithoutClientInput | ClientSearchUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSearchUpdateManyWithWhereWithoutClientInput | ClientSearchUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSearchScalarWhereInput | ClientSearchScalarWhereInput[]
  }

  export type AgencyReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput> | AgencyReviewCreateWithoutClientInput[] | AgencyReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyReviewCreateOrConnectWithoutClientInput | AgencyReviewCreateOrConnectWithoutClientInput[]
    upsert?: AgencyReviewUpsertWithWhereUniqueWithoutClientInput | AgencyReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyReviewCreateManyClientInputEnvelope
    set?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    disconnect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    delete?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    connect?: AgencyReviewWhereUniqueInput | AgencyReviewWhereUniqueInput[]
    update?: AgencyReviewUpdateWithWhereUniqueWithoutClientInput | AgencyReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyReviewUpdateManyWithWhereWithoutClientInput | AgencyReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
  }

  export type AgencyViewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput> | AgencyViewCreateWithoutClientInput[] | AgencyViewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AgencyViewCreateOrConnectWithoutClientInput | AgencyViewCreateOrConnectWithoutClientInput[]
    upsert?: AgencyViewUpsertWithWhereUniqueWithoutClientInput | AgencyViewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AgencyViewCreateManyClientInputEnvelope
    set?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    disconnect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    delete?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    connect?: AgencyViewWhereUniqueInput | AgencyViewWhereUniqueInput[]
    update?: AgencyViewUpdateWithWhereUniqueWithoutClientInput | AgencyViewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AgencyViewUpdateManyWithWhereWithoutClientInput | AgencyViewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
  }

  export type PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput> | PropertyEngagementCreateWithoutClientInput[] | PropertyEngagementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutClientInput | PropertyEngagementCreateOrConnectWithoutClientInput[]
    upsert?: PropertyEngagementUpsertWithWhereUniqueWithoutClientInput | PropertyEngagementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PropertyEngagementCreateManyClientInputEnvelope
    set?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    disconnect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    delete?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    update?: PropertyEngagementUpdateWithWhereUniqueWithoutClientInput | PropertyEngagementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PropertyEngagementUpdateManyWithWhereWithoutClientInput | PropertyEngagementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput> | ProposalCreateWithoutClientInput[] | ProposalUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutClientInput | ProposalCreateOrConnectWithoutClientInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutClientInput | ProposalUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProposalCreateManyClientInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutClientInput | ProposalUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutClientInput | ProposalUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput> | ProposalCollaborationCreateWithoutClientInput[] | ProposalCollaborationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutClientInput | ProposalCollaborationCreateOrConnectWithoutClientInput[]
    upsert?: ProposalCollaborationUpsertWithWhereUniqueWithoutClientInput | ProposalCollaborationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProposalCollaborationCreateManyClientInputEnvelope
    set?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    disconnect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    delete?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    connect?: ProposalCollaborationWhereUniqueInput | ProposalCollaborationWhereUniqueInput[]
    update?: ProposalCollaborationUpdateWithWhereUniqueWithoutClientInput | ProposalCollaborationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProposalCollaborationUpdateManyWithWhereWithoutClientInput | ProposalCollaborationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProposalCollaborationScalarWhereInput | ProposalCollaborationScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClientSearchesInput = {
    create?: XOR<ClientCreateWithoutClientSearchesInput, ClientUncheckedCreateWithoutClientSearchesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientSearchesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientPropertySubscriptionCreateNestedOneWithoutClientSearchInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientSearchInput
    connect?: ClientPropertySubscriptionWhereUniqueInput
  }

  export type ClientPropertySubscriptionUncheckedCreateNestedOneWithoutClientSearchInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientSearchInput
    connect?: ClientPropertySubscriptionWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClientSearchesNestedInput = {
    create?: XOR<ClientCreateWithoutClientSearchesInput, ClientUncheckedCreateWithoutClientSearchesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientSearchesInput
    upsert?: ClientUpsertWithoutClientSearchesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientSearchesInput, ClientUpdateWithoutClientSearchesInput>, ClientUncheckedUpdateWithoutClientSearchesInput>
  }

  export type ClientPropertySubscriptionUpdateOneWithoutClientSearchNestedInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientSearchInput
    upsert?: ClientPropertySubscriptionUpsertWithoutClientSearchInput
    disconnect?: ClientPropertySubscriptionWhereInput | boolean
    delete?: ClientPropertySubscriptionWhereInput | boolean
    connect?: ClientPropertySubscriptionWhereUniqueInput
    update?: XOR<XOR<ClientPropertySubscriptionUpdateToOneWithWhereWithoutClientSearchInput, ClientPropertySubscriptionUpdateWithoutClientSearchInput>, ClientPropertySubscriptionUncheckedUpdateWithoutClientSearchInput>
  }

  export type ClientPropertySubscriptionUncheckedUpdateOneWithoutClientSearchNestedInput = {
    create?: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
    connectOrCreate?: ClientPropertySubscriptionCreateOrConnectWithoutClientSearchInput
    upsert?: ClientPropertySubscriptionUpsertWithoutClientSearchInput
    disconnect?: ClientPropertySubscriptionWhereInput | boolean
    delete?: ClientPropertySubscriptionWhereInput | boolean
    connect?: ClientPropertySubscriptionWhereUniqueInput
    update?: XOR<XOR<ClientPropertySubscriptionUpdateToOneWithWhereWithoutClientSearchInput, ClientPropertySubscriptionUpdateWithoutClientSearchInput>, ClientPropertySubscriptionUncheckedUpdateWithoutClientSearchInput>
  }

  export type ClientCreateNestedOneWithoutClientSubscriptionInput = {
    create?: XOR<ClientCreateWithoutClientSubscriptionInput, ClientUncheckedCreateWithoutClientSubscriptionInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientSubscriptionInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientSearchCreateNestedOneWithoutClientPropertySubscriptionInput = {
    create?: XOR<ClientSearchCreateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedCreateWithoutClientPropertySubscriptionInput>
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientPropertySubscriptionInput
    connect?: ClientSearchWhereUniqueInput
  }

  export type ClientUpdateOneWithoutClientSubscriptionNestedInput = {
    create?: XOR<ClientCreateWithoutClientSubscriptionInput, ClientUncheckedCreateWithoutClientSubscriptionInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientSubscriptionInput
    upsert?: ClientUpsertWithoutClientSubscriptionInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientSubscriptionInput, ClientUpdateWithoutClientSubscriptionInput>, ClientUncheckedUpdateWithoutClientSubscriptionInput>
  }

  export type ClientSearchUpdateOneWithoutClientPropertySubscriptionNestedInput = {
    create?: XOR<ClientSearchCreateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedCreateWithoutClientPropertySubscriptionInput>
    connectOrCreate?: ClientSearchCreateOrConnectWithoutClientPropertySubscriptionInput
    upsert?: ClientSearchUpsertWithoutClientPropertySubscriptionInput
    disconnect?: ClientSearchWhereInput | boolean
    delete?: ClientSearchWhereInput | boolean
    connect?: ClientSearchWhereUniqueInput
    update?: XOR<XOR<ClientSearchUpdateToOneWithWhereWithoutClientPropertySubscriptionInput, ClientSearchUpdateWithoutClientPropertySubscriptionInput>, ClientSearchUncheckedUpdateWithoutClientPropertySubscriptionInput>
  }

  export type EnumPropertyListingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyListingType
  }

  export type EnumExternalListingCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExternalListingCategory
  }

  export type AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput = {
    create?: XOR<AgencyMemberCreateWithoutCreatedPropertiesInput, AgencyMemberUncheckedCreateWithoutCreatedPropertiesInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutCreatedPropertiesInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type PropertyViewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type AgencyCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<AgencyCreateWithoutPropertiesInput, AgencyUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutPropertiesInput
    connect?: AgencyWhereUniqueInput
  }

  export type PropertyFavoriteCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput> | PropertyFavoriteCreateWithoutPropertyInput[] | PropertyFavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutPropertyInput | PropertyFavoriteCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFavoriteCreateManyPropertyInputEnvelope
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
  }

  export type PropertySaleCreateNestedOneWithoutPropertyInput = {
    create?: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertySaleCreateOrConnectWithoutPropertyInput
    connect?: PropertySaleWhereUniqueInput
  }

  export type PropertyEngagementCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput> | PropertyEngagementCreateWithoutPropertyInput[] | PropertyEngagementUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutPropertyInput | PropertyEngagementCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyEngagementCreateManyPropertyInputEnvelope
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
  }

  export type PropertySubmissionReviewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput> | PropertySubmissionReviewCreateWithoutPropertyInput[] | PropertySubmissionReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySubmissionReviewCreateOrConnectWithoutPropertyInput | PropertySubmissionReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertySubmissionReviewCreateManyPropertyInputEnvelope
    connect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
  }

  export type PropertyLocationCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyLocationCreateWithoutPropertiesInput, PropertyLocationUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutPropertiesInput
    connect?: PropertyLocationWhereUniqueInput
  }

  export type PropertyCategoryCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutPropertiesInput
    connect?: PropertyCategoryWhereUniqueInput
  }

  export type PropertySubcategoryCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertySubcategoryCreateWithoutPropertiesInput, PropertySubcategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutPropertiesInput
    connect?: PropertySubcategoryWhereUniqueInput
  }

  export type AgencyClientCreateNestedOneWithoutOwnedPropertiesInput = {
    create?: XOR<AgencyClientCreateWithoutOwnedPropertiesInput, AgencyClientUncheckedCreateWithoutOwnedPropertiesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutOwnedPropertiesInput
    connect?: AgencyClientWhereUniqueInput
  }

  export type AgencyClientCreateNestedOneWithoutRentedPropertiesInput = {
    create?: XOR<AgencyClientCreateWithoutRentedPropertiesInput, AgencyClientUncheckedCreateWithoutRentedPropertiesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutRentedPropertiesInput
    connect?: AgencyClientWhereUniqueInput
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput> | PropertyFavoriteCreateWithoutPropertyInput[] | PropertyFavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutPropertyInput | PropertyFavoriteCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFavoriteCreateManyPropertyInputEnvelope
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
  }

  export type PropertySaleUncheckedCreateNestedOneWithoutPropertyInput = {
    create?: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertySaleCreateOrConnectWithoutPropertyInput
    connect?: PropertySaleWhereUniqueInput
  }

  export type PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput> | PropertyEngagementCreateWithoutPropertyInput[] | PropertyEngagementUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutPropertyInput | PropertyEngagementCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyEngagementCreateManyPropertyInputEnvelope
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
  }

  export type PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput> | PropertySubmissionReviewCreateWithoutPropertyInput[] | PropertySubmissionReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySubmissionReviewCreateOrConnectWithoutPropertyInput | PropertySubmissionReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertySubmissionReviewCreateManyPropertyInputEnvelope
    connect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type NullableEnumPropertyOrientationFieldUpdateOperationsInput = {
    set?: $Enums.PropertyOrientation | null
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutCreatedPropertiesInput, AgencyMemberUncheckedCreateWithoutCreatedPropertiesInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutCreatedPropertiesInput
    upsert?: AgencyMemberUpsertWithoutCreatedPropertiesInput
    disconnect?: AgencyMemberWhereInput | boolean
    delete?: AgencyMemberWhereInput | boolean
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutCreatedPropertiesInput, AgencyMemberUpdateWithoutCreatedPropertiesInput>, AgencyMemberUncheckedUpdateWithoutCreatedPropertiesInput>
  }

  export type PropertyViewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type AgencyUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<AgencyCreateWithoutPropertiesInput, AgencyUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutPropertiesInput
    upsert?: AgencyUpsertWithoutPropertiesInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutPropertiesInput, AgencyUpdateWithoutPropertiesInput>, AgencyUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyFavoriteUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput> | PropertyFavoriteCreateWithoutPropertyInput[] | PropertyFavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutPropertyInput | PropertyFavoriteCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFavoriteUpsertWithWhereUniqueWithoutPropertyInput | PropertyFavoriteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFavoriteCreateManyPropertyInputEnvelope
    set?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    disconnect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    delete?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    update?: PropertyFavoriteUpdateWithWhereUniqueWithoutPropertyInput | PropertyFavoriteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFavoriteUpdateManyWithWhereWithoutPropertyInput | PropertyFavoriteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
  }

  export type PropertySaleUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertySaleCreateOrConnectWithoutPropertyInput
    upsert?: PropertySaleUpsertWithoutPropertyInput
    disconnect?: PropertySaleWhereInput | boolean
    delete?: PropertySaleWhereInput | boolean
    connect?: PropertySaleWhereUniqueInput
    update?: XOR<XOR<PropertySaleUpdateToOneWithWhereWithoutPropertyInput, PropertySaleUpdateWithoutPropertyInput>, PropertySaleUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyEngagementUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput> | PropertyEngagementCreateWithoutPropertyInput[] | PropertyEngagementUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutPropertyInput | PropertyEngagementCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyEngagementUpsertWithWhereUniqueWithoutPropertyInput | PropertyEngagementUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyEngagementCreateManyPropertyInputEnvelope
    set?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    disconnect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    delete?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    update?: PropertyEngagementUpdateWithWhereUniqueWithoutPropertyInput | PropertyEngagementUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyEngagementUpdateManyWithWhereWithoutPropertyInput | PropertyEngagementUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
  }

  export type PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput> | PropertySubmissionReviewCreateWithoutPropertyInput[] | PropertySubmissionReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySubmissionReviewCreateOrConnectWithoutPropertyInput | PropertySubmissionReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertySubmissionReviewUpsertWithWhereUniqueWithoutPropertyInput | PropertySubmissionReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertySubmissionReviewCreateManyPropertyInputEnvelope
    set?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    disconnect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    delete?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    connect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    update?: PropertySubmissionReviewUpdateWithWhereUniqueWithoutPropertyInput | PropertySubmissionReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertySubmissionReviewUpdateManyWithWhereWithoutPropertyInput | PropertySubmissionReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertySubmissionReviewScalarWhereInput | PropertySubmissionReviewScalarWhereInput[]
  }

  export type PropertyLocationUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyLocationCreateWithoutPropertiesInput, PropertyLocationUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyLocationUpsertWithoutPropertiesInput
    disconnect?: PropertyLocationWhereInput | boolean
    delete?: PropertyLocationWhereInput | boolean
    connect?: PropertyLocationWhereUniqueInput
    update?: XOR<XOR<PropertyLocationUpdateToOneWithWhereWithoutPropertiesInput, PropertyLocationUpdateWithoutPropertiesInput>, PropertyLocationUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyCategoryUpsertWithoutPropertiesInput
    disconnect?: PropertyCategoryWhereInput | boolean
    delete?: PropertyCategoryWhereInput | boolean
    connect?: PropertyCategoryWhereUniqueInput
    update?: XOR<XOR<PropertyCategoryUpdateToOneWithWhereWithoutPropertiesInput, PropertyCategoryUpdateWithoutPropertiesInput>, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertySubcategoryUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertySubcategoryCreateWithoutPropertiesInput, PropertySubcategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutPropertiesInput
    upsert?: PropertySubcategoryUpsertWithoutPropertiesInput
    disconnect?: PropertySubcategoryWhereInput | boolean
    delete?: PropertySubcategoryWhereInput | boolean
    connect?: PropertySubcategoryWhereUniqueInput
    update?: XOR<XOR<PropertySubcategoryUpdateToOneWithWhereWithoutPropertiesInput, PropertySubcategoryUpdateWithoutPropertiesInput>, PropertySubcategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput = {
    create?: XOR<AgencyClientCreateWithoutOwnedPropertiesInput, AgencyClientUncheckedCreateWithoutOwnedPropertiesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutOwnedPropertiesInput
    upsert?: AgencyClientUpsertWithoutOwnedPropertiesInput
    disconnect?: AgencyClientWhereInput | boolean
    delete?: AgencyClientWhereInput | boolean
    connect?: AgencyClientWhereUniqueInput
    update?: XOR<XOR<AgencyClientUpdateToOneWithWhereWithoutOwnedPropertiesInput, AgencyClientUpdateWithoutOwnedPropertiesInput>, AgencyClientUncheckedUpdateWithoutOwnedPropertiesInput>
  }

  export type AgencyClientUpdateOneWithoutRentedPropertiesNestedInput = {
    create?: XOR<AgencyClientCreateWithoutRentedPropertiesInput, AgencyClientUncheckedCreateWithoutRentedPropertiesInput>
    connectOrCreate?: AgencyClientCreateOrConnectWithoutRentedPropertiesInput
    upsert?: AgencyClientUpsertWithoutRentedPropertiesInput
    disconnect?: AgencyClientWhereInput | boolean
    delete?: AgencyClientWhereInput | boolean
    connect?: AgencyClientWhereUniqueInput
    update?: XOR<XOR<AgencyClientUpdateToOneWithWhereWithoutRentedPropertiesInput, AgencyClientUpdateWithoutRentedPropertiesInput>, AgencyClientUncheckedUpdateWithoutRentedPropertiesInput>
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput> | PropertyFavoriteCreateWithoutPropertyInput[] | PropertyFavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFavoriteCreateOrConnectWithoutPropertyInput | PropertyFavoriteCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFavoriteUpsertWithWhereUniqueWithoutPropertyInput | PropertyFavoriteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFavoriteCreateManyPropertyInputEnvelope
    set?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    disconnect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    delete?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    connect?: PropertyFavoriteWhereUniqueInput | PropertyFavoriteWhereUniqueInput[]
    update?: PropertyFavoriteUpdateWithWhereUniqueWithoutPropertyInput | PropertyFavoriteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFavoriteUpdateManyWithWhereWithoutPropertyInput | PropertyFavoriteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
  }

  export type PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertySaleCreateOrConnectWithoutPropertyInput
    upsert?: PropertySaleUpsertWithoutPropertyInput
    disconnect?: PropertySaleWhereInput | boolean
    delete?: PropertySaleWhereInput | boolean
    connect?: PropertySaleWhereUniqueInput
    update?: XOR<XOR<PropertySaleUpdateToOneWithWhereWithoutPropertyInput, PropertySaleUpdateWithoutPropertyInput>, PropertySaleUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput> | PropertyEngagementCreateWithoutPropertyInput[] | PropertyEngagementUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyEngagementCreateOrConnectWithoutPropertyInput | PropertyEngagementCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyEngagementUpsertWithWhereUniqueWithoutPropertyInput | PropertyEngagementUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyEngagementCreateManyPropertyInputEnvelope
    set?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    disconnect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    delete?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    connect?: PropertyEngagementWhereUniqueInput | PropertyEngagementWhereUniqueInput[]
    update?: PropertyEngagementUpdateWithWhereUniqueWithoutPropertyInput | PropertyEngagementUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyEngagementUpdateManyWithWhereWithoutPropertyInput | PropertyEngagementUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
  }

  export type PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput> | PropertySubmissionReviewCreateWithoutPropertyInput[] | PropertySubmissionReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySubmissionReviewCreateOrConnectWithoutPropertyInput | PropertySubmissionReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertySubmissionReviewUpsertWithWhereUniqueWithoutPropertyInput | PropertySubmissionReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertySubmissionReviewCreateManyPropertyInputEnvelope
    set?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    disconnect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    delete?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    connect?: PropertySubmissionReviewWhereUniqueInput | PropertySubmissionReviewWhereUniqueInput[]
    update?: PropertySubmissionReviewUpdateWithWhereUniqueWithoutPropertyInput | PropertySubmissionReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertySubmissionReviewUpdateManyWithWhereWithoutPropertyInput | PropertySubmissionReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertySubmissionReviewScalarWhereInput | PropertySubmissionReviewScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertySubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput> | PropertySubcategoryCreateWithoutCategoryInput[] | PropertySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutCategoryInput | PropertySubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertySubcategoryCreateManyCategoryInputEnvelope
    connect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertySubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput> | PropertySubcategoryCreateWithoutCategoryInput[] | PropertySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutCategoryInput | PropertySubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertySubcategoryCreateManyCategoryInputEnvelope
    connect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCategoryInput | PropertyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCategoryInput | PropertyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCategoryInput | PropertyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertySubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput> | PropertySubcategoryCreateWithoutCategoryInput[] | PropertySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutCategoryInput | PropertySubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertySubcategoryUpsertWithWhereUniqueWithoutCategoryInput | PropertySubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertySubcategoryCreateManyCategoryInputEnvelope
    set?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    disconnect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    delete?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    connect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    update?: PropertySubcategoryUpdateWithWhereUniqueWithoutCategoryInput | PropertySubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertySubcategoryUpdateManyWithWhereWithoutCategoryInput | PropertySubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertySubcategoryScalarWhereInput | PropertySubcategoryScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCategoryInput | PropertyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCategoryInput | PropertyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCategoryInput | PropertyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput> | PropertySubcategoryCreateWithoutCategoryInput[] | PropertySubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertySubcategoryCreateOrConnectWithoutCategoryInput | PropertySubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertySubcategoryUpsertWithWhereUniqueWithoutCategoryInput | PropertySubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertySubcategoryCreateManyCategoryInputEnvelope
    set?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    disconnect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    delete?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    connect?: PropertySubcategoryWhereUniqueInput | PropertySubcategoryWhereUniqueInput[]
    update?: PropertySubcategoryUpdateWithWhereUniqueWithoutCategoryInput | PropertySubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertySubcategoryUpdateManyWithWhereWithoutCategoryInput | PropertySubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertySubcategoryScalarWhereInput | PropertySubcategoryScalarWhereInput[]
  }

  export type PropertyCategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<PropertyCategoryCreateWithoutSubcategoriesInput, PropertyCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: PropertyCategoryWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput> | PropertyCreateWithoutSubcategoryInput[] | PropertyUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutSubcategoryInput | PropertyCreateOrConnectWithoutSubcategoryInput[]
    createMany?: PropertyCreateManySubcategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput> | PropertyCreateWithoutSubcategoryInput[] | PropertyUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutSubcategoryInput | PropertyCreateOrConnectWithoutSubcategoryInput[]
    createMany?: PropertyCreateManySubcategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<PropertyCategoryCreateWithoutSubcategoriesInput, PropertyCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: PropertyCategoryUpsertWithoutSubcategoriesInput
    connect?: PropertyCategoryWhereUniqueInput
    update?: XOR<XOR<PropertyCategoryUpdateToOneWithWhereWithoutSubcategoriesInput, PropertyCategoryUpdateWithoutSubcategoriesInput>, PropertyCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type PropertyUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput> | PropertyCreateWithoutSubcategoryInput[] | PropertyUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutSubcategoryInput | PropertyCreateOrConnectWithoutSubcategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutSubcategoryInput | PropertyUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: PropertyCreateManySubcategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutSubcategoryInput | PropertyUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutSubcategoryInput | PropertyUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput> | PropertyCreateWithoutSubcategoryInput[] | PropertyUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutSubcategoryInput | PropertyCreateOrConnectWithoutSubcategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutSubcategoryInput | PropertyUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: PropertyCreateManySubcategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutSubcategoryInput | PropertyUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutSubcategoryInput | PropertyUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyLocationCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PropertyLocationCreateWithoutChildrenInput, PropertyLocationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutChildrenInput
    connect?: PropertyLocationWhereUniqueInput
  }

  export type PropertyLocationCreateNestedManyWithoutParentInput = {
    create?: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput> | PropertyLocationCreateWithoutParentInput[] | PropertyLocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutParentInput | PropertyLocationCreateOrConnectWithoutParentInput[]
    createMany?: PropertyLocationCreateManyParentInputEnvelope
    connect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyLocationInput = {
    create?: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput> | PropertyCreateWithoutPropertyLocationInput[] | PropertyUncheckedCreateWithoutPropertyLocationInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyLocationInput | PropertyCreateOrConnectWithoutPropertyLocationInput[]
    createMany?: PropertyCreateManyPropertyLocationInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyLocationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput> | PropertyLocationCreateWithoutParentInput[] | PropertyLocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutParentInput | PropertyLocationCreateOrConnectWithoutParentInput[]
    createMany?: PropertyLocationCreateManyParentInputEnvelope
    connect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyLocationInput = {
    create?: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput> | PropertyCreateWithoutPropertyLocationInput[] | PropertyUncheckedCreateWithoutPropertyLocationInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyLocationInput | PropertyCreateOrConnectWithoutPropertyLocationInput[]
    createMany?: PropertyCreateManyPropertyLocationInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyLocationUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PropertyLocationCreateWithoutChildrenInput, PropertyLocationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutChildrenInput
    upsert?: PropertyLocationUpsertWithoutChildrenInput
    disconnect?: PropertyLocationWhereInput | boolean
    delete?: PropertyLocationWhereInput | boolean
    connect?: PropertyLocationWhereUniqueInput
    update?: XOR<XOR<PropertyLocationUpdateToOneWithWhereWithoutChildrenInput, PropertyLocationUpdateWithoutChildrenInput>, PropertyLocationUncheckedUpdateWithoutChildrenInput>
  }

  export type PropertyLocationUpdateManyWithoutParentNestedInput = {
    create?: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput> | PropertyLocationCreateWithoutParentInput[] | PropertyLocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutParentInput | PropertyLocationCreateOrConnectWithoutParentInput[]
    upsert?: PropertyLocationUpsertWithWhereUniqueWithoutParentInput | PropertyLocationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PropertyLocationCreateManyParentInputEnvelope
    set?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    disconnect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    delete?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    connect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    update?: PropertyLocationUpdateWithWhereUniqueWithoutParentInput | PropertyLocationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PropertyLocationUpdateManyWithWhereWithoutParentInput | PropertyLocationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PropertyLocationScalarWhereInput | PropertyLocationScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutPropertyLocationNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput> | PropertyCreateWithoutPropertyLocationInput[] | PropertyUncheckedCreateWithoutPropertyLocationInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyLocationInput | PropertyCreateOrConnectWithoutPropertyLocationInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyLocationInput | PropertyUpsertWithWhereUniqueWithoutPropertyLocationInput[]
    createMany?: PropertyCreateManyPropertyLocationInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyLocationInput | PropertyUpdateWithWhereUniqueWithoutPropertyLocationInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyLocationInput | PropertyUpdateManyWithWhereWithoutPropertyLocationInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyLocationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput> | PropertyLocationCreateWithoutParentInput[] | PropertyLocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PropertyLocationCreateOrConnectWithoutParentInput | PropertyLocationCreateOrConnectWithoutParentInput[]
    upsert?: PropertyLocationUpsertWithWhereUniqueWithoutParentInput | PropertyLocationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PropertyLocationCreateManyParentInputEnvelope
    set?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    disconnect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    delete?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    connect?: PropertyLocationWhereUniqueInput | PropertyLocationWhereUniqueInput[]
    update?: PropertyLocationUpdateWithWhereUniqueWithoutParentInput | PropertyLocationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PropertyLocationUpdateManyWithWhereWithoutParentInput | PropertyLocationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PropertyLocationScalarWhereInput | PropertyLocationScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyLocationNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput> | PropertyCreateWithoutPropertyLocationInput[] | PropertyUncheckedCreateWithoutPropertyLocationInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyLocationInput | PropertyCreateOrConnectWithoutPropertyLocationInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyLocationInput | PropertyUpsertWithWhereUniqueWithoutPropertyLocationInput[]
    createMany?: PropertyCreateManyPropertyLocationInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyLocationInput | PropertyUpdateWithWhereUniqueWithoutPropertyLocationInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyLocationInput | PropertyUpdateManyWithWhereWithoutPropertyLocationInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutPropertyReviewInput = {
    create?: XOR<PropertyCreateWithoutPropertyReviewInput, PropertyUncheckedCreateWithoutPropertyReviewInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyReviewInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPropertyReviewNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyReviewInput, PropertyUncheckedCreateWithoutPropertyReviewInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyReviewInput
    upsert?: PropertyUpsertWithoutPropertyReviewInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyReviewInput, PropertyUpdateWithoutPropertyReviewInput>, PropertyUncheckedUpdateWithoutPropertyReviewInput>
  }

  export type PropertyCreateNestedOneWithoutPropertySaleInput = {
    create?: XOR<PropertyCreateWithoutPropertySaleInput, PropertyUncheckedCreateWithoutPropertySaleInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertySaleInput
    connect?: PropertyWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutPropertySaleInput = {
    create?: XOR<AgencyCreateWithoutPropertySaleInput, AgencyUncheckedCreateWithoutPropertySaleInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutPropertySaleInput
    connect?: AgencyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPropertySaleNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertySaleInput, PropertyUncheckedCreateWithoutPropertySaleInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertySaleInput
    upsert?: PropertyUpsertWithoutPropertySaleInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertySaleInput, PropertyUpdateWithoutPropertySaleInput>, PropertyUncheckedUpdateWithoutPropertySaleInput>
  }

  export type AgencyUpdateOneRequiredWithoutPropertySaleNestedInput = {
    create?: XOR<AgencyCreateWithoutPropertySaleInput, AgencyUncheckedCreateWithoutPropertySaleInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutPropertySaleInput
    upsert?: AgencyUpsertWithoutPropertySaleInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutPropertySaleInput, AgencyUpdateWithoutPropertySaleInput>, AgencyUncheckedUpdateWithoutPropertySaleInput>
  }

  export type PropertyCreateNestedOneWithoutViewsInput = {
    create?: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutPropertyViewsInput = {
    create?: XOR<ClientCreateWithoutPropertyViewsInput, ClientUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPropertyViewsInput
    connect?: ClientWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewsInput
    upsert?: PropertyUpsertWithoutViewsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutViewsInput, PropertyUpdateWithoutViewsInput>, PropertyUncheckedUpdateWithoutViewsInput>
  }

  export type ClientUpdateOneWithoutPropertyViewsNestedInput = {
    create?: XOR<ClientCreateWithoutPropertyViewsInput, ClientUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPropertyViewsInput
    upsert?: ClientUpsertWithoutPropertyViewsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPropertyViewsInput, ClientUpdateWithoutPropertyViewsInput>, ClientUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type PropertyCreateNestedOneWithoutPropertyFavoriteInput = {
    create?: XOR<PropertyCreateWithoutPropertyFavoriteInput, PropertyUncheckedCreateWithoutPropertyFavoriteInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyFavoriteInput
    connect?: PropertyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFavoritesInput
    connect?: ClientWhereUniqueInput
  }

  export type PropertyUpdateOneWithoutPropertyFavoriteNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyFavoriteInput, PropertyUncheckedCreateWithoutPropertyFavoriteInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyFavoriteInput
    upsert?: PropertyUpsertWithoutPropertyFavoriteInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyFavoriteInput, PropertyUpdateWithoutPropertyFavoriteInput>, PropertyUncheckedUpdateWithoutPropertyFavoriteInput>
  }

  export type ClientUpdateOneWithoutFavoritesNestedInput = {
    create?: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFavoritesInput
    upsert?: ClientUpsertWithoutFavoritesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFavoritesInput, ClientUpdateWithoutFavoritesInput>, ClientUncheckedUpdateWithoutFavoritesInput>
  }

  export type PropertyCreateNestedOneWithoutPropertyEngagementInput = {
    create?: XOR<PropertyCreateWithoutPropertyEngagementInput, PropertyUncheckedCreateWithoutPropertyEngagementInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyEngagementInput
    connect?: PropertyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutPropertyEngagementInput = {
    create?: XOR<ClientCreateWithoutPropertyEngagementInput, ClientUncheckedCreateWithoutPropertyEngagementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPropertyEngagementInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumEngagementTypeFieldUpdateOperationsInput = {
    set?: $Enums.EngagementType
  }

  export type PropertyUpdateOneRequiredWithoutPropertyEngagementNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyEngagementInput, PropertyUncheckedCreateWithoutPropertyEngagementInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyEngagementInput
    upsert?: PropertyUpsertWithoutPropertyEngagementInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyEngagementInput, PropertyUpdateWithoutPropertyEngagementInput>, PropertyUncheckedUpdateWithoutPropertyEngagementInput>
  }

  export type ClientUpdateOneWithoutPropertyEngagementNestedInput = {
    create?: XOR<ClientCreateWithoutPropertyEngagementInput, ClientUncheckedCreateWithoutPropertyEngagementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPropertyEngagementInput
    upsert?: ClientUpsertWithoutPropertyEngagementInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPropertyEngagementInput, ClientUpdateWithoutPropertyEngagementInput>, ClientUncheckedUpdateWithoutPropertyEngagementInput>
  }

  export type ClientCreateNestedOneWithoutProposalInput = {
    create?: XOR<ClientCreateWithoutProposalInput, ClientUncheckedCreateWithoutProposalInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProposalInput
    connect?: ClientWhereUniqueInput
  }

  export type ProposalOfferCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput> | ProposalOfferCreateWithoutProposalInput[] | ProposalOfferUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalInput | ProposalOfferCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalOfferCreateManyProposalInputEnvelope
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
  }

  export type ProposalOfferUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput> | ProposalOfferCreateWithoutProposalInput[] | ProposalOfferUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalInput | ProposalOfferCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalOfferCreateManyProposalInputEnvelope
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
  }

  export type EnumProposalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProposalStatus
  }

  export type ClientUpdateOneRequiredWithoutProposalNestedInput = {
    create?: XOR<ClientCreateWithoutProposalInput, ClientUncheckedCreateWithoutProposalInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProposalInput
    upsert?: ClientUpsertWithoutProposalInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProposalInput, ClientUpdateWithoutProposalInput>, ClientUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalOfferUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput> | ProposalOfferCreateWithoutProposalInput[] | ProposalOfferUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalInput | ProposalOfferCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalOfferUpsertWithWhereUniqueWithoutProposalInput | ProposalOfferUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalOfferCreateManyProposalInputEnvelope
    set?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    disconnect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    delete?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    update?: ProposalOfferUpdateWithWhereUniqueWithoutProposalInput | ProposalOfferUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalOfferUpdateManyWithWhereWithoutProposalInput | ProposalOfferUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
  }

  export type ProposalOfferUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput> | ProposalOfferCreateWithoutProposalInput[] | ProposalOfferUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalInput | ProposalOfferCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalOfferUpsertWithWhereUniqueWithoutProposalInput | ProposalOfferUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalOfferCreateManyProposalInputEnvelope
    set?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    disconnect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    delete?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    connect?: ProposalOfferWhereUniqueInput | ProposalOfferWhereUniqueInput[]
    update?: ProposalOfferUpdateWithWhereUniqueWithoutProposalInput | ProposalOfferUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalOfferUpdateManyWithWhereWithoutProposalInput | ProposalOfferUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
  }

  export type ProposalCreateNestedOneWithoutOffersInput = {
    create?: XOR<ProposalCreateWithoutOffersInput, ProposalUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutOffersInput
    connect?: ProposalWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutProposalOfferInput = {
    create?: XOR<AgencyCreateWithoutProposalOfferInput, AgencyUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutProposalOfferInput
    connect?: AgencyWhereUniqueInput
  }

  export type ProposalCollaborationCreateNestedOneWithoutProposalOfferInput = {
    create?: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutProposalOfferInput
    connect?: ProposalCollaborationWhereUniqueInput
  }

  export type ProposalCollaborationUncheckedCreateNestedOneWithoutProposalOfferInput = {
    create?: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutProposalOfferInput
    connect?: ProposalCollaborationWhereUniqueInput
  }

  export type ProposalUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<ProposalCreateWithoutOffersInput, ProposalUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutOffersInput
    upsert?: ProposalUpsertWithoutOffersInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutOffersInput, ProposalUpdateWithoutOffersInput>, ProposalUncheckedUpdateWithoutOffersInput>
  }

  export type AgencyUpdateOneRequiredWithoutProposalOfferNestedInput = {
    create?: XOR<AgencyCreateWithoutProposalOfferInput, AgencyUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutProposalOfferInput
    upsert?: AgencyUpsertWithoutProposalOfferInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutProposalOfferInput, AgencyUpdateWithoutProposalOfferInput>, AgencyUncheckedUpdateWithoutProposalOfferInput>
  }

  export type ProposalCollaborationUpdateOneWithoutProposalOfferNestedInput = {
    create?: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutProposalOfferInput
    upsert?: ProposalCollaborationUpsertWithoutProposalOfferInput
    disconnect?: ProposalCollaborationWhereInput | boolean
    delete?: ProposalCollaborationWhereInput | boolean
    connect?: ProposalCollaborationWhereUniqueInput
    update?: XOR<XOR<ProposalCollaborationUpdateToOneWithWhereWithoutProposalOfferInput, ProposalCollaborationUpdateWithoutProposalOfferInput>, ProposalCollaborationUncheckedUpdateWithoutProposalOfferInput>
  }

  export type ProposalCollaborationUncheckedUpdateOneWithoutProposalOfferNestedInput = {
    create?: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
    connectOrCreate?: ProposalCollaborationCreateOrConnectWithoutProposalOfferInput
    upsert?: ProposalCollaborationUpsertWithoutProposalOfferInput
    disconnect?: ProposalCollaborationWhereInput | boolean
    delete?: ProposalCollaborationWhereInput | boolean
    connect?: ProposalCollaborationWhereUniqueInput
    update?: XOR<XOR<ProposalCollaborationUpdateToOneWithWhereWithoutProposalOfferInput, ProposalCollaborationUpdateWithoutProposalOfferInput>, ProposalCollaborationUncheckedUpdateWithoutProposalOfferInput>
  }

  export type ClientCreateNestedOneWithoutProposalCollaborationInput = {
    create?: XOR<ClientCreateWithoutProposalCollaborationInput, ClientUncheckedCreateWithoutProposalCollaborationInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProposalCollaborationInput
    connect?: ClientWhereUniqueInput
  }

  export type ProposalOfferCreateNestedOneWithoutProposalCollaborationInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalCollaborationInput, ProposalOfferUncheckedCreateWithoutProposalCollaborationInput>
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalCollaborationInput
    connect?: ProposalOfferWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutProposalCollaborationNestedInput = {
    create?: XOR<ClientCreateWithoutProposalCollaborationInput, ClientUncheckedCreateWithoutProposalCollaborationInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProposalCollaborationInput
    upsert?: ClientUpsertWithoutProposalCollaborationInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProposalCollaborationInput, ClientUpdateWithoutProposalCollaborationInput>, ClientUncheckedUpdateWithoutProposalCollaborationInput>
  }

  export type ProposalOfferUpdateOneWithoutProposalCollaborationNestedInput = {
    create?: XOR<ProposalOfferCreateWithoutProposalCollaborationInput, ProposalOfferUncheckedCreateWithoutProposalCollaborationInput>
    connectOrCreate?: ProposalOfferCreateOrConnectWithoutProposalCollaborationInput
    upsert?: ProposalOfferUpsertWithoutProposalCollaborationInput
    disconnect?: ProposalOfferWhereInput | boolean
    delete?: ProposalOfferWhereInput | boolean
    connect?: ProposalOfferWhereUniqueInput
    update?: XOR<XOR<ProposalOfferUpdateToOneWithWhereWithoutProposalCollaborationInput, ProposalOfferUpdateWithoutProposalCollaborationInput>, ProposalOfferUncheckedUpdateWithoutProposalCollaborationInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AgencyCreateNestedOneWithoutUsersInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    connect?: AgencyWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserFeatureRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput> | UserFeatureRequestCreateWithoutUserInput[] | UserFeatureRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureRequestCreateOrConnectWithoutUserInput | UserFeatureRequestCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureRequestCreateManyUserInputEnvelope
    connect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
  }

  export type AgencyMemberCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutUserInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutAgencyOwnerInput = {
    create?: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyOwnerInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyInvitationCreateNestedManyWithoutSenderInput = {
    create?: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput> | AgencyInvitationCreateWithoutSenderInput[] | AgencyInvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutSenderInput | AgencyInvitationCreateOrConnectWithoutSenderInput[]
    createMany?: AgencyInvitationCreateManySenderInputEnvelope
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput> | UserFeatureRequestCreateWithoutUserInput[] | UserFeatureRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureRequestCreateOrConnectWithoutUserInput | UserFeatureRequestCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureRequestCreateManyUserInputEnvelope
    connect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
  }

  export type AgencyMemberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutUserInput
    connect?: AgencyMemberWhereUniqueInput
  }

  export type AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput = {
    create?: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyOwnerInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput> | AgencyInvitationCreateWithoutSenderInput[] | AgencyInvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutSenderInput | AgencyInvitationCreateOrConnectWithoutSenderInput[]
    createMany?: AgencyInvitationCreateManySenderInputEnvelope
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
  }

  export type NullableEnumUserLanguageFieldUpdateOperationsInput = {
    set?: $Enums.UserLanguage | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AgencyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    upsert?: AgencyUpsertWithoutUsersInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUsersInput, AgencyUpdateWithoutUsersInput>, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput> | UserFeatureRequestCreateWithoutUserInput[] | UserFeatureRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureRequestCreateOrConnectWithoutUserInput | UserFeatureRequestCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureRequestUpsertWithWhereUniqueWithoutUserInput | UserFeatureRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureRequestCreateManyUserInputEnvelope
    set?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    disconnect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    delete?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    connect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    update?: UserFeatureRequestUpdateWithWhereUniqueWithoutUserInput | UserFeatureRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureRequestUpdateManyWithWhereWithoutUserInput | UserFeatureRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureRequestScalarWhereInput | UserFeatureRequestScalarWhereInput[]
  }

  export type AgencyMemberUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutUserInput
    upsert?: AgencyMemberUpsertWithoutUserInput
    disconnect?: AgencyMemberWhereInput | boolean
    delete?: AgencyMemberWhereInput | boolean
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutUserInput, AgencyMemberUpdateWithoutUserInput>, AgencyMemberUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateOneWithoutAgencyOwnerNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyOwnerInput
    upsert?: AgencyUpsertWithoutAgencyOwnerInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyOwnerInput, AgencyUpdateWithoutAgencyOwnerInput>, AgencyUncheckedUpdateWithoutAgencyOwnerInput>
  }

  export type AgencyInvitationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput> | AgencyInvitationCreateWithoutSenderInput[] | AgencyInvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutSenderInput | AgencyInvitationCreateOrConnectWithoutSenderInput[]
    upsert?: AgencyInvitationUpsertWithWhereUniqueWithoutSenderInput | AgencyInvitationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: AgencyInvitationCreateManySenderInputEnvelope
    set?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    disconnect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    delete?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    update?: AgencyInvitationUpdateWithWhereUniqueWithoutSenderInput | AgencyInvitationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: AgencyInvitationUpdateManyWithWhereWithoutSenderInput | AgencyInvitationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput> | UserFeatureRequestCreateWithoutUserInput[] | UserFeatureRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureRequestCreateOrConnectWithoutUserInput | UserFeatureRequestCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureRequestUpsertWithWhereUniqueWithoutUserInput | UserFeatureRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureRequestCreateManyUserInputEnvelope
    set?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    disconnect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    delete?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    connect?: UserFeatureRequestWhereUniqueInput | UserFeatureRequestWhereUniqueInput[]
    update?: UserFeatureRequestUpdateWithWhereUniqueWithoutUserInput | UserFeatureRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureRequestUpdateManyWithWhereWithoutUserInput | UserFeatureRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureRequestScalarWhereInput | UserFeatureRequestScalarWhereInput[]
  }

  export type AgencyMemberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyMemberCreateOrConnectWithoutUserInput
    upsert?: AgencyMemberUpsertWithoutUserInput
    disconnect?: AgencyMemberWhereInput | boolean
    delete?: AgencyMemberWhereInput | boolean
    connect?: AgencyMemberWhereUniqueInput
    update?: XOR<XOR<AgencyMemberUpdateToOneWithWhereWithoutUserInput, AgencyMemberUpdateWithoutUserInput>, AgencyMemberUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput = {
    create?: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAgencyOwnerInput
    upsert?: AgencyUpsertWithoutAgencyOwnerInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAgencyOwnerInput, AgencyUpdateWithoutAgencyOwnerInput>, AgencyUncheckedUpdateWithoutAgencyOwnerInput>
  }

  export type AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput> | AgencyInvitationCreateWithoutSenderInput[] | AgencyInvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: AgencyInvitationCreateOrConnectWithoutSenderInput | AgencyInvitationCreateOrConnectWithoutSenderInput[]
    upsert?: AgencyInvitationUpsertWithWhereUniqueWithoutSenderInput | AgencyInvitationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: AgencyInvitationCreateManySenderInputEnvelope
    set?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    disconnect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    delete?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    connect?: AgencyInvitationWhereUniqueInput | AgencyInvitationWhereUniqueInput[]
    update?: AgencyInvitationUpdateWithWhereUniqueWithoutSenderInput | AgencyInvitationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: AgencyInvitationUpdateManyWithWhereWithoutSenderInput | AgencyInvitationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutUserFeatureRequestInput = {
    create?: XOR<UserCreateWithoutUserFeatureRequestInput, UserUncheckedCreateWithoutUserFeatureRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFeatureRequestInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserFeatureRequestNestedInput = {
    create?: XOR<UserCreateWithoutUserFeatureRequestInput, UserUncheckedCreateWithoutUserFeatureRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFeatureRequestInput
    upsert?: UserUpsertWithoutUserFeatureRequestInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFeatureRequestInput, UserUpdateWithoutUserFeatureRequestInput>, UserUncheckedUpdateWithoutUserFeatureRequestInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAgencyApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyApprovalStatus | EnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel> | $Enums.AgencyApprovalStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAgencyPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyPlan | EnumAgencyPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyPlanFilter<$PrismaModel> | $Enums.AgencyPlan
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAgencyApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyApprovalStatus | EnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyApprovalStatus[] | ListEnumAgencyApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyApprovalStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAgencyPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyPlan | EnumAgencyPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyPlan[] | ListEnumAgencyPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyPlanWithAggregatesFilter<$PrismaModel> | $Enums.AgencyPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyPlanFilter<$PrismaModel>
    _max?: NestedEnumAgencyPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAgencyClientStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientStatus | EnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel> | $Enums.AgencyClientStatus | null
  }

  export type NestedEnumAgencyClientStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientStatus | EnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyClientStatus[] | ListEnumAgencyClientStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyClientStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgencyClientStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAgencyClientStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type NestedEnumPropertyListingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel> | $Enums.PropertyListingType | null
  }

  export type NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientPreferenceStatus | EnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel> | $Enums.AgencyClientPreferenceStatus
  }

  export type NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyListingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyListingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyListingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyListingTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAgencyClientPreferenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyClientPreferenceStatus | EnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyClientPreferenceStatus[] | ListEnumAgencyClientPreferenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyClientPreferenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyClientPreferenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyClientPreferenceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberStatus | EnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel> | $Enums.AgencyMemberStatus | null
  }

  export type NestedEnumAgencyMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberRole | EnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyMemberRoleFilter<$PrismaModel> | $Enums.AgencyMemberRole
  }

  export type NestedEnumAgencyMemberStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberStatus | EnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgencyMemberStatus[] | ListEnumAgencyMemberStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgencyMemberStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgencyMemberStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAgencyMemberStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgencyMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyMemberRole | EnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyMemberRole[] | ListEnumAgencyMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.AgencyMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumAgencyMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumAgencyInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyInvitationStatus | EnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel> | $Enums.AgencyInvitationStatus
  }

  export type NestedEnumAgencyInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgencyInvitationStatus | EnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgencyInvitationStatus[] | ListEnumAgencyInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgencyInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgencyInvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumAgencyInvitationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyListingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyListingTypeFilter<$PrismaModel> | $Enums.PropertyListingType
  }

  export type NestedEnumPropertyListingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyListingType | EnumPropertyListingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyListingType[] | ListEnumPropertyListingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyListingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyListingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyListingTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyListingTypeFilter<$PrismaModel>
  }

  export type NestedEnumExternalListingCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalListingCategory | EnumExternalListingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalListingCategoryFilter<$PrismaModel> | $Enums.ExternalListingCategory
  }

  export type NestedEnumExternalListingCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalListingCategory | EnumExternalListingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalListingCategory[] | ListEnumExternalListingCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalListingCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExternalListingCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalListingCategoryFilter<$PrismaModel>
    _max?: NestedEnumExternalListingCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedEnumPropertyOrientationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyOrientation | EnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel> | $Enums.PropertyOrientation | null
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedEnumPropertyOrientationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyOrientation | EnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyOrientation[] | ListEnumPropertyOrientationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyOrientationNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyOrientation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyOrientationNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumEngagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeFilter<$PrismaModel> | $Enums.EngagementType
  }

  export type NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementTypeFilter<$PrismaModel>
  }

  export type NestedEnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserLanguageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLanguage | EnumUserLanguageFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLanguageNullableFilter<$PrismaModel> | $Enums.UserLanguage | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserLanguageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLanguage | EnumUserLanguageFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLanguage[] | ListEnumUserLanguageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLanguageNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserLanguage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserLanguageNullableFilter<$PrismaModel>
    _max?: NestedEnumUserLanguageNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAgencyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserCreateManyAgencyInputEnvelope = {
    data: UserCreateManyAgencyInput | UserCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyReviewCreateWithoutAgencyInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    client: ClientCreateNestedOneWithoutReviewsInput
  }

  export type AgencyReviewUncheckedCreateWithoutAgencyInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
  }

  export type AgencyReviewCreateOrConnectWithoutAgencyInput = {
    where: AgencyReviewWhereUniqueInput
    create: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyReviewCreateManyAgencyInputEnvelope = {
    data: AgencyReviewCreateManyAgencyInput | AgencyReviewCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutAgencyInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAgencyInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput>
  }

  export type PropertyCreateManyAgencyInputEnvelope = {
    data: PropertyCreateManyAgencyInput | PropertyCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type PropertySaleCreateWithoutAgencyInput = {
    id?: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
    property: PropertyCreateNestedOneWithoutPropertySaleInput
  }

  export type PropertySaleUncheckedCreateWithoutAgencyInput = {
    id?: string
    propertyId: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
  }

  export type PropertySaleCreateOrConnectWithoutAgencyInput = {
    where: PropertySaleWhereUniqueInput
    create: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput>
  }

  export type PropertySaleCreateManyAgencyInputEnvelope = {
    data: PropertySaleCreateManyAgencyInput | PropertySaleCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyViewCreateWithoutAgencyInput = {
    id?: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutAgencyViewInput
  }

  export type AgencyViewUncheckedCreateWithoutAgencyInput = {
    id?: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyViewCreateOrConnectWithoutAgencyInput = {
    where: AgencyViewWhereUniqueInput
    create: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyViewCreateManyAgencyInputEnvelope = {
    data: AgencyViewCreateManyAgencyInput | AgencyViewCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type ProposalOfferCreateWithoutAgencyInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutOffersInput
    proposalCollaboration?: ProposalCollaborationCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferUncheckedCreateWithoutAgencyInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    proposalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferCreateOrConnectWithoutAgencyInput = {
    where: ProposalOfferWhereUniqueInput
    create: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput>
  }

  export type ProposalOfferCreateManyAgencyInputEnvelope = {
    data: ProposalOfferCreateManyAgencyInput | ProposalOfferCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencySubmissionReviewCreateWithoutAgencyInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySubmissionReviewUncheckedCreateWithoutAgencyInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySubmissionReviewCreateOrConnectWithoutAgencyInput = {
    where: AgencySubmissionReviewWhereUniqueInput
    create: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
  }

  export type UserCreateWithoutOwnedAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutOwnedAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutOwnedAgencyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedAgencyInput, UserUncheckedCreateWithoutOwnedAgencyInput>
  }

  export type AgencyMemberCreateWithoutAgencyInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutAgencyInput = {
    id?: string
    userId: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutAgencyInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyMemberCreateManyAgencyInputEnvelope = {
    data: AgencyMemberCreateManyAgencyInput | AgencyMemberCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyInvitationCreateWithoutAgencyInput = {
    id?: string
    token: string
    email: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutAgencyInvitationSenderInput
  }

  export type AgencyInvitationUncheckedCreateWithoutAgencyInput = {
    id?: string
    token: string
    email: string
    senderId: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyInvitationCreateOrConnectWithoutAgencyInput = {
    where: AgencyInvitationWhereUniqueInput
    create: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyInvitationCreateManyAgencyInputEnvelope = {
    data: AgencyInvitationCreateManyAgencyInput | AgencyInvitationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientCreateWithoutAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientCreateOrConnectWithoutAgencyInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyClientCreateManyAgencyInputEnvelope = {
    data: AgencyClientCreateManyAgencyInput | AgencyClientCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
  }

  export type UserUpdateManyWithWhereWithoutAgencyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    location?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    accessToken?: StringNullableFilter<"User"> | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    language?: EnumUserLanguageNullableFilter<"User"> | $Enums.UserLanguage | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clientId?: StringNullableFilter<"User"> | string | null
    agencyId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    ipAddress?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type AgencyReviewUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyReviewWhereUniqueInput
    update: XOR<AgencyReviewUpdateWithoutAgencyInput, AgencyReviewUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyReviewCreateWithoutAgencyInput, AgencyReviewUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyReviewUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyReviewWhereUniqueInput
    data: XOR<AgencyReviewUpdateWithoutAgencyInput, AgencyReviewUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyReviewUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyReviewScalarWhereInput
    data: XOR<AgencyReviewUpdateManyMutationInput, AgencyReviewUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyReviewScalarWhereInput = {
    AND?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
    OR?: AgencyReviewScalarWhereInput[]
    NOT?: AgencyReviewScalarWhereInput | AgencyReviewScalarWhereInput[]
    id?: StringFilter<"AgencyReview"> | string
    approved?: BoolFilter<"AgencyReview"> | boolean
    rating?: FloatFilter<"AgencyReview"> | number
    comment?: StringNullableFilter<"AgencyReview"> | string | null
    createdAt?: DateTimeFilter<"AgencyReview"> | Date | string
    attributes?: JsonNullableFilter<"AgencyReview">
    agencyId?: StringFilter<"AgencyReview"> | string
    clientId?: StringFilter<"AgencyReview"> | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutAgencyInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutAgencyInput, PropertyUncheckedUpdateWithoutAgencyInput>
    create: XOR<PropertyCreateWithoutAgencyInput, PropertyUncheckedCreateWithoutAgencyInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutAgencyInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutAgencyInput, PropertyUncheckedUpdateWithoutAgencyInput>
  }

  export type PropertyUpdateManyWithWhereWithoutAgencyInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutAgencyInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: JsonFilter<"Property">
    latitude?: FloatFilter<"Property"> | number
    address?: StringFilter<"Property"> | string
    longitude?: FloatFilter<"Property"> | number
    agencyId?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    price?: IntFilter<"Property"> | number
    hasApproximatePrice?: BoolNullableFilter<"Property"> | boolean | null
    approximatePrice?: IntNullableFilter<"Property"> | number | null
    estimationPrice?: IntNullableFilter<"Property"> | number | null
    size?: IntFilter<"Property"> | number
    description?: JsonFilter<"Property">
    slug?: StringNullableFilter<"Property"> | string | null
    photos?: JsonNullableFilter<"Property">
    video?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    createdBy?: StringFilter<"Property"> | string
    createdByMemberId?: StringNullableFilter<"Property"> | string | null
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    attributes?: JsonNullableFilter<"Property">
    yearBuilt?: DateTimeNullableFilter<"Property"> | Date | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    builder?: StringNullableFilter<"Property"> | string | null
    propertyCadastralMunicipality?: StringNullableFilter<"Property"> | string | null
    propertyDeed?: StringNullableFilter<"Property"> | string | null
    inDevelopment?: BoolNullableFilter<"Property"> | boolean | null
    inDevelopmentUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyPlan?: JsonNullableFilter<"Property">
    poi?: JsonNullableFilter<"Property">
    featured?: BoolFilter<"Property"> | boolean
    featuredUntil?: DateTimeNullableFilter<"Property"> | Date | string | null
    orientation?: EnumPropertyOrientationNullableFilter<"Property"> | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Property"> | $Enums.PropertyListingType
    propertyLocationId?: StringNullableFilter<"Property"> | string | null
    modifications?: JsonNullableFilter<"Property">
    categoryId?: StringNullableFilter<"Property"> | string | null
    subcategoryId?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringNullableFilter<"Property"> | string | null
    renterId?: StringNullableFilter<"Property"> | string | null
    externalId?: StringNullableFilter<"Property"> | string | null
    autoRenewEnabled?: BoolFilter<"Property"> | boolean
    autoRenewStartDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    autoRenewEndDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    lastAutoRenewedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    bumpedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
  }

  export type PropertySaleUpsertWithWhereUniqueWithoutAgencyInput = {
    where: PropertySaleWhereUniqueInput
    update: XOR<PropertySaleUpdateWithoutAgencyInput, PropertySaleUncheckedUpdateWithoutAgencyInput>
    create: XOR<PropertySaleCreateWithoutAgencyInput, PropertySaleUncheckedCreateWithoutAgencyInput>
  }

  export type PropertySaleUpdateWithWhereUniqueWithoutAgencyInput = {
    where: PropertySaleWhereUniqueInput
    data: XOR<PropertySaleUpdateWithoutAgencyInput, PropertySaleUncheckedUpdateWithoutAgencyInput>
  }

  export type PropertySaleUpdateManyWithWhereWithoutAgencyInput = {
    where: PropertySaleScalarWhereInput
    data: XOR<PropertySaleUpdateManyMutationInput, PropertySaleUncheckedUpdateManyWithoutAgencyInput>
  }

  export type PropertySaleScalarWhereInput = {
    AND?: PropertySaleScalarWhereInput | PropertySaleScalarWhereInput[]
    OR?: PropertySaleScalarWhereInput[]
    NOT?: PropertySaleScalarWhereInput | PropertySaleScalarWhereInput[]
    id?: StringFilter<"PropertySale"> | string
    propertyId?: StringFilter<"PropertySale"> | string
    agencyId?: StringFilter<"PropertySale"> | string
    propertyDeed?: StringFilter<"PropertySale"> | string
    soldAt?: DateTimeFilter<"PropertySale"> | Date | string
    soldFor?: IntFilter<"PropertySale"> | number
    visibility?: BoolFilter<"PropertySale"> | boolean
  }

  export type AgencyViewUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyViewWhereUniqueInput
    update: XOR<AgencyViewUpdateWithoutAgencyInput, AgencyViewUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyViewCreateWithoutAgencyInput, AgencyViewUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyViewUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyViewWhereUniqueInput
    data: XOR<AgencyViewUpdateWithoutAgencyInput, AgencyViewUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyViewUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyViewScalarWhereInput
    data: XOR<AgencyViewUpdateManyMutationInput, AgencyViewUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyViewScalarWhereInput = {
    AND?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
    OR?: AgencyViewScalarWhereInput[]
    NOT?: AgencyViewScalarWhereInput | AgencyViewScalarWhereInput[]
    id?: StringFilter<"AgencyView"> | string
    agencyId?: StringFilter<"AgencyView"> | string
    clientId?: StringNullableFilter<"AgencyView"> | string | null
    additionalInfo?: JsonNullableFilter<"AgencyView">
    viewDate?: DateTimeFilter<"AgencyView"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyView"> | Date | string
  }

  export type ProposalOfferUpsertWithWhereUniqueWithoutAgencyInput = {
    where: ProposalOfferWhereUniqueInput
    update: XOR<ProposalOfferUpdateWithoutAgencyInput, ProposalOfferUncheckedUpdateWithoutAgencyInput>
    create: XOR<ProposalOfferCreateWithoutAgencyInput, ProposalOfferUncheckedCreateWithoutAgencyInput>
  }

  export type ProposalOfferUpdateWithWhereUniqueWithoutAgencyInput = {
    where: ProposalOfferWhereUniqueInput
    data: XOR<ProposalOfferUpdateWithoutAgencyInput, ProposalOfferUncheckedUpdateWithoutAgencyInput>
  }

  export type ProposalOfferUpdateManyWithWhereWithoutAgencyInput = {
    where: ProposalOfferScalarWhereInput
    data: XOR<ProposalOfferUpdateManyMutationInput, ProposalOfferUncheckedUpdateManyWithoutAgencyInput>
  }

  export type ProposalOfferScalarWhereInput = {
    AND?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
    OR?: ProposalOfferScalarWhereInput[]
    NOT?: ProposalOfferScalarWhereInput | ProposalOfferScalarWhereInput[]
    id?: StringFilter<"ProposalOffer"> | string
    title?: StringFilter<"ProposalOffer"> | string
    price?: IntFilter<"ProposalOffer"> | number
    description?: StringFilter<"ProposalOffer"> | string
    saleTimeline?: DateTimeFilter<"ProposalOffer"> | Date | string
    proposalId?: StringFilter<"ProposalOffer"> | string
    agencyId?: StringFilter<"ProposalOffer"> | string
    createdAt?: DateTimeFilter<"ProposalOffer"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalOffer"> | Date | string
  }

  export type AgencySubmissionReviewUpsertWithoutAgencyInput = {
    update: XOR<AgencySubmissionReviewUpdateWithoutAgencyInput, AgencySubmissionReviewUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencySubmissionReviewCreateWithoutAgencyInput, AgencySubmissionReviewUncheckedCreateWithoutAgencyInput>
    where?: AgencySubmissionReviewWhereInput
  }

  export type AgencySubmissionReviewUpdateToOneWithWhereWithoutAgencyInput = {
    where?: AgencySubmissionReviewWhereInput
    data: XOR<AgencySubmissionReviewUpdateWithoutAgencyInput, AgencySubmissionReviewUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencySubmissionReviewUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySubmissionReviewUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutOwnedAgencyInput = {
    update: XOR<UserUpdateWithoutOwnedAgencyInput, UserUncheckedUpdateWithoutOwnedAgencyInput>
    create: XOR<UserCreateWithoutOwnedAgencyInput, UserUncheckedCreateWithoutOwnedAgencyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedAgencyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedAgencyInput, UserUncheckedUpdateWithoutOwnedAgencyInput>
  }

  export type UserUpdateWithoutOwnedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AgencyMemberUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyMemberWhereUniqueInput
    update: XOR<AgencyMemberUpdateWithoutAgencyInput, AgencyMemberUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyMemberCreateWithoutAgencyInput, AgencyMemberUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyMemberUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyMemberWhereUniqueInput
    data: XOR<AgencyMemberUpdateWithoutAgencyInput, AgencyMemberUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyMemberUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyMemberScalarWhereInput
    data: XOR<AgencyMemberUpdateManyMutationInput, AgencyMemberUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyMemberScalarWhereInput = {
    AND?: AgencyMemberScalarWhereInput | AgencyMemberScalarWhereInput[]
    OR?: AgencyMemberScalarWhereInput[]
    NOT?: AgencyMemberScalarWhereInput | AgencyMemberScalarWhereInput[]
    id?: StringFilter<"AgencyMember"> | string
    userId?: StringFilter<"AgencyMember"> | string
    agencyId?: StringNullableFilter<"AgencyMember"> | string | null
    status?: EnumAgencyMemberStatusNullableFilter<"AgencyMember"> | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFilter<"AgencyMember"> | $Enums.AgencyMemberRole
    createdAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgencyMember"> | Date | string | null
  }

  export type AgencyInvitationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyInvitationWhereUniqueInput
    update: XOR<AgencyInvitationUpdateWithoutAgencyInput, AgencyInvitationUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyInvitationCreateWithoutAgencyInput, AgencyInvitationUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyInvitationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyInvitationWhereUniqueInput
    data: XOR<AgencyInvitationUpdateWithoutAgencyInput, AgencyInvitationUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyInvitationUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyInvitationScalarWhereInput
    data: XOR<AgencyInvitationUpdateManyMutationInput, AgencyInvitationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyInvitationScalarWhereInput = {
    AND?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
    OR?: AgencyInvitationScalarWhereInput[]
    NOT?: AgencyInvitationScalarWhereInput | AgencyInvitationScalarWhereInput[]
    id?: StringFilter<"AgencyInvitation"> | string
    token?: StringFilter<"AgencyInvitation"> | string
    agencyId?: StringFilter<"AgencyInvitation"> | string
    email?: StringFilter<"AgencyInvitation"> | string
    senderId?: StringFilter<"AgencyInvitation"> | string
    status?: EnumAgencyInvitationStatusFilter<"AgencyInvitation"> | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyInvitation"> | Date | string
  }

  export type AgencyClientUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyClientWhereUniqueInput
    update: XOR<AgencyClientUpdateWithoutAgencyInput, AgencyClientUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyClientCreateWithoutAgencyInput, AgencyClientUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyClientUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyClientWhereUniqueInput
    data: XOR<AgencyClientUpdateWithoutAgencyInput, AgencyClientUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyClientUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyClientScalarWhereInput
    data: XOR<AgencyClientUpdateManyMutationInput, AgencyClientUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencyClientScalarWhereInput = {
    AND?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
    OR?: AgencyClientScalarWhereInput[]
    NOT?: AgencyClientScalarWhereInput | AgencyClientScalarWhereInput[]
    id?: StringFilter<"AgencyClient"> | string
    name?: StringFilter<"AgencyClient"> | string
    lastName?: StringNullableFilter<"AgencyClient"> | string | null
    email?: StringNullableFilter<"AgencyClient"> | string | null
    phone?: StringNullableFilter<"AgencyClient"> | string | null
    status?: EnumAgencyClientStatusNullableFilter<"AgencyClient"> | $Enums.AgencyClientStatus | null
    location?: StringNullableFilter<"AgencyClient"> | string | null
    agencyId?: StringFilter<"AgencyClient"> | string
    createdById?: StringNullableFilter<"AgencyClient"> | string | null
    createdAt?: DateTimeFilter<"AgencyClient"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClient"> | Date | string
  }

  export type AgencyClientCreateWithoutMemberNotesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateWithoutMemberNotesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientCreateOrConnectWithoutMemberNotesInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutMemberNotesInput, AgencyClientUncheckedCreateWithoutMemberNotesInput>
  }

  export type AgencyMemberCreateWithoutAgencyClientNotesInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutAgencyClientNotesInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutAgencyClientNotesInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutAgencyClientNotesInput, AgencyMemberUncheckedCreateWithoutAgencyClientNotesInput>
  }

  export type AgencyClientUpsertWithoutMemberNotesInput = {
    update: XOR<AgencyClientUpdateWithoutMemberNotesInput, AgencyClientUncheckedUpdateWithoutMemberNotesInput>
    create: XOR<AgencyClientCreateWithoutMemberNotesInput, AgencyClientUncheckedCreateWithoutMemberNotesInput>
    where?: AgencyClientWhereInput
  }

  export type AgencyClientUpdateToOneWithWhereWithoutMemberNotesInput = {
    where?: AgencyClientWhereInput
    data: XOR<AgencyClientUpdateWithoutMemberNotesInput, AgencyClientUncheckedUpdateWithoutMemberNotesInput>
  }

  export type AgencyClientUpdateWithoutMemberNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutMemberNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type AgencyMemberUpsertWithoutAgencyClientNotesInput = {
    update: XOR<AgencyMemberUpdateWithoutAgencyClientNotesInput, AgencyMemberUncheckedUpdateWithoutAgencyClientNotesInput>
    create: XOR<AgencyMemberCreateWithoutAgencyClientNotesInput, AgencyMemberUncheckedCreateWithoutAgencyClientNotesInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutAgencyClientNotesInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutAgencyClientNotesInput, AgencyMemberUncheckedUpdateWithoutAgencyClientNotesInput>
  }

  export type AgencyMemberUpdateWithoutAgencyClientNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutAgencyClientNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyClientNotesCreateWithoutAgencyClientInput = {
    id?: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByMember: AgencyMemberCreateNestedOneWithoutAgencyClientNotesInput
  }

  export type AgencyClientNotesUncheckedCreateWithoutAgencyClientInput = {
    id?: string
    title: string
    description: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientNotesCreateOrConnectWithoutAgencyClientInput = {
    where: AgencyClientNotesWhereUniqueInput
    create: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyClientNotesCreateManyAgencyClientInputEnvelope = {
    data: AgencyClientNotesCreateManyAgencyClientInput | AgencyClientNotesCreateManyAgencyClientInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutAgencyClientInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyClientInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyClientInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyClientInput, AgencyUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyMemberCreateWithoutAgencyClientInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutAgencyClientInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutAgencyClientInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutAgencyClientInput, AgencyMemberUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceCreateWithoutAgencyClientInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientPreferenceInput
  }

  export type AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    createdById?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type AgencyClientPreferenceCreateOrConnectWithoutAgencyClientInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    create: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceCreateManyAgencyClientInputEnvelope = {
    data: AgencyClientPreferenceCreateManyAgencyClientInput | AgencyClientPreferenceCreateManyAgencyClientInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutOwnerInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyCreateManyOwnerInputEnvelope = {
    data: PropertyCreateManyOwnerInput | PropertyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutRenterInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutRenterInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRenterInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput>
  }

  export type PropertyCreateManyRenterInputEnvelope = {
    data: PropertyCreateManyRenterInput | PropertyCreateManyRenterInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientNotesUpsertWithWhereUniqueWithoutAgencyClientInput = {
    where: AgencyClientNotesWhereUniqueInput
    update: XOR<AgencyClientNotesUpdateWithoutAgencyClientInput, AgencyClientNotesUncheckedUpdateWithoutAgencyClientInput>
    create: XOR<AgencyClientNotesCreateWithoutAgencyClientInput, AgencyClientNotesUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyClientNotesUpdateWithWhereUniqueWithoutAgencyClientInput = {
    where: AgencyClientNotesWhereUniqueInput
    data: XOR<AgencyClientNotesUpdateWithoutAgencyClientInput, AgencyClientNotesUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyClientNotesUpdateManyWithWhereWithoutAgencyClientInput = {
    where: AgencyClientNotesScalarWhereInput
    data: XOR<AgencyClientNotesUpdateManyMutationInput, AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientInput>
  }

  export type AgencyClientNotesScalarWhereInput = {
    AND?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
    OR?: AgencyClientNotesScalarWhereInput[]
    NOT?: AgencyClientNotesScalarWhereInput | AgencyClientNotesScalarWhereInput[]
    id?: StringFilter<"AgencyClientNotes"> | string
    title?: StringFilter<"AgencyClientNotes"> | string
    description?: StringFilter<"AgencyClientNotes"> | string
    agencyClientId?: StringFilter<"AgencyClientNotes"> | string
    createdById?: StringFilter<"AgencyClientNotes"> | string
    createdAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientNotes"> | Date | string
  }

  export type AgencyUpsertWithoutAgencyClientInput = {
    update: XOR<AgencyUpdateWithoutAgencyClientInput, AgencyUncheckedUpdateWithoutAgencyClientInput>
    create: XOR<AgencyCreateWithoutAgencyClientInput, AgencyUncheckedCreateWithoutAgencyClientInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyClientInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyClientInput, AgencyUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyMemberUpsertWithoutAgencyClientInput = {
    update: XOR<AgencyMemberUpdateWithoutAgencyClientInput, AgencyMemberUncheckedUpdateWithoutAgencyClientInput>
    create: XOR<AgencyMemberCreateWithoutAgencyClientInput, AgencyMemberUncheckedCreateWithoutAgencyClientInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutAgencyClientInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutAgencyClientInput, AgencyMemberUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyMemberUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyClientPreferenceUpsertWithWhereUniqueWithoutAgencyClientInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    update: XOR<AgencyClientPreferenceUpdateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedUpdateWithoutAgencyClientInput>
    create: XOR<AgencyClientPreferenceCreateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedCreateWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceUpdateWithWhereUniqueWithoutAgencyClientInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    data: XOR<AgencyClientPreferenceUpdateWithoutAgencyClientInput, AgencyClientPreferenceUncheckedUpdateWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceUpdateManyWithWhereWithoutAgencyClientInput = {
    where: AgencyClientPreferenceScalarWhereInput
    data: XOR<AgencyClientPreferenceUpdateManyMutationInput, AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientInput>
  }

  export type AgencyClientPreferenceScalarWhereInput = {
    AND?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
    OR?: AgencyClientPreferenceScalarWhereInput[]
    NOT?: AgencyClientPreferenceScalarWhereInput | AgencyClientPreferenceScalarWhereInput[]
    id?: StringFilter<"AgencyClientPreference"> | string
    propertyType?: EnumPropertyTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyType | null
    listingType?: EnumPropertyListingTypeNullableFilter<"AgencyClientPreference"> | $Enums.PropertyListingType | null
    minPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxPrice?: IntNullableFilter<"AgencyClientPreference"> | number | null
    minSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    maxSize?: IntNullableFilter<"AgencyClientPreference"> | number | null
    categoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    subcategoryId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    locationId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    location?: StringNullableFilter<"AgencyClientPreference"> | string | null
    createdById?: StringNullableFilter<"AgencyClientPreference"> | string | null
    agencyClientId?: StringNullableFilter<"AgencyClientPreference"> | string | null
    offeredPropertyIds?: StringNullableListFilter<"AgencyClientPreference">
    createdAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyClientPreference"> | Date | string
    status?: EnumAgencyClientPreferenceStatusFilter<"AgencyClientPreference"> | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: DateTimeNullableFilter<"AgencyClientPreference"> | Date | string | null
  }

  export type PropertyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyUpsertWithWhereUniqueWithoutRenterInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutRenterInput, PropertyUncheckedUpdateWithoutRenterInput>
    create: XOR<PropertyCreateWithoutRenterInput, PropertyUncheckedCreateWithoutRenterInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutRenterInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutRenterInput, PropertyUncheckedUpdateWithoutRenterInput>
  }

  export type PropertyUpdateManyWithWhereWithoutRenterInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutRenterInput>
  }

  export type AgencyMemberCreateWithoutAgencyClientPreferenceInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutAgencyClientPreferenceInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutAgencyClientPreferenceInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedCreateWithoutAgencyClientPreferenceInput>
  }

  export type AgencyClientCreateWithoutPreferencesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateWithoutPreferencesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientCreateOrConnectWithoutPreferencesInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutPreferencesInput, AgencyClientUncheckedCreateWithoutPreferencesInput>
  }

  export type AgencyMemberUpsertWithoutAgencyClientPreferenceInput = {
    update: XOR<AgencyMemberUpdateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedUpdateWithoutAgencyClientPreferenceInput>
    create: XOR<AgencyMemberCreateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedCreateWithoutAgencyClientPreferenceInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutAgencyClientPreferenceInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutAgencyClientPreferenceInput, AgencyMemberUncheckedUpdateWithoutAgencyClientPreferenceInput>
  }

  export type AgencyMemberUpdateWithoutAgencyClientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutAgencyClientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyClientUpsertWithoutPreferencesInput = {
    update: XOR<AgencyClientUpdateWithoutPreferencesInput, AgencyClientUncheckedUpdateWithoutPreferencesInput>
    create: XOR<AgencyClientCreateWithoutPreferencesInput, AgencyClientUncheckedCreateWithoutPreferencesInput>
    where?: AgencyClientWhereInput
  }

  export type AgencyClientUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: AgencyClientWhereInput
    data: XOR<AgencyClientUpdateWithoutPreferencesInput, AgencyClientUncheckedUpdateWithoutPreferencesInput>
  }

  export type AgencyClientUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type UserCreateWithoutAgencyMemberInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAgencyMemberInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAgencyMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyMemberInput, UserUncheckedCreateWithoutAgencyMemberInput>
  }

  export type AgencyCreateWithoutAgencyMembersInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyMembersInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyMembersInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyMembersInput, AgencyUncheckedCreateWithoutAgencyMembersInput>
  }

  export type PropertyCreateWithoutCreatedByMemberInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutCreatedByMemberInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCreatedByMemberInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput>
  }

  export type PropertyCreateManyCreatedByMemberInputEnvelope = {
    data: PropertyCreateManyCreatedByMemberInput | PropertyCreateManyCreatedByMemberInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientNotesCreateWithoutCreatedByMemberInput = {
    id?: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyClient: AgencyClientCreateNestedOneWithoutMemberNotesInput
  }

  export type AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput = {
    id?: string
    title: string
    description: string
    agencyClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientNotesCreateOrConnectWithoutCreatedByMemberInput = {
    where: AgencyClientNotesWhereUniqueInput
    create: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput>
  }

  export type AgencyClientNotesCreateManyCreatedByMemberInputEnvelope = {
    data: AgencyClientNotesCreateManyCreatedByMemberInput | AgencyClientNotesCreateManyCreatedByMemberInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientCreateWithoutCreatedByInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientCreateOrConnectWithoutCreatedByInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyClientCreateManyCreatedByInputEnvelope = {
    data: AgencyClientCreateManyCreatedByInput | AgencyClientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AgencyClientPreferenceCreateWithoutCreatedByInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
    agencyClient?: AgencyClientCreateNestedOneWithoutPreferencesInput
  }

  export type AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    agencyClientId?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type AgencyClientPreferenceCreateOrConnectWithoutCreatedByInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    create: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyClientPreferenceCreateManyCreatedByInputEnvelope = {
    data: AgencyClientPreferenceCreateManyCreatedByInput | AgencyClientPreferenceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AgentReminderCreateWithoutAgencyMemberInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgentReminderUncheckedCreateWithoutAgencyMemberInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgentReminderCreateOrConnectWithoutAgencyMemberInput = {
    where: AgentReminderWhereUniqueInput
    create: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput>
  }

  export type AgentReminderCreateManyAgencyMemberInputEnvelope = {
    data: AgentReminderCreateManyAgencyMemberInput | AgentReminderCreateManyAgencyMemberInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgencyMemberInput = {
    update: XOR<UserUpdateWithoutAgencyMemberInput, UserUncheckedUpdateWithoutAgencyMemberInput>
    create: XOR<UserCreateWithoutAgencyMemberInput, UserUncheckedCreateWithoutAgencyMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyMemberInput, UserUncheckedUpdateWithoutAgencyMemberInput>
  }

  export type UserUpdateWithoutAgencyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AgencyUpsertWithoutAgencyMembersInput = {
    update: XOR<AgencyUpdateWithoutAgencyMembersInput, AgencyUncheckedUpdateWithoutAgencyMembersInput>
    create: XOR<AgencyCreateWithoutAgencyMembersInput, AgencyUncheckedCreateWithoutAgencyMembersInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyMembersInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyMembersInput, AgencyUncheckedUpdateWithoutAgencyMembersInput>
  }

  export type AgencyUpdateWithoutAgencyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutCreatedByMemberInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCreatedByMemberInput, PropertyUncheckedUpdateWithoutCreatedByMemberInput>
    create: XOR<PropertyCreateWithoutCreatedByMemberInput, PropertyUncheckedCreateWithoutCreatedByMemberInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCreatedByMemberInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCreatedByMemberInput, PropertyUncheckedUpdateWithoutCreatedByMemberInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCreatedByMemberInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutCreatedByMemberInput>
  }

  export type AgencyClientNotesUpsertWithWhereUniqueWithoutCreatedByMemberInput = {
    where: AgencyClientNotesWhereUniqueInput
    update: XOR<AgencyClientNotesUpdateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedUpdateWithoutCreatedByMemberInput>
    create: XOR<AgencyClientNotesCreateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedCreateWithoutCreatedByMemberInput>
  }

  export type AgencyClientNotesUpdateWithWhereUniqueWithoutCreatedByMemberInput = {
    where: AgencyClientNotesWhereUniqueInput
    data: XOR<AgencyClientNotesUpdateWithoutCreatedByMemberInput, AgencyClientNotesUncheckedUpdateWithoutCreatedByMemberInput>
  }

  export type AgencyClientNotesUpdateManyWithWhereWithoutCreatedByMemberInput = {
    where: AgencyClientNotesScalarWhereInput
    data: XOR<AgencyClientNotesUpdateManyMutationInput, AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberInput>
  }

  export type AgencyClientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyClientWhereUniqueInput
    update: XOR<AgencyClientUpdateWithoutCreatedByInput, AgencyClientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AgencyClientCreateWithoutCreatedByInput, AgencyClientUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyClientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyClientWhereUniqueInput
    data: XOR<AgencyClientUpdateWithoutCreatedByInput, AgencyClientUncheckedUpdateWithoutCreatedByInput>
  }

  export type AgencyClientUpdateManyWithWhereWithoutCreatedByInput = {
    where: AgencyClientScalarWhereInput
    data: XOR<AgencyClientUpdateManyMutationInput, AgencyClientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AgencyClientPreferenceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    update: XOR<AgencyClientPreferenceUpdateWithoutCreatedByInput, AgencyClientPreferenceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AgencyClientPreferenceCreateWithoutCreatedByInput, AgencyClientPreferenceUncheckedCreateWithoutCreatedByInput>
  }

  export type AgencyClientPreferenceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AgencyClientPreferenceWhereUniqueInput
    data: XOR<AgencyClientPreferenceUpdateWithoutCreatedByInput, AgencyClientPreferenceUncheckedUpdateWithoutCreatedByInput>
  }

  export type AgencyClientPreferenceUpdateManyWithWhereWithoutCreatedByInput = {
    where: AgencyClientPreferenceScalarWhereInput
    data: XOR<AgencyClientPreferenceUpdateManyMutationInput, AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AgentReminderUpsertWithWhereUniqueWithoutAgencyMemberInput = {
    where: AgentReminderWhereUniqueInput
    update: XOR<AgentReminderUpdateWithoutAgencyMemberInput, AgentReminderUncheckedUpdateWithoutAgencyMemberInput>
    create: XOR<AgentReminderCreateWithoutAgencyMemberInput, AgentReminderUncheckedCreateWithoutAgencyMemberInput>
  }

  export type AgentReminderUpdateWithWhereUniqueWithoutAgencyMemberInput = {
    where: AgentReminderWhereUniqueInput
    data: XOR<AgentReminderUpdateWithoutAgencyMemberInput, AgentReminderUncheckedUpdateWithoutAgencyMemberInput>
  }

  export type AgentReminderUpdateManyWithWhereWithoutAgencyMemberInput = {
    where: AgentReminderScalarWhereInput
    data: XOR<AgentReminderUpdateManyMutationInput, AgentReminderUncheckedUpdateManyWithoutAgencyMemberInput>
  }

  export type AgentReminderScalarWhereInput = {
    AND?: AgentReminderScalarWhereInput | AgentReminderScalarWhereInput[]
    OR?: AgentReminderScalarWhereInput[]
    NOT?: AgentReminderScalarWhereInput | AgentReminderScalarWhereInput[]
    id?: StringFilter<"AgentReminder"> | string
    title?: StringFilter<"AgentReminder"> | string
    description?: StringFilter<"AgentReminder"> | string
    status?: EnumReminderStatusFilter<"AgentReminder"> | $Enums.ReminderStatus
    agencyMemberId?: StringFilter<"AgentReminder"> | string
    startDate?: DateTimeFilter<"AgentReminder"> | Date | string
    isRecurring?: BoolFilter<"AgentReminder"> | boolean
    endDate?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    lastSentAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AgentReminder"> | Date | string | null
  }

  export type AgencyCreateWithoutAgencyInvitationInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyInvitationInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyInvitationInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyInvitationInput, AgencyUncheckedCreateWithoutAgencyInvitationInput>
  }

  export type UserCreateWithoutAgencyInvitationSenderInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
  }

  export type UserUncheckedCreateWithoutAgencyInvitationSenderInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
  }

  export type UserCreateOrConnectWithoutAgencyInvitationSenderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyInvitationSenderInput, UserUncheckedCreateWithoutAgencyInvitationSenderInput>
  }

  export type AgencyUpsertWithoutAgencyInvitationInput = {
    update: XOR<AgencyUpdateWithoutAgencyInvitationInput, AgencyUncheckedUpdateWithoutAgencyInvitationInput>
    create: XOR<AgencyCreateWithoutAgencyInvitationInput, AgencyUncheckedCreateWithoutAgencyInvitationInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyInvitationInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyInvitationInput, AgencyUncheckedUpdateWithoutAgencyInvitationInput>
  }

  export type AgencyUpdateWithoutAgencyInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserUpsertWithoutAgencyInvitationSenderInput = {
    update: XOR<UserUpdateWithoutAgencyInvitationSenderInput, UserUncheckedUpdateWithoutAgencyInvitationSenderInput>
    create: XOR<UserCreateWithoutAgencyInvitationSenderInput, UserUncheckedCreateWithoutAgencyInvitationSenderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyInvitationSenderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyInvitationSenderInput, UserUncheckedUpdateWithoutAgencyInvitationSenderInput>
  }

  export type UserUpdateWithoutAgencyInvitationSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyInvitationSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
  }

  export type AgencyCreateWithoutAgencySubmissionReviewInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencySubmissionReviewInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencySubmissionReviewInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencySubmissionReviewInput, AgencyUncheckedCreateWithoutAgencySubmissionReviewInput>
  }

  export type AgencyUpsertWithoutAgencySubmissionReviewInput = {
    update: XOR<AgencyUpdateWithoutAgencySubmissionReviewInput, AgencyUncheckedUpdateWithoutAgencySubmissionReviewInput>
    create: XOR<AgencyCreateWithoutAgencySubmissionReviewInput, AgencyUncheckedCreateWithoutAgencySubmissionReviewInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencySubmissionReviewInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencySubmissionReviewInput, AgencyUncheckedUpdateWithoutAgencySubmissionReviewInput>
  }

  export type AgencyUpdateWithoutAgencySubmissionReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencySubmissionReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateWithoutAgencyViewInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyViewInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyViewInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyViewInput, AgencyUncheckedCreateWithoutAgencyViewInput>
  }

  export type ClientCreateWithoutAgencyViewInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAgencyViewInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAgencyViewInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAgencyViewInput, ClientUncheckedCreateWithoutAgencyViewInput>
  }

  export type AgencyUpsertWithoutAgencyViewInput = {
    update: XOR<AgencyUpdateWithoutAgencyViewInput, AgencyUncheckedUpdateWithoutAgencyViewInput>
    create: XOR<AgencyCreateWithoutAgencyViewInput, AgencyUncheckedCreateWithoutAgencyViewInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyViewInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyViewInput, AgencyUncheckedUpdateWithoutAgencyViewInput>
  }

  export type AgencyUpdateWithoutAgencyViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type ClientUpsertWithoutAgencyViewInput = {
    update: XOR<ClientUpdateWithoutAgencyViewInput, ClientUncheckedUpdateWithoutAgencyViewInput>
    create: XOR<ClientCreateWithoutAgencyViewInput, ClientUncheckedCreateWithoutAgencyViewInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAgencyViewInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAgencyViewInput, ClientUncheckedUpdateWithoutAgencyViewInput>
  }

  export type ClientUpdateWithoutAgencyViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAgencyViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgencyCreateWithoutRatingsInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutRatingsInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutRatingsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutRatingsInput, AgencyUncheckedCreateWithoutRatingsInput>
  }

  export type ClientCreateWithoutReviewsInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReviewsInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReviewsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
  }

  export type AgencyUpsertWithoutRatingsInput = {
    update: XOR<AgencyUpdateWithoutRatingsInput, AgencyUncheckedUpdateWithoutRatingsInput>
    create: XOR<AgencyCreateWithoutRatingsInput, AgencyUncheckedCreateWithoutRatingsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutRatingsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutRatingsInput, AgencyUncheckedUpdateWithoutRatingsInput>
  }

  export type AgencyUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type ClientUpsertWithoutReviewsInput = {
    update: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgencyMemberCreateWithoutRemindersInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
  }

  export type AgencyMemberUncheckedCreateWithoutRemindersInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type AgencyMemberCreateOrConnectWithoutRemindersInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutRemindersInput, AgencyMemberUncheckedCreateWithoutRemindersInput>
  }

  export type AgencyMemberUpsertWithoutRemindersInput = {
    update: XOR<AgencyMemberUpdateWithoutRemindersInput, AgencyMemberUncheckedUpdateWithoutRemindersInput>
    create: XOR<AgencyMemberCreateWithoutRemindersInput, AgencyMemberUncheckedCreateWithoutRemindersInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutRemindersInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutRemindersInput, AgencyMemberUncheckedUpdateWithoutRemindersInput>
  }

  export type AgencyMemberUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ClientPropertySubscriptionCreateWithoutClientInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientSearch?: ClientSearchCreateNestedOneWithoutClientPropertySubscriptionInput
  }

  export type ClientPropertySubscriptionUncheckedCreateWithoutClientInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientSearchId?: string | null
  }

  export type ClientPropertySubscriptionCreateOrConnectWithoutClientInput = {
    where: ClientPropertySubscriptionWhereUniqueInput
    create: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput>
  }

  export type ClientPropertySubscriptionCreateManyClientInputEnvelope = {
    data: ClientPropertySubscriptionCreateManyClientInput | ClientPropertySubscriptionCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PropertyFavoriteCreateWithoutClientInput = {
    id?: string
    favoriteDate: Date | string
    property?: PropertyCreateNestedOneWithoutPropertyFavoriteInput
  }

  export type PropertyFavoriteUncheckedCreateWithoutClientInput = {
    id?: string
    favoriteDate: Date | string
    propertyId?: string | null
  }

  export type PropertyFavoriteCreateOrConnectWithoutClientInput = {
    where: PropertyFavoriteWhereUniqueInput
    create: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput>
  }

  export type PropertyFavoriteCreateManyClientInputEnvelope = {
    data: PropertyFavoriteCreateManyClientInput | PropertyFavoriteCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PropertyViewCreateWithoutClientInput = {
    id?: string
    viewDate?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutViewsInput
  }

  export type PropertyViewUncheckedCreateWithoutClientInput = {
    id?: string
    viewDate?: Date | string
    propertyId: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewCreateOrConnectWithoutClientInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput>
  }

  export type PropertyViewCreateManyClientInputEnvelope = {
    data: PropertyViewCreateManyClientInput | PropertyViewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientSearchCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionCreateNestedOneWithoutClientSearchInput
  }

  export type ClientSearchUncheckedCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionUncheckedCreateNestedOneWithoutClientSearchInput
  }

  export type ClientSearchCreateOrConnectWithoutClientInput = {
    where: ClientSearchWhereUniqueInput
    create: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput>
  }

  export type ClientSearchCreateManyClientInputEnvelope = {
    data: ClientSearchCreateManyClientInput | ClientSearchCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AgencyReviewCreateWithoutClientInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agency: AgencyCreateNestedOneWithoutRatingsInput
  }

  export type AgencyReviewUncheckedCreateWithoutClientInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId: string
  }

  export type AgencyReviewCreateOrConnectWithoutClientInput = {
    where: AgencyReviewWhereUniqueInput
    create: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput>
  }

  export type AgencyReviewCreateManyClientInputEnvelope = {
    data: AgencyReviewCreateManyClientInput | AgencyReviewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type AgencyViewCreateWithoutClientInput = {
    id?: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyViewInput
  }

  export type AgencyViewUncheckedCreateWithoutClientInput = {
    id?: string
    agencyId: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyViewCreateOrConnectWithoutClientInput = {
    where: AgencyViewWhereUniqueInput
    create: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput>
  }

  export type AgencyViewCreateManyClientInputEnvelope = {
    data: AgencyViewCreateManyClientInput | AgencyViewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PropertyEngagementCreateWithoutClientInput = {
    id?: string
    type: $Enums.EngagementType
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    property: PropertyCreateNestedOneWithoutPropertyEngagementInput
  }

  export type PropertyEngagementUncheckedCreateWithoutClientInput = {
    id?: string
    propertyId: string
    type: $Enums.EngagementType
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementCreateOrConnectWithoutClientInput = {
    where: PropertyEngagementWhereUniqueInput
    create: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput>
  }

  export type PropertyEngagementCreateManyClientInputEnvelope = {
    data: PropertyEngagementCreateManyClientInput | PropertyEngagementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: ProposalOfferCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: ProposalOfferUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutClientInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput>
  }

  export type ProposalCreateManyClientInputEnvelope = {
    data: ProposalCreateManyClientInput | ProposalCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCollaborationCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalOffer?: ProposalOfferCreateNestedOneWithoutProposalCollaborationInput
  }

  export type ProposalCollaborationUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    proposalOfferId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCollaborationCreateOrConnectWithoutClientInput = {
    where: ProposalCollaborationWhereUniqueInput
    create: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput>
  }

  export type ProposalCollaborationCreateManyClientInputEnvelope = {
    data: ProposalCollaborationCreateManyClientInput | ProposalCollaborationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientPropertySubscriptionUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientPropertySubscriptionWhereUniqueInput
    update: XOR<ClientPropertySubscriptionUpdateWithoutClientInput, ClientPropertySubscriptionUncheckedUpdateWithoutClientInput>
    create: XOR<ClientPropertySubscriptionCreateWithoutClientInput, ClientPropertySubscriptionUncheckedCreateWithoutClientInput>
  }

  export type ClientPropertySubscriptionUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientPropertySubscriptionWhereUniqueInput
    data: XOR<ClientPropertySubscriptionUpdateWithoutClientInput, ClientPropertySubscriptionUncheckedUpdateWithoutClientInput>
  }

  export type ClientPropertySubscriptionUpdateManyWithWhereWithoutClientInput = {
    where: ClientPropertySubscriptionScalarWhereInput
    data: XOR<ClientPropertySubscriptionUpdateManyMutationInput, ClientPropertySubscriptionUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientPropertySubscriptionScalarWhereInput = {
    AND?: ClientPropertySubscriptionScalarWhereInput | ClientPropertySubscriptionScalarWhereInput[]
    OR?: ClientPropertySubscriptionScalarWhereInput[]
    NOT?: ClientPropertySubscriptionScalarWhereInput | ClientPropertySubscriptionScalarWhereInput[]
    id?: StringFilter<"ClientPropertySubscription"> | string
    minSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxSize?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    minPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    maxPrice?: IntNullableFilter<"ClientPropertySubscription"> | number | null
    location?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    listingType?: EnumPropertyListingTypeNullableFilter<"ClientPropertySubscription"> | $Enums.PropertyListingType | null
    category?: StringFilter<"ClientPropertySubscription"> | string
    subCategory?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    createdAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPropertySubscription"> | Date | string
    clientId?: StringNullableFilter<"ClientPropertySubscription"> | string | null
    clientSearchId?: StringNullableFilter<"ClientPropertySubscription"> | string | null
  }

  export type PropertyFavoriteUpsertWithWhereUniqueWithoutClientInput = {
    where: PropertyFavoriteWhereUniqueInput
    update: XOR<PropertyFavoriteUpdateWithoutClientInput, PropertyFavoriteUncheckedUpdateWithoutClientInput>
    create: XOR<PropertyFavoriteCreateWithoutClientInput, PropertyFavoriteUncheckedCreateWithoutClientInput>
  }

  export type PropertyFavoriteUpdateWithWhereUniqueWithoutClientInput = {
    where: PropertyFavoriteWhereUniqueInput
    data: XOR<PropertyFavoriteUpdateWithoutClientInput, PropertyFavoriteUncheckedUpdateWithoutClientInput>
  }

  export type PropertyFavoriteUpdateManyWithWhereWithoutClientInput = {
    where: PropertyFavoriteScalarWhereInput
    data: XOR<PropertyFavoriteUpdateManyMutationInput, PropertyFavoriteUncheckedUpdateManyWithoutClientInput>
  }

  export type PropertyFavoriteScalarWhereInput = {
    AND?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
    OR?: PropertyFavoriteScalarWhereInput[]
    NOT?: PropertyFavoriteScalarWhereInput | PropertyFavoriteScalarWhereInput[]
    id?: StringFilter<"PropertyFavorite"> | string
    favoriteDate?: DateTimeFilter<"PropertyFavorite"> | Date | string
    propertyId?: StringNullableFilter<"PropertyFavorite"> | string | null
    clientId?: StringNullableFilter<"PropertyFavorite"> | string | null
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutClientInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutClientInput, PropertyViewUncheckedUpdateWithoutClientInput>
    create: XOR<PropertyViewCreateWithoutClientInput, PropertyViewUncheckedCreateWithoutClientInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutClientInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutClientInput, PropertyViewUncheckedUpdateWithoutClientInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutClientInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutClientInput>
  }

  export type PropertyViewScalarWhereInput = {
    AND?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    OR?: PropertyViewScalarWhereInput[]
    NOT?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    viewDate?: DateTimeFilter<"PropertyView"> | Date | string
    propertyId?: StringFilter<"PropertyView"> | string
    clientId?: StringNullableFilter<"PropertyView"> | string | null
    additionalInfo?: JsonNullableFilter<"PropertyView">
    createdAt?: DateTimeFilter<"PropertyView"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyView"> | Date | string
  }

  export type ClientSearchUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientSearchWhereUniqueInput
    update: XOR<ClientSearchUpdateWithoutClientInput, ClientSearchUncheckedUpdateWithoutClientInput>
    create: XOR<ClientSearchCreateWithoutClientInput, ClientSearchUncheckedCreateWithoutClientInput>
  }

  export type ClientSearchUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientSearchWhereUniqueInput
    data: XOR<ClientSearchUpdateWithoutClientInput, ClientSearchUncheckedUpdateWithoutClientInput>
  }

  export type ClientSearchUpdateManyWithWhereWithoutClientInput = {
    where: ClientSearchScalarWhereInput
    data: XOR<ClientSearchUpdateManyMutationInput, ClientSearchUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientSearchScalarWhereInput = {
    AND?: ClientSearchScalarWhereInput | ClientSearchScalarWhereInput[]
    OR?: ClientSearchScalarWhereInput[]
    NOT?: ClientSearchScalarWhereInput | ClientSearchScalarWhereInput[]
    id?: StringFilter<"ClientSearch"> | string
    createdAt?: DateTimeFilter<"ClientSearch"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSearch"> | Date | string
    clientId?: StringFilter<"ClientSearch"> | string
    title?: JsonFilter<"ClientSearch">
    link?: StringFilter<"ClientSearch"> | string
    filters?: JsonFilter<"ClientSearch">
    receiveOffers?: BoolFilter<"ClientSearch"> | boolean
    agencyIdsJson?: JsonNullableFilter<"ClientSearch">
  }

  export type AgencyReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: AgencyReviewWhereUniqueInput
    update: XOR<AgencyReviewUpdateWithoutClientInput, AgencyReviewUncheckedUpdateWithoutClientInput>
    create: XOR<AgencyReviewCreateWithoutClientInput, AgencyReviewUncheckedCreateWithoutClientInput>
  }

  export type AgencyReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: AgencyReviewWhereUniqueInput
    data: XOR<AgencyReviewUpdateWithoutClientInput, AgencyReviewUncheckedUpdateWithoutClientInput>
  }

  export type AgencyReviewUpdateManyWithWhereWithoutClientInput = {
    where: AgencyReviewScalarWhereInput
    data: XOR<AgencyReviewUpdateManyMutationInput, AgencyReviewUncheckedUpdateManyWithoutClientInput>
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AgencyViewUpsertWithWhereUniqueWithoutClientInput = {
    where: AgencyViewWhereUniqueInput
    update: XOR<AgencyViewUpdateWithoutClientInput, AgencyViewUncheckedUpdateWithoutClientInput>
    create: XOR<AgencyViewCreateWithoutClientInput, AgencyViewUncheckedCreateWithoutClientInput>
  }

  export type AgencyViewUpdateWithWhereUniqueWithoutClientInput = {
    where: AgencyViewWhereUniqueInput
    data: XOR<AgencyViewUpdateWithoutClientInput, AgencyViewUncheckedUpdateWithoutClientInput>
  }

  export type AgencyViewUpdateManyWithWhereWithoutClientInput = {
    where: AgencyViewScalarWhereInput
    data: XOR<AgencyViewUpdateManyMutationInput, AgencyViewUncheckedUpdateManyWithoutClientInput>
  }

  export type PropertyEngagementUpsertWithWhereUniqueWithoutClientInput = {
    where: PropertyEngagementWhereUniqueInput
    update: XOR<PropertyEngagementUpdateWithoutClientInput, PropertyEngagementUncheckedUpdateWithoutClientInput>
    create: XOR<PropertyEngagementCreateWithoutClientInput, PropertyEngagementUncheckedCreateWithoutClientInput>
  }

  export type PropertyEngagementUpdateWithWhereUniqueWithoutClientInput = {
    where: PropertyEngagementWhereUniqueInput
    data: XOR<PropertyEngagementUpdateWithoutClientInput, PropertyEngagementUncheckedUpdateWithoutClientInput>
  }

  export type PropertyEngagementUpdateManyWithWhereWithoutClientInput = {
    where: PropertyEngagementScalarWhereInput
    data: XOR<PropertyEngagementUpdateManyMutationInput, PropertyEngagementUncheckedUpdateManyWithoutClientInput>
  }

  export type PropertyEngagementScalarWhereInput = {
    AND?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
    OR?: PropertyEngagementScalarWhereInput[]
    NOT?: PropertyEngagementScalarWhereInput | PropertyEngagementScalarWhereInput[]
    id?: StringFilter<"PropertyEngagement"> | string
    propertyId?: StringFilter<"PropertyEngagement"> | string
    type?: EnumEngagementTypeFilter<"PropertyEngagement"> | $Enums.EngagementType
    clientId?: StringNullableFilter<"PropertyEngagement"> | string | null
    createdAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyEngagement"> | Date | string
    additionalInfo?: JsonNullableFilter<"PropertyEngagement">
  }

  export type ProposalUpsertWithWhereUniqueWithoutClientInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutClientInput, ProposalUncheckedUpdateWithoutClientInput>
    create: XOR<ProposalCreateWithoutClientInput, ProposalUncheckedCreateWithoutClientInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutClientInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutClientInput, ProposalUncheckedUpdateWithoutClientInput>
  }

  export type ProposalUpdateManyWithWhereWithoutClientInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutClientInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    location?: StringFilter<"Proposal"> | string
    size?: IntNullableFilter<"Proposal"> | number | null
    category?: EnumPropertyTypeFilter<"Proposal"> | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFilter<"Proposal"> | $Enums.PropertyListingType
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    photos?: JsonNullableFilter<"Proposal">
    clientId?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
  }

  export type ProposalCollaborationUpsertWithWhereUniqueWithoutClientInput = {
    where: ProposalCollaborationWhereUniqueInput
    update: XOR<ProposalCollaborationUpdateWithoutClientInput, ProposalCollaborationUncheckedUpdateWithoutClientInput>
    create: XOR<ProposalCollaborationCreateWithoutClientInput, ProposalCollaborationUncheckedCreateWithoutClientInput>
  }

  export type ProposalCollaborationUpdateWithWhereUniqueWithoutClientInput = {
    where: ProposalCollaborationWhereUniqueInput
    data: XOR<ProposalCollaborationUpdateWithoutClientInput, ProposalCollaborationUncheckedUpdateWithoutClientInput>
  }

  export type ProposalCollaborationUpdateManyWithWhereWithoutClientInput = {
    where: ProposalCollaborationScalarWhereInput
    data: XOR<ProposalCollaborationUpdateManyMutationInput, ProposalCollaborationUncheckedUpdateManyWithoutClientInput>
  }

  export type ProposalCollaborationScalarWhereInput = {
    AND?: ProposalCollaborationScalarWhereInput | ProposalCollaborationScalarWhereInput[]
    OR?: ProposalCollaborationScalarWhereInput[]
    NOT?: ProposalCollaborationScalarWhereInput | ProposalCollaborationScalarWhereInput[]
    id?: StringFilter<"ProposalCollaboration"> | string
    clientId?: StringFilter<"ProposalCollaboration"> | string
    title?: StringFilter<"ProposalCollaboration"> | string
    description?: StringFilter<"ProposalCollaboration"> | string
    email?: StringFilter<"ProposalCollaboration"> | string
    phone?: StringNullableFilter<"ProposalCollaboration"> | string | null
    agencyId?: StringFilter<"ProposalCollaboration"> | string
    proposalOfferId?: StringFilter<"ProposalCollaboration"> | string
    createdAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalCollaboration"> | Date | string
  }

  export type ClientCreateWithoutClientSearchesInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientSearchesInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientSearchesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientSearchesInput, ClientUncheckedCreateWithoutClientSearchesInput>
  }

  export type ClientPropertySubscriptionCreateWithoutClientSearchInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutClientSubscriptionInput
  }

  export type ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
  }

  export type ClientPropertySubscriptionCreateOrConnectWithoutClientSearchInput = {
    where: ClientPropertySubscriptionWhereUniqueInput
    create: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
  }

  export type ClientUpsertWithoutClientSearchesInput = {
    update: XOR<ClientUpdateWithoutClientSearchesInput, ClientUncheckedUpdateWithoutClientSearchesInput>
    create: XOR<ClientCreateWithoutClientSearchesInput, ClientUncheckedCreateWithoutClientSearchesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientSearchesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientSearchesInput, ClientUncheckedUpdateWithoutClientSearchesInput>
  }

  export type ClientUpdateWithoutClientSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientPropertySubscriptionUpsertWithoutClientSearchInput = {
    update: XOR<ClientPropertySubscriptionUpdateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedUpdateWithoutClientSearchInput>
    create: XOR<ClientPropertySubscriptionCreateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedCreateWithoutClientSearchInput>
    where?: ClientPropertySubscriptionWhereInput
  }

  export type ClientPropertySubscriptionUpdateToOneWithWhereWithoutClientSearchInput = {
    where?: ClientPropertySubscriptionWhereInput
    data: XOR<ClientPropertySubscriptionUpdateWithoutClientSearchInput, ClientPropertySubscriptionUncheckedUpdateWithoutClientSearchInput>
  }

  export type ClientPropertySubscriptionUpdateWithoutClientSearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutClientSubscriptionNestedInput
  }

  export type ClientPropertySubscriptionUncheckedUpdateWithoutClientSearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateWithoutClientSubscriptionInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientSubscriptionInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientSubscriptionInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientSubscriptionInput, ClientUncheckedCreateWithoutClientSubscriptionInput>
  }

  export type ClientSearchCreateWithoutClientPropertySubscriptionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    client: ClientCreateNestedOneWithoutClientSearchesInput
  }

  export type ClientSearchUncheckedCreateWithoutClientPropertySubscriptionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientSearchCreateOrConnectWithoutClientPropertySubscriptionInput = {
    where: ClientSearchWhereUniqueInput
    create: XOR<ClientSearchCreateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedCreateWithoutClientPropertySubscriptionInput>
  }

  export type ClientUpsertWithoutClientSubscriptionInput = {
    update: XOR<ClientUpdateWithoutClientSubscriptionInput, ClientUncheckedUpdateWithoutClientSubscriptionInput>
    create: XOR<ClientCreateWithoutClientSubscriptionInput, ClientUncheckedCreateWithoutClientSubscriptionInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientSubscriptionInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientSubscriptionInput, ClientUncheckedUpdateWithoutClientSubscriptionInput>
  }

  export type ClientUpdateWithoutClientSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientSearchUpsertWithoutClientPropertySubscriptionInput = {
    update: XOR<ClientSearchUpdateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedUpdateWithoutClientPropertySubscriptionInput>
    create: XOR<ClientSearchCreateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedCreateWithoutClientPropertySubscriptionInput>
    where?: ClientSearchWhereInput
  }

  export type ClientSearchUpdateToOneWithWhereWithoutClientPropertySubscriptionInput = {
    where?: ClientSearchWhereInput
    data: XOR<ClientSearchUpdateWithoutClientPropertySubscriptionInput, ClientSearchUncheckedUpdateWithoutClientPropertySubscriptionInput>
  }

  export type ClientSearchUpdateWithoutClientPropertySubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientUpdateOneRequiredWithoutClientSearchesNestedInput
  }

  export type ClientSearchUncheckedUpdateWithoutClientPropertySubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgencyMemberCreateWithoutCreatedPropertiesInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgencyMemberInput
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutCreatedPropertiesInput = {
    id?: string
    userId: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutCreatedPropertiesInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutCreatedPropertiesInput, AgencyMemberUncheckedCreateWithoutCreatedPropertiesInput>
  }

  export type PropertyViewCreateWithoutPropertyInput = {
    id?: string
    viewDate?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutPropertyViewsInput
  }

  export type PropertyViewUncheckedCreateWithoutPropertyInput = {
    id?: string
    viewDate?: Date | string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewCreateOrConnectWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewCreateManyPropertyInputEnvelope = {
    data: PropertyViewCreateManyPropertyInput | PropertyViewCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutPropertiesInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutPropertiesInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutPropertiesInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutPropertiesInput, AgencyUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyFavoriteCreateWithoutPropertyInput = {
    id?: string
    favoriteDate: Date | string
    client?: ClientCreateNestedOneWithoutFavoritesInput
  }

  export type PropertyFavoriteUncheckedCreateWithoutPropertyInput = {
    id?: string
    favoriteDate: Date | string
    clientId?: string | null
  }

  export type PropertyFavoriteCreateOrConnectWithoutPropertyInput = {
    where: PropertyFavoriteWhereUniqueInput
    create: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFavoriteCreateManyPropertyInputEnvelope = {
    data: PropertyFavoriteCreateManyPropertyInput | PropertyFavoriteCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertySaleCreateWithoutPropertyInput = {
    id?: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
    agency: AgencyCreateNestedOneWithoutPropertySaleInput
  }

  export type PropertySaleUncheckedCreateWithoutPropertyInput = {
    id?: string
    agencyId: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
  }

  export type PropertySaleCreateOrConnectWithoutPropertyInput = {
    where: PropertySaleWhereUniqueInput
    create: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyEngagementCreateWithoutPropertyInput = {
    id?: string
    type: $Enums.EngagementType
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientCreateNestedOneWithoutPropertyEngagementInput
  }

  export type PropertyEngagementUncheckedCreateWithoutPropertyInput = {
    id?: string
    type: $Enums.EngagementType
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementCreateOrConnectWithoutPropertyInput = {
    where: PropertyEngagementWhereUniqueInput
    create: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyEngagementCreateManyPropertyInputEnvelope = {
    data: PropertyEngagementCreateManyPropertyInput | PropertyEngagementCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertySubmissionReviewCreateWithoutPropertyInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionReviewUncheckedCreateWithoutPropertyInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionReviewCreateOrConnectWithoutPropertyInput = {
    where: PropertySubmissionReviewWhereUniqueInput
    create: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertySubmissionReviewCreateManyPropertyInputEnvelope = {
    data: PropertySubmissionReviewCreateManyPropertyInput | PropertySubmissionReviewCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyLocationCreateWithoutPropertiesInput = {
    id?: string
    name: string
    parent?: PropertyLocationCreateNestedOneWithoutChildrenInput
    children?: PropertyLocationCreateNestedManyWithoutParentInput
  }

  export type PropertyLocationUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    parentId?: string | null
    children?: PropertyLocationUncheckedCreateNestedManyWithoutParentInput
  }

  export type PropertyLocationCreateOrConnectWithoutPropertiesInput = {
    where: PropertyLocationWhereUniqueInput
    create: XOR<PropertyLocationCreateWithoutPropertiesInput, PropertyLocationUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyCategoryCreateWithoutPropertiesInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: PropertySubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUncheckedCreateWithoutPropertiesInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategories?: PropertySubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryCreateOrConnectWithoutPropertiesInput = {
    where: PropertyCategoryWhereUniqueInput
    create: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertySubcategoryCreateWithoutPropertiesInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: PropertyCategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type PropertySubcategoryUncheckedCreateWithoutPropertiesInput = {
    id: string
    value: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubcategoryCreateOrConnectWithoutPropertiesInput = {
    where: PropertySubcategoryWhereUniqueInput
    create: XOR<PropertySubcategoryCreateWithoutPropertiesInput, PropertySubcategoryUncheckedCreateWithoutPropertiesInput>
  }

  export type AgencyClientCreateWithoutOwnedPropertiesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    rentedProperties?: PropertyCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientUncheckedCreateWithoutOwnedPropertiesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    rentedProperties?: PropertyUncheckedCreateNestedManyWithoutRenterInput
  }

  export type AgencyClientCreateOrConnectWithoutOwnedPropertiesInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutOwnedPropertiesInput, AgencyClientUncheckedCreateWithoutOwnedPropertiesInput>
  }

  export type AgencyClientCreateWithoutRentedPropertiesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesCreateNestedManyWithoutAgencyClientInput
    agency: AgencyCreateNestedOneWithoutAgencyClientInput
    createdBy?: AgencyMemberCreateNestedOneWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyCreateNestedManyWithoutOwnerInput
  }

  export type AgencyClientUncheckedCreateWithoutRentedPropertiesInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutAgencyClientInput
    preferences?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutAgencyClientInput
    ownedProperties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type AgencyClientCreateOrConnectWithoutRentedPropertiesInput = {
    where: AgencyClientWhereUniqueInput
    create: XOR<AgencyClientCreateWithoutRentedPropertiesInput, AgencyClientUncheckedCreateWithoutRentedPropertiesInput>
  }

  export type AgencyMemberUpsertWithoutCreatedPropertiesInput = {
    update: XOR<AgencyMemberUpdateWithoutCreatedPropertiesInput, AgencyMemberUncheckedUpdateWithoutCreatedPropertiesInput>
    create: XOR<AgencyMemberCreateWithoutCreatedPropertiesInput, AgencyMemberUncheckedCreateWithoutCreatedPropertiesInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutCreatedPropertiesInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutCreatedPropertiesInput, AgencyMemberUncheckedUpdateWithoutCreatedPropertiesInput>
  }

  export type AgencyMemberUpdateWithoutCreatedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutCreatedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type AgencyUpsertWithoutPropertiesInput = {
    update: XOR<AgencyUpdateWithoutPropertiesInput, AgencyUncheckedUpdateWithoutPropertiesInput>
    create: XOR<AgencyCreateWithoutPropertiesInput, AgencyUncheckedCreateWithoutPropertiesInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutPropertiesInput, AgencyUncheckedUpdateWithoutPropertiesInput>
  }

  export type AgencyUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PropertyFavoriteUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFavoriteWhereUniqueInput
    update: XOR<PropertyFavoriteUpdateWithoutPropertyInput, PropertyFavoriteUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyFavoriteCreateWithoutPropertyInput, PropertyFavoriteUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFavoriteUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFavoriteWhereUniqueInput
    data: XOR<PropertyFavoriteUpdateWithoutPropertyInput, PropertyFavoriteUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyFavoriteUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyFavoriteScalarWhereInput
    data: XOR<PropertyFavoriteUpdateManyMutationInput, PropertyFavoriteUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertySaleUpsertWithoutPropertyInput = {
    update: XOR<PropertySaleUpdateWithoutPropertyInput, PropertySaleUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertySaleCreateWithoutPropertyInput, PropertySaleUncheckedCreateWithoutPropertyInput>
    where?: PropertySaleWhereInput
  }

  export type PropertySaleUpdateToOneWithWhereWithoutPropertyInput = {
    where?: PropertySaleWhereInput
    data: XOR<PropertySaleUpdateWithoutPropertyInput, PropertySaleUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertySaleUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
    agency?: AgencyUpdateOneRequiredWithoutPropertySaleNestedInput
  }

  export type PropertySaleUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyEngagementUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyEngagementWhereUniqueInput
    update: XOR<PropertyEngagementUpdateWithoutPropertyInput, PropertyEngagementUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyEngagementCreateWithoutPropertyInput, PropertyEngagementUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyEngagementUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyEngagementWhereUniqueInput
    data: XOR<PropertyEngagementUpdateWithoutPropertyInput, PropertyEngagementUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyEngagementUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyEngagementScalarWhereInput
    data: XOR<PropertyEngagementUpdateManyMutationInput, PropertyEngagementUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertySubmissionReviewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertySubmissionReviewWhereUniqueInput
    update: XOR<PropertySubmissionReviewUpdateWithoutPropertyInput, PropertySubmissionReviewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertySubmissionReviewCreateWithoutPropertyInput, PropertySubmissionReviewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertySubmissionReviewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertySubmissionReviewWhereUniqueInput
    data: XOR<PropertySubmissionReviewUpdateWithoutPropertyInput, PropertySubmissionReviewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertySubmissionReviewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertySubmissionReviewScalarWhereInput
    data: XOR<PropertySubmissionReviewUpdateManyMutationInput, PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertySubmissionReviewScalarWhereInput = {
    AND?: PropertySubmissionReviewScalarWhereInput | PropertySubmissionReviewScalarWhereInput[]
    OR?: PropertySubmissionReviewScalarWhereInput[]
    NOT?: PropertySubmissionReviewScalarWhereInput | PropertySubmissionReviewScalarWhereInput[]
    id?: StringFilter<"PropertySubmissionReview"> | string
    propertyId?: StringFilter<"PropertySubmissionReview"> | string
    title?: JsonFilter<"PropertySubmissionReview">
    description?: JsonFilter<"PropertySubmissionReview">
    createdAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubmissionReview"> | Date | string
  }

  export type PropertyLocationUpsertWithoutPropertiesInput = {
    update: XOR<PropertyLocationUpdateWithoutPropertiesInput, PropertyLocationUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyLocationCreateWithoutPropertiesInput, PropertyLocationUncheckedCreateWithoutPropertiesInput>
    where?: PropertyLocationWhereInput
  }

  export type PropertyLocationUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyLocationWhereInput
    data: XOR<PropertyLocationUpdateWithoutPropertiesInput, PropertyLocationUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyLocationUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: PropertyLocationUpdateOneWithoutChildrenNestedInput
    children?: PropertyLocationUpdateManyWithoutParentNestedInput
  }

  export type PropertyLocationUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: PropertyLocationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PropertyCategoryUpsertWithoutPropertiesInput = {
    update: XOR<PropertyCategoryUpdateWithoutPropertiesInput, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    where?: PropertyCategoryWhereInput
  }

  export type PropertyCategoryUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyCategoryWhereInput
    data: XOR<PropertyCategoryUpdateWithoutPropertiesInput, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: PropertySubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: PropertySubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PropertySubcategoryUpsertWithoutPropertiesInput = {
    update: XOR<PropertySubcategoryUpdateWithoutPropertiesInput, PropertySubcategoryUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertySubcategoryCreateWithoutPropertiesInput, PropertySubcategoryUncheckedCreateWithoutPropertiesInput>
    where?: PropertySubcategoryWhereInput
  }

  export type PropertySubcategoryUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertySubcategoryWhereInput
    data: XOR<PropertySubcategoryUpdateWithoutPropertiesInput, PropertySubcategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertySubcategoryUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: PropertyCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type PropertySubcategoryUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientUpsertWithoutOwnedPropertiesInput = {
    update: XOR<AgencyClientUpdateWithoutOwnedPropertiesInput, AgencyClientUncheckedUpdateWithoutOwnedPropertiesInput>
    create: XOR<AgencyClientCreateWithoutOwnedPropertiesInput, AgencyClientUncheckedCreateWithoutOwnedPropertiesInput>
    where?: AgencyClientWhereInput
  }

  export type AgencyClientUpdateToOneWithWhereWithoutOwnedPropertiesInput = {
    where?: AgencyClientWhereInput
    data: XOR<AgencyClientUpdateWithoutOwnedPropertiesInput, AgencyClientUncheckedUpdateWithoutOwnedPropertiesInput>
  }

  export type AgencyClientUpdateWithoutOwnedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutOwnedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUpsertWithoutRentedPropertiesInput = {
    update: XOR<AgencyClientUpdateWithoutRentedPropertiesInput, AgencyClientUncheckedUpdateWithoutRentedPropertiesInput>
    create: XOR<AgencyClientCreateWithoutRentedPropertiesInput, AgencyClientUncheckedCreateWithoutRentedPropertiesInput>
    where?: AgencyClientWhereInput
  }

  export type AgencyClientUpdateToOneWithWhereWithoutRentedPropertiesInput = {
    where?: AgencyClientWhereInput
    data: XOR<AgencyClientUpdateWithoutRentedPropertiesInput, AgencyClientUncheckedUpdateWithoutRentedPropertiesInput>
  }

  export type AgencyClientUpdateWithoutRentedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutRentedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PropertyCreateWithoutCategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyCreateManyCategoryInputEnvelope = {
    data: PropertyCreateManyCategoryInput | PropertyCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertySubcategoryCreateWithoutCategoryInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutSubcategoryInput
  }

  export type PropertySubcategoryUncheckedCreateWithoutCategoryInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type PropertySubcategoryCreateOrConnectWithoutCategoryInput = {
    where: PropertySubcategoryWhereUniqueInput
    create: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PropertySubcategoryCreateManyCategoryInputEnvelope = {
    data: PropertySubcategoryCreateManyCategoryInput | PropertySubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCategoryInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PropertySubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PropertySubcategoryWhereUniqueInput
    update: XOR<PropertySubcategoryUpdateWithoutCategoryInput, PropertySubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<PropertySubcategoryCreateWithoutCategoryInput, PropertySubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PropertySubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PropertySubcategoryWhereUniqueInput
    data: XOR<PropertySubcategoryUpdateWithoutCategoryInput, PropertySubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type PropertySubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: PropertySubcategoryScalarWhereInput
    data: XOR<PropertySubcategoryUpdateManyMutationInput, PropertySubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PropertySubcategoryScalarWhereInput = {
    AND?: PropertySubcategoryScalarWhereInput | PropertySubcategoryScalarWhereInput[]
    OR?: PropertySubcategoryScalarWhereInput[]
    NOT?: PropertySubcategoryScalarWhereInput | PropertySubcategoryScalarWhereInput[]
    id?: StringFilter<"PropertySubcategory"> | string
    value?: StringFilter<"PropertySubcategory"> | string
    categoryId?: StringFilter<"PropertySubcategory"> | string
    createdAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubcategory"> | Date | string
  }

  export type PropertyCategoryCreateWithoutSubcategoriesInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUncheckedCreateWithoutSubcategoriesInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: PropertyCategoryWhereUniqueInput
    create: XOR<PropertyCategoryCreateWithoutSubcategoriesInput, PropertyCategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type PropertyCreateWithoutSubcategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSubcategoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput>
  }

  export type PropertyCreateManySubcategoryInputEnvelope = {
    data: PropertyCreateManySubcategoryInput | PropertyCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<PropertyCategoryUpdateWithoutSubcategoriesInput, PropertyCategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<PropertyCategoryCreateWithoutSubcategoriesInput, PropertyCategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: PropertyCategoryWhereInput
  }

  export type PropertyCategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: PropertyCategoryWhereInput
    data: XOR<PropertyCategoryUpdateWithoutSubcategoriesInput, PropertyCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type PropertyCategoryUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutSubcategoryInput, PropertyUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<PropertyCreateWithoutSubcategoryInput, PropertyUncheckedCreateWithoutSubcategoryInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutSubcategoryInput, PropertyUncheckedUpdateWithoutSubcategoryInput>
  }

  export type PropertyUpdateManyWithWhereWithoutSubcategoryInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type PropertyLocationCreateWithoutChildrenInput = {
    id?: string
    name: string
    parent?: PropertyLocationCreateNestedOneWithoutChildrenInput
    properties?: PropertyCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    parentId?: string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationCreateOrConnectWithoutChildrenInput = {
    where: PropertyLocationWhereUniqueInput
    create: XOR<PropertyLocationCreateWithoutChildrenInput, PropertyLocationUncheckedCreateWithoutChildrenInput>
  }

  export type PropertyLocationCreateWithoutParentInput = {
    id?: string
    name: string
    children?: PropertyLocationCreateNestedManyWithoutParentInput
    properties?: PropertyCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    children?: PropertyLocationUncheckedCreateNestedManyWithoutParentInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyLocationInput
  }

  export type PropertyLocationCreateOrConnectWithoutParentInput = {
    where: PropertyLocationWhereUniqueInput
    create: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput>
  }

  export type PropertyLocationCreateManyParentInputEnvelope = {
    data: PropertyLocationCreateManyParentInput | PropertyLocationCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutPropertyLocationInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertyLocationInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyLocationInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput>
  }

  export type PropertyCreateManyPropertyLocationInputEnvelope = {
    data: PropertyCreateManyPropertyLocationInput | PropertyCreateManyPropertyLocationInput[]
    skipDuplicates?: boolean
  }

  export type PropertyLocationUpsertWithoutChildrenInput = {
    update: XOR<PropertyLocationUpdateWithoutChildrenInput, PropertyLocationUncheckedUpdateWithoutChildrenInput>
    create: XOR<PropertyLocationCreateWithoutChildrenInput, PropertyLocationUncheckedCreateWithoutChildrenInput>
    where?: PropertyLocationWhereInput
  }

  export type PropertyLocationUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PropertyLocationWhereInput
    data: XOR<PropertyLocationUpdateWithoutChildrenInput, PropertyLocationUncheckedUpdateWithoutChildrenInput>
  }

  export type PropertyLocationUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: PropertyLocationUpdateOneWithoutChildrenNestedInput
    properties?: PropertyUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: PropertyUncheckedUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationUpsertWithWhereUniqueWithoutParentInput = {
    where: PropertyLocationWhereUniqueInput
    update: XOR<PropertyLocationUpdateWithoutParentInput, PropertyLocationUncheckedUpdateWithoutParentInput>
    create: XOR<PropertyLocationCreateWithoutParentInput, PropertyLocationUncheckedCreateWithoutParentInput>
  }

  export type PropertyLocationUpdateWithWhereUniqueWithoutParentInput = {
    where: PropertyLocationWhereUniqueInput
    data: XOR<PropertyLocationUpdateWithoutParentInput, PropertyLocationUncheckedUpdateWithoutParentInput>
  }

  export type PropertyLocationUpdateManyWithWhereWithoutParentInput = {
    where: PropertyLocationScalarWhereInput
    data: XOR<PropertyLocationUpdateManyMutationInput, PropertyLocationUncheckedUpdateManyWithoutParentInput>
  }

  export type PropertyLocationScalarWhereInput = {
    AND?: PropertyLocationScalarWhereInput | PropertyLocationScalarWhereInput[]
    OR?: PropertyLocationScalarWhereInput[]
    NOT?: PropertyLocationScalarWhereInput | PropertyLocationScalarWhereInput[]
    id?: StringFilter<"PropertyLocation"> | string
    name?: StringFilter<"PropertyLocation"> | string
    parentId?: StringNullableFilter<"PropertyLocation"> | string | null
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyLocationInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyLocationInput, PropertyUncheckedUpdateWithoutPropertyLocationInput>
    create: XOR<PropertyCreateWithoutPropertyLocationInput, PropertyUncheckedCreateWithoutPropertyLocationInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyLocationInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyLocationInput, PropertyUncheckedUpdateWithoutPropertyLocationInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyLocationInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyLocationInput>
  }

  export type PropertyCreateWithoutPropertyReviewInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertyReviewInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyReviewInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyReviewInput, PropertyUncheckedCreateWithoutPropertyReviewInput>
  }

  export type PropertyUpsertWithoutPropertyReviewInput = {
    update: XOR<PropertyUpdateWithoutPropertyReviewInput, PropertyUncheckedUpdateWithoutPropertyReviewInput>
    create: XOR<PropertyCreateWithoutPropertyReviewInput, PropertyUncheckedCreateWithoutPropertyReviewInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyReviewInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyReviewInput, PropertyUncheckedUpdateWithoutPropertyReviewInput>
  }

  export type PropertyUpdateWithoutPropertyReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPropertySaleInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertySaleInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertySaleInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertySaleInput, PropertyUncheckedCreateWithoutPropertySaleInput>
  }

  export type AgencyCreateWithoutPropertySaleInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutPropertySaleInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutPropertySaleInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutPropertySaleInput, AgencyUncheckedCreateWithoutPropertySaleInput>
  }

  export type PropertyUpsertWithoutPropertySaleInput = {
    update: XOR<PropertyUpdateWithoutPropertySaleInput, PropertyUncheckedUpdateWithoutPropertySaleInput>
    create: XOR<PropertyCreateWithoutPropertySaleInput, PropertyUncheckedCreateWithoutPropertySaleInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertySaleInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertySaleInput, PropertyUncheckedUpdateWithoutPropertySaleInput>
  }

  export type PropertyUpdateWithoutPropertySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AgencyUpsertWithoutPropertySaleInput = {
    update: XOR<AgencyUpdateWithoutPropertySaleInput, AgencyUncheckedUpdateWithoutPropertySaleInput>
    create: XOR<AgencyCreateWithoutPropertySaleInput, AgencyUncheckedCreateWithoutPropertySaleInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutPropertySaleInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutPropertySaleInput, AgencyUncheckedUpdateWithoutPropertySaleInput>
  }

  export type AgencyUpdateWithoutPropertySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutPropertySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PropertyCreateWithoutViewsInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutViewsInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutViewsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
  }

  export type ClientCreateWithoutPropertyViewsInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPropertyViewsInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPropertyViewsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPropertyViewsInput, ClientUncheckedCreateWithoutPropertyViewsInput>
  }

  export type PropertyUpsertWithoutViewsInput = {
    update: XOR<PropertyUpdateWithoutViewsInput, PropertyUncheckedUpdateWithoutViewsInput>
    create: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutViewsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutViewsInput, PropertyUncheckedUpdateWithoutViewsInput>
  }

  export type PropertyUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ClientUpsertWithoutPropertyViewsInput = {
    update: XOR<ClientUpdateWithoutPropertyViewsInput, ClientUncheckedUpdateWithoutPropertyViewsInput>
    create: XOR<ClientCreateWithoutPropertyViewsInput, ClientUncheckedCreateWithoutPropertyViewsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPropertyViewsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPropertyViewsInput, ClientUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type ClientUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PropertyCreateWithoutPropertyFavoriteInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertyFavoriteInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyFavoriteInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyFavoriteInput, PropertyUncheckedCreateWithoutPropertyFavoriteInput>
  }

  export type ClientCreateWithoutFavoritesInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFavoritesInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFavoritesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
  }

  export type PropertyUpsertWithoutPropertyFavoriteInput = {
    update: XOR<PropertyUpdateWithoutPropertyFavoriteInput, PropertyUncheckedUpdateWithoutPropertyFavoriteInput>
    create: XOR<PropertyCreateWithoutPropertyFavoriteInput, PropertyUncheckedCreateWithoutPropertyFavoriteInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyFavoriteInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyFavoriteInput, PropertyUncheckedUpdateWithoutPropertyFavoriteInput>
  }

  export type PropertyUpdateWithoutPropertyFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ClientUpsertWithoutFavoritesInput = {
    update: XOR<ClientUpdateWithoutFavoritesInput, ClientUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFavoritesInput, ClientUncheckedUpdateWithoutFavoritesInput>
  }

  export type ClientUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PropertyCreateWithoutPropertyEngagementInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    createdByMember?: AgencyMemberCreateNestedOneWithoutCreatedPropertiesInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    agency?: AgencyCreateNestedOneWithoutPropertiesInput
    PropertyFavorite?: PropertyFavoriteCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleCreateNestedOneWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewCreateNestedManyWithoutPropertyInput
    propertyLocation?: PropertyLocationCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    subcategory?: PropertySubcategoryCreateNestedOneWithoutPropertiesInput
    owner?: AgencyClientCreateNestedOneWithoutOwnedPropertiesInput
    renter?: AgencyClientCreateNestedOneWithoutRentedPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertyEngagementInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyFavorite?: PropertyFavoriteUncheckedCreateNestedManyWithoutPropertyInput
    PropertySale?: PropertySaleUncheckedCreateNestedOneWithoutPropertyInput
    propertyReview?: PropertySubmissionReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyEngagementInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyEngagementInput, PropertyUncheckedCreateWithoutPropertyEngagementInput>
  }

  export type ClientCreateWithoutPropertyEngagementInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPropertyEngagementInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPropertyEngagementInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPropertyEngagementInput, ClientUncheckedCreateWithoutPropertyEngagementInput>
  }

  export type PropertyUpsertWithoutPropertyEngagementInput = {
    update: XOR<PropertyUpdateWithoutPropertyEngagementInput, PropertyUncheckedUpdateWithoutPropertyEngagementInput>
    create: XOR<PropertyCreateWithoutPropertyEngagementInput, PropertyUncheckedCreateWithoutPropertyEngagementInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyEngagementInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyEngagementInput, PropertyUncheckedUpdateWithoutPropertyEngagementInput>
  }

  export type PropertyUpdateWithoutPropertyEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ClientUpsertWithoutPropertyEngagementInput = {
    update: XOR<ClientUpdateWithoutPropertyEngagementInput, ClientUncheckedUpdateWithoutPropertyEngagementInput>
    create: XOR<ClientCreateWithoutPropertyEngagementInput, ClientUncheckedCreateWithoutPropertyEngagementInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPropertyEngagementInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPropertyEngagementInput, ClientUncheckedUpdateWithoutPropertyEngagementInput>
  }

  export type ClientUpdateWithoutPropertyEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPropertyEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutProposalInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProposalInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProposalInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProposalInput, ClientUncheckedCreateWithoutProposalInput>
  }

  export type ProposalOfferCreateWithoutProposalInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutProposalOfferInput
    proposalCollaboration?: ProposalCollaborationCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferUncheckedCreateWithoutProposalInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferCreateOrConnectWithoutProposalInput = {
    where: ProposalOfferWhereUniqueInput
    create: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput>
  }

  export type ProposalOfferCreateManyProposalInputEnvelope = {
    data: ProposalOfferCreateManyProposalInput | ProposalOfferCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProposalInput = {
    update: XOR<ClientUpdateWithoutProposalInput, ClientUncheckedUpdateWithoutProposalInput>
    create: XOR<ClientCreateWithoutProposalInput, ClientUncheckedCreateWithoutProposalInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProposalInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProposalInput, ClientUncheckedUpdateWithoutProposalInput>
  }

  export type ClientUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProposalOfferUpsertWithWhereUniqueWithoutProposalInput = {
    where: ProposalOfferWhereUniqueInput
    update: XOR<ProposalOfferUpdateWithoutProposalInput, ProposalOfferUncheckedUpdateWithoutProposalInput>
    create: XOR<ProposalOfferCreateWithoutProposalInput, ProposalOfferUncheckedCreateWithoutProposalInput>
  }

  export type ProposalOfferUpdateWithWhereUniqueWithoutProposalInput = {
    where: ProposalOfferWhereUniqueInput
    data: XOR<ProposalOfferUpdateWithoutProposalInput, ProposalOfferUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalOfferUpdateManyWithWhereWithoutProposalInput = {
    where: ProposalOfferScalarWhereInput
    data: XOR<ProposalOfferUpdateManyMutationInput, ProposalOfferUncheckedUpdateManyWithoutProposalInput>
  }

  export type ProposalCreateWithoutOffersInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutOffersInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateOrConnectWithoutOffersInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutOffersInput, ProposalUncheckedCreateWithoutOffersInput>
  }

  export type AgencyCreateWithoutProposalOfferInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutProposalOfferInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutProposalOfferInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutProposalOfferInput, AgencyUncheckedCreateWithoutProposalOfferInput>
  }

  export type ProposalCollaborationCreateWithoutProposalOfferInput = {
    id?: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProposalCollaborationInput
  }

  export type ProposalCollaborationUncheckedCreateWithoutProposalOfferInput = {
    id?: string
    clientId: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCollaborationCreateOrConnectWithoutProposalOfferInput = {
    where: ProposalCollaborationWhereUniqueInput
    create: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
  }

  export type ProposalUpsertWithoutOffersInput = {
    update: XOR<ProposalUpdateWithoutOffersInput, ProposalUncheckedUpdateWithoutOffersInput>
    create: XOR<ProposalCreateWithoutOffersInput, ProposalUncheckedCreateWithoutOffersInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutOffersInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutOffersInput, ProposalUncheckedUpdateWithoutOffersInput>
  }

  export type ProposalUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUpsertWithoutProposalOfferInput = {
    update: XOR<AgencyUpdateWithoutProposalOfferInput, AgencyUncheckedUpdateWithoutProposalOfferInput>
    create: XOR<AgencyCreateWithoutProposalOfferInput, AgencyUncheckedCreateWithoutProposalOfferInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutProposalOfferInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutProposalOfferInput, AgencyUncheckedUpdateWithoutProposalOfferInput>
  }

  export type AgencyUpdateWithoutProposalOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutProposalOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type ProposalCollaborationUpsertWithoutProposalOfferInput = {
    update: XOR<ProposalCollaborationUpdateWithoutProposalOfferInput, ProposalCollaborationUncheckedUpdateWithoutProposalOfferInput>
    create: XOR<ProposalCollaborationCreateWithoutProposalOfferInput, ProposalCollaborationUncheckedCreateWithoutProposalOfferInput>
    where?: ProposalCollaborationWhereInput
  }

  export type ProposalCollaborationUpdateToOneWithWhereWithoutProposalOfferInput = {
    where?: ProposalCollaborationWhereInput
    data: XOR<ProposalCollaborationUpdateWithoutProposalOfferInput, ProposalCollaborationUncheckedUpdateWithoutProposalOfferInput>
  }

  export type ProposalCollaborationUpdateWithoutProposalOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProposalCollaborationNestedInput
  }

  export type ProposalCollaborationUncheckedUpdateWithoutProposalOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutProposalCollaborationInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProposalCollaborationInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProposalCollaborationInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProposalCollaborationInput, ClientUncheckedCreateWithoutProposalCollaborationInput>
  }

  export type ProposalOfferCreateWithoutProposalCollaborationInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutOffersInput
    agency: AgencyCreateNestedOneWithoutProposalOfferInput
  }

  export type ProposalOfferUncheckedCreateWithoutProposalCollaborationInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    proposalId: string
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalOfferCreateOrConnectWithoutProposalCollaborationInput = {
    where: ProposalOfferWhereUniqueInput
    create: XOR<ProposalOfferCreateWithoutProposalCollaborationInput, ProposalOfferUncheckedCreateWithoutProposalCollaborationInput>
  }

  export type ClientUpsertWithoutProposalCollaborationInput = {
    update: XOR<ClientUpdateWithoutProposalCollaborationInput, ClientUncheckedUpdateWithoutProposalCollaborationInput>
    create: XOR<ClientCreateWithoutProposalCollaborationInput, ClientUncheckedCreateWithoutProposalCollaborationInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProposalCollaborationInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProposalCollaborationInput, ClientUncheckedUpdateWithoutProposalCollaborationInput>
  }

  export type ClientUpdateWithoutProposalCollaborationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProposalCollaborationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProposalOfferUpsertWithoutProposalCollaborationInput = {
    update: XOR<ProposalOfferUpdateWithoutProposalCollaborationInput, ProposalOfferUncheckedUpdateWithoutProposalCollaborationInput>
    create: XOR<ProposalOfferCreateWithoutProposalCollaborationInput, ProposalOfferUncheckedCreateWithoutProposalCollaborationInput>
    where?: ProposalOfferWhereInput
  }

  export type ProposalOfferUpdateToOneWithWhereWithoutProposalCollaborationInput = {
    where?: ProposalOfferWhereInput
    data: XOR<ProposalOfferUpdateWithoutProposalCollaborationInput, ProposalOfferUncheckedUpdateWithoutProposalCollaborationInput>
  }

  export type ProposalOfferUpdateWithoutProposalCollaborationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutOffersNestedInput
    agency?: AgencyUpdateOneRequiredWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateWithoutProposalCollaborationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementCreateNestedManyWithoutClientInput
    Proposal?: ProposalCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    receiveCompanyEmail?: boolean | null
    receiveCompanySMS?: boolean | null
    receiveAgentEmail?: boolean | null
    receiveAgentSMS?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedCreateNestedManyWithoutClientInput
    favorites?: PropertyFavoriteUncheckedCreateNestedManyWithoutClientInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutClientInput
    clientSearches?: ClientSearchUncheckedCreateNestedManyWithoutClientInput
    reviews?: AgencyReviewUncheckedCreateNestedManyWithoutClientInput
    AgencyView?: AgencyViewUncheckedCreateNestedManyWithoutClientInput
    PropertyEngagement?: PropertyEngagementUncheckedCreateNestedManyWithoutClientInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutClientInput
    ProposalCollaboration?: ProposalCollaborationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutUsersInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyOwner?: UserCreateNestedOneWithoutOwnedAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUsersInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUsersInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureRequestCreateWithoutUserInput = {
    id?: string
    featureName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserFeatureRequestUncheckedCreateWithoutUserInput = {
    id?: string
    featureName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserFeatureRequestCreateOrConnectWithoutUserInput = {
    where: UserFeatureRequestWhereUniqueInput
    create: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureRequestCreateManyUserInputEnvelope = {
    data: UserFeatureRequestCreateManyUserInput | UserFeatureRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgencyMemberCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    agency?: AgencyCreateNestedOneWithoutAgencyMembersInput
    createdProperties?: PropertyCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberUncheckedCreateWithoutUserInput = {
    id?: string
    agencyId?: string | null
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    createdProperties?: PropertyUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClientNotes?: AgencyClientNotesUncheckedCreateNestedManyWithoutCreatedByMemberInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutCreatedByInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedCreateNestedManyWithoutCreatedByInput
    reminders?: AgentReminderUncheckedCreateNestedManyWithoutAgencyMemberInput
  }

  export type AgencyMemberCreateOrConnectWithoutUserInput = {
    where: AgencyMemberWhereUniqueInput
    create: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
  }

  export type AgencyCreateWithoutAgencyOwnerInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewCreateNestedManyWithoutAgencyInput
    properties?: PropertyCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAgencyOwnerInput = {
    id?: string
    status?: $Enums.AgencyApprovalStatus
    imotkoApproved?: boolean
    plan?: $Enums.AgencyPlan
    planUntil?: Date | string | null
    email?: string | null
    taxNumber?: string | null
    name: string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: string | null
    address: string
    phone?: string | null
    location?: string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: number
    owner: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    ratings?: AgencyReviewUncheckedCreateNestedManyWithoutAgencyInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAgencyInput
    propertySale?: PropertySaleUncheckedCreateNestedManyWithoutAgencyInput
    agencyView?: AgencyViewUncheckedCreateNestedManyWithoutAgencyInput
    proposalOffer?: ProposalOfferUncheckedCreateNestedManyWithoutAgencyInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedCreateNestedOneWithoutAgencyInput
    agencyMembers?: AgencyMemberUncheckedCreateNestedManyWithoutAgencyInput
    agencyInvitation?: AgencyInvitationUncheckedCreateNestedManyWithoutAgencyInput
    agencyClient?: AgencyClientUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAgencyOwnerInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
  }

  export type AgencyInvitationCreateWithoutSenderInput = {
    id?: string
    token: string
    email: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutAgencyInvitationInput
  }

  export type AgencyInvitationUncheckedCreateWithoutSenderInput = {
    id?: string
    token: string
    agencyId: string
    email: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyInvitationCreateOrConnectWithoutSenderInput = {
    where: AgencyInvitationWhereUniqueInput
    create: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput>
  }

  export type AgencyInvitationCreateManySenderInputEnvelope = {
    data: AgencyInvitationCreateManySenderInput | AgencyInvitationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutUserInput = {
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiveCompanyEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveCompanySMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveAgentSMS?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    clientSubscription?: ClientPropertySubscriptionUncheckedUpdateManyWithoutClientNestedInput
    favorites?: PropertyFavoriteUncheckedUpdateManyWithoutClientNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutClientNestedInput
    clientSearches?: ClientSearchUncheckedUpdateManyWithoutClientNestedInput
    reviews?: AgencyReviewUncheckedUpdateManyWithoutClientNestedInput
    AgencyView?: AgencyViewUncheckedUpdateManyWithoutClientNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutClientNestedInput
    Proposal?: ProposalUncheckedUpdateManyWithoutClientNestedInput
    ProposalCollaboration?: ProposalCollaborationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    description?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
  }

  export type AgencyUpsertWithoutUsersInput = {
    update: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUsersInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type AgencyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyOwner?: UserUpdateOneWithoutOwnedAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFeatureRequestWhereUniqueInput
    update: XOR<UserFeatureRequestUpdateWithoutUserInput, UserFeatureRequestUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeatureRequestCreateWithoutUserInput, UserFeatureRequestUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFeatureRequestWhereUniqueInput
    data: XOR<UserFeatureRequestUpdateWithoutUserInput, UserFeatureRequestUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureRequestUpdateManyWithWhereWithoutUserInput = {
    where: UserFeatureRequestScalarWhereInput
    data: XOR<UserFeatureRequestUpdateManyMutationInput, UserFeatureRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFeatureRequestScalarWhereInput = {
    AND?: UserFeatureRequestScalarWhereInput | UserFeatureRequestScalarWhereInput[]
    OR?: UserFeatureRequestScalarWhereInput[]
    NOT?: UserFeatureRequestScalarWhereInput | UserFeatureRequestScalarWhereInput[]
    id?: StringFilter<"UserFeatureRequest"> | string
    featureName?: StringFilter<"UserFeatureRequest"> | string
    userId?: StringNullableFilter<"UserFeatureRequest"> | string | null
    createdAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserFeatureRequest"> | Date | string | null
  }

  export type AgencyMemberUpsertWithoutUserInput = {
    update: XOR<AgencyMemberUpdateWithoutUserInput, AgencyMemberUncheckedUpdateWithoutUserInput>
    create: XOR<AgencyMemberCreateWithoutUserInput, AgencyMemberUncheckedCreateWithoutUserInput>
    where?: AgencyMemberWhereInput
  }

  export type AgencyMemberUpdateToOneWithWhereWithoutUserInput = {
    where?: AgencyMemberWhereInput
    data: XOR<AgencyMemberUpdateWithoutUserInput, AgencyMemberUncheckedUpdateWithoutUserInput>
  }

  export type AgencyMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agency?: AgencyUpdateOneWithoutAgencyMembersNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyUpsertWithoutAgencyOwnerInput = {
    update: XOR<AgencyUpdateWithoutAgencyOwnerInput, AgencyUncheckedUpdateWithoutAgencyOwnerInput>
    create: XOR<AgencyCreateWithoutAgencyOwnerInput, AgencyUncheckedCreateWithoutAgencyOwnerInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAgencyOwnerInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAgencyOwnerInput, AgencyUncheckedUpdateWithoutAgencyOwnerInput>
  }

  export type AgencyUpdateWithoutAgencyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAgencyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyApprovalStatusFieldUpdateOperationsInput | $Enums.AgencyApprovalStatus
    imotkoApproved?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumAgencyPlanFieldUpdateOperationsInput | $Enums.AgencyPlan
    planUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableJsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    social?: NullableJsonNullValueInput | InputJsonValue
    logo?: NullableJsonNullValueInput | InputJsonValue
    credits?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    ratings?: AgencyReviewUncheckedUpdateManyWithoutAgencyNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAgencyNestedInput
    propertySale?: PropertySaleUncheckedUpdateManyWithoutAgencyNestedInput
    agencyView?: AgencyViewUncheckedUpdateManyWithoutAgencyNestedInput
    proposalOffer?: ProposalOfferUncheckedUpdateManyWithoutAgencyNestedInput
    AgencySubmissionReview?: AgencySubmissionReviewUncheckedUpdateOneWithoutAgencyNestedInput
    agencyMembers?: AgencyMemberUncheckedUpdateManyWithoutAgencyNestedInput
    agencyInvitation?: AgencyInvitationUncheckedUpdateManyWithoutAgencyNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyInvitationUpsertWithWhereUniqueWithoutSenderInput = {
    where: AgencyInvitationWhereUniqueInput
    update: XOR<AgencyInvitationUpdateWithoutSenderInput, AgencyInvitationUncheckedUpdateWithoutSenderInput>
    create: XOR<AgencyInvitationCreateWithoutSenderInput, AgencyInvitationUncheckedCreateWithoutSenderInput>
  }

  export type AgencyInvitationUpdateWithWhereUniqueWithoutSenderInput = {
    where: AgencyInvitationWhereUniqueInput
    data: XOR<AgencyInvitationUpdateWithoutSenderInput, AgencyInvitationUncheckedUpdateWithoutSenderInput>
  }

  export type AgencyInvitationUpdateManyWithWhereWithoutSenderInput = {
    where: AgencyInvitationScalarWhereInput
    data: XOR<AgencyInvitationUpdateManyMutationInput, AgencyInvitationUncheckedUpdateManyWithoutSenderInput>
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    UserFeatureRequest?: UserFeatureRequestUncheckedCreateNestedManyWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutUserFeatureRequestInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    agency?: AgencyCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    agencyMember?: AgencyMemberCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutUserFeatureRequestInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    agencyId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    agencyMember?: AgencyMemberUncheckedCreateNestedOneWithoutUserInput
    ownedAgency?: AgencyUncheckedCreateNestedOneWithoutAgencyOwnerInput
    agencyInvitationSender?: AgencyInvitationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutUserFeatureRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFeatureRequestInput, UserUncheckedCreateWithoutUserFeatureRequestInput>
  }

  export type UserUpsertWithoutUserFeatureRequestInput = {
    update: XOR<UserUpdateWithoutUserFeatureRequestInput, UserUncheckedUpdateWithoutUserFeatureRequestInput>
    create: XOR<UserCreateWithoutUserFeatureRequestInput, UserUncheckedCreateWithoutUserFeatureRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFeatureRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFeatureRequestInput, UserUncheckedUpdateWithoutUserFeatureRequestInput>
  }

  export type UserUpdateWithoutUserFeatureRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFeatureRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email: string
    location?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    phone?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    language?: $Enums.UserLanguage | null
    role?: $Enums.UserRole
    clientId?: string | null
    adminId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgencyReviewCreateManyAgencyInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
  }

  export type PropertyCreateManyAgencyInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertySaleCreateManyAgencyInput = {
    id?: string
    propertyId: string
    propertyDeed: string
    soldAt?: Date | string
    soldFor: number
    visibility?: boolean
  }

  export type AgencyViewCreateManyAgencyInput = {
    id?: string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalOfferCreateManyAgencyInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    proposalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyMemberCreateManyAgencyInput = {
    id?: string
    userId: string
    status?: $Enums.AgencyMemberStatus | null
    role?: $Enums.AgencyMemberRole
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgencyInvitationCreateManyAgencyInput = {
    id?: string
    token: string
    email: string
    senderId: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientCreateManyAgencyInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    UserFeatureRequest?: UserFeatureRequestUncheckedUpdateManyWithoutUserNestedInput
    agencyMember?: AgencyMemberUncheckedUpdateOneWithoutUserNestedInput
    ownedAgency?: AgencyUncheckedUpdateOneWithoutAgencyOwnerNestedInput
    agencyInvitationSender?: AgencyInvitationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableEnumUserLanguageFieldUpdateOperationsInput | $Enums.UserLanguage | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyReviewUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type AgencyReviewUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencyReviewUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertySaleUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
    property?: PropertyUpdateOneRequiredWithoutPropertySaleNestedInput
  }

  export type PropertySaleUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertySaleUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    propertyDeed?: StringFieldUpdateOperationsInput | string
    soldAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldFor?: IntFieldUpdateOperationsInput | number
    visibility?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgencyViewUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutAgencyViewNestedInput
  }

  export type AgencyViewUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyViewUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalOfferUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutOffersNestedInput
    proposalCollaboration?: ProposalCollaborationUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyMemberUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgencyMemberNestedInput
    createdProperties?: PropertyUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdProperties?: PropertyUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClientNotes?: AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberNestedInput
    agencyClient?: AgencyClientUncheckedUpdateManyWithoutCreatedByNestedInput
    AgencyClientPreference?: AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByNestedInput
    reminders?: AgentReminderUncheckedUpdateManyWithoutAgencyMemberNestedInput
  }

  export type AgencyMemberUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumAgencyMemberStatusFieldUpdateOperationsInput | $Enums.AgencyMemberStatus | null
    role?: EnumAgencyMemberRoleFieldUpdateOperationsInput | $Enums.AgencyMemberRole
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyInvitationUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutAgencyInvitationSenderNestedInput
  }

  export type AgencyInvitationUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyInvitationUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesCreateManyAgencyClientInput = {
    id?: string
    title: string
    description: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientPreferenceCreateManyAgencyClientInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    createdById?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type PropertyCreateManyOwnerInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertyCreateManyRenterInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type AgencyClientNotesUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByMember?: AgencyMemberUpdateOneRequiredWithoutAgencyClientNotesNestedInput
  }

  export type AgencyClientNotesUncheckedUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientPreferenceUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: AgencyMemberUpdateOneWithoutAgencyClientPreferenceNestedInput
  }

  export type AgencyClientPreferenceUncheckedUpdateWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUpdateWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateManyCreatedByMemberInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type AgencyClientNotesCreateManyCreatedByMemberInput = {
    id?: string
    title: string
    description: string
    agencyClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientCreateManyCreatedByInput = {
    id?: string
    name: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.AgencyClientStatus | null
    location?: string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyClientPreferenceCreateManyCreatedByInput = {
    id?: string
    propertyType?: $Enums.PropertyType | null
    listingType?: $Enums.PropertyListingType | null
    minPrice?: number | null
    maxPrice?: number | null
    minSize?: number | null
    maxSize?: number | null
    categoryId?: string | null
    subcategoryId?: string | null
    locationId?: string | null
    location?: string | null
    agencyClientId?: string | null
    offeredPropertyIds?: AgencyClientPreferenceCreateofferedPropertyIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: Date | string | null
  }

  export type AgentReminderCreateManyAgencyMemberInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ReminderStatus
    startDate: Date | string
    isRecurring?: boolean
    endDate?: Date | string | null
    lastSentAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyClientNotesUpdateWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyClient?: AgencyClientUpdateOneRequiredWithoutMemberNotesNestedInput
  }

  export type AgencyClientNotesUncheckedUpdateWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    agencyClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientNotesUncheckedUpdateManyWithoutCreatedByMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    agencyClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUpdateManyWithoutAgencyClientNestedInput
    agency?: AgencyUpdateOneRequiredWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberNotes?: AgencyClientNotesUncheckedUpdateManyWithoutAgencyClientNestedInput
    preferences?: AgencyClientPreferenceUncheckedUpdateManyWithoutAgencyClientNestedInput
    ownedProperties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    rentedProperties?: PropertyUncheckedUpdateManyWithoutRenterNestedInput
  }

  export type AgencyClientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumAgencyClientStatusFieldUpdateOperationsInput | $Enums.AgencyClientStatus | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyClientPreferenceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyClient?: AgencyClientUpdateOneWithoutPreferencesNestedInput
  }

  export type AgencyClientPreferenceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyClientId?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyClientPreferenceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    agencyClientId?: NullableStringFieldUpdateOperationsInput | string | null
    offeredPropertyIds?: AgencyClientPreferenceUpdateofferedPropertyIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgencyClientPreferenceStatusFieldUpdateOperationsInput | $Enums.AgencyClientPreferenceStatus
    lastOfferSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentReminderUpdateWithoutAgencyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentReminderUncheckedUpdateWithoutAgencyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentReminderUncheckedUpdateManyWithoutAgencyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientPropertySubscriptionCreateManyClientInput = {
    id?: string
    minSize?: number | null
    maxSize?: number | null
    minPrice?: number | null
    maxPrice?: number | null
    location?: string | null
    listingType?: $Enums.PropertyListingType | null
    category: string
    subCategory?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientSearchId?: string | null
  }

  export type PropertyFavoriteCreateManyClientInput = {
    id?: string
    favoriteDate: Date | string
    propertyId?: string | null
  }

  export type PropertyViewCreateManyClientInput = {
    id?: string
    viewDate?: Date | string
    propertyId: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSearchCreateManyClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: JsonNullValueInput | InputJsonValue
    link: string
    filters: JsonNullValueInput | InputJsonValue
    receiveOffers?: boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgencyReviewCreateManyClientInput = {
    id?: string
    approved?: boolean
    rating: number
    comment?: string | null
    createdAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId: string
  }

  export type AgencyViewCreateManyClientInput = {
    id?: string
    agencyId: string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyEngagementCreateManyClientInput = {
    id?: string
    propertyId: string
    type: $Enums.EngagementType
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProposalCreateManyClientInput = {
    id?: string
    title: string
    description: string
    location: string
    size?: number | null
    category: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    status?: $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCollaborationCreateManyClientInput = {
    id?: string
    title: string
    description: string
    email: string
    phone?: string | null
    agencyId: string
    proposalOfferId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientPropertySubscriptionUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientSearch?: ClientSearchUpdateOneWithoutClientPropertySubscriptionNestedInput
  }

  export type ClientPropertySubscriptionUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientSearchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientPropertySubscriptionUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    minSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxSize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    listingType?: NullableEnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType | null
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientSearchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFavoriteUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutPropertyFavoriteNestedInput
  }

  export type PropertyFavoriteUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFavoriteUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyViewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSearchUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionUpdateOneWithoutClientSearchNestedInput
  }

  export type ClientSearchUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
    clientPropertySubscription?: ClientPropertySubscriptionUncheckedUpdateOneWithoutClientSearchNestedInput
  }

  export type ClientSearchUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: JsonNullValueInput | InputJsonValue
    link?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    receiveOffers?: BoolFieldUpdateOperationsInput | boolean
    agencyIdsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgencyReviewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agency?: AgencyUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type AgencyReviewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencyReviewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencyViewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyViewNestedInput
  }

  export type AgencyViewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyViewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyEngagementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    property?: PropertyUpdateOneRequiredWithoutPropertyEngagementNestedInput
  }

  export type PropertyEngagementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProposalUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: ProposalOfferUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: ProposalOfferUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    photos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCollaborationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalOffer?: ProposalOfferUpdateOneWithoutProposalCollaborationNestedInput
  }

  export type ProposalCollaborationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    proposalOfferId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCollaborationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    proposalOfferId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateManyPropertyInput = {
    id?: string
    viewDate?: Date | string
    clientId?: string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyFavoriteCreateManyPropertyInput = {
    id?: string
    favoriteDate: Date | string
    clientId?: string | null
  }

  export type PropertyEngagementCreateManyPropertyInput = {
    id?: string
    type: $Enums.EngagementType
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertySubmissionReviewCreateManyPropertyInput = {
    id?: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutPropertyViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFavoriteUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutFavoritesNestedInput
  }

  export type PropertyFavoriteUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFavoriteUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoriteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyEngagementUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientUpdateOneWithoutPropertyEngagementNestedInput
  }

  export type PropertyEngagementUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyEngagementUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertySubmissionReviewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionReviewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyCategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertySubcategoryCreateManyCategoryInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertySubcategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutSubcategoryNestedInput
  }

  export type PropertySubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type PropertySubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManySubcategoryInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    propertyLocationId?: string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    propertyLocation?: PropertyLocationUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    propertyLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyLocationCreateManyParentInput = {
    id?: string
    name: string
  }

  export type PropertyCreateManyPropertyLocationInput = {
    id?: string
    name: JsonNullValueInput | InputJsonValue
    latitude: number
    address: string
    longitude: number
    agencyId?: string | null
    status?: $Enums.PropertyStatus
    price: number
    hasApproximatePrice?: boolean | null
    approximatePrice?: number | null
    estimationPrice?: number | null
    size: number
    description: JsonNullValueInput | InputJsonValue
    slug?: string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByMemberId?: string | null
    updatedAt?: Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: Date | string | null
    remarks?: string | null
    builder?: string | null
    propertyCadastralMunicipality?: string | null
    propertyDeed?: string | null
    inDevelopment?: boolean | null
    inDevelopmentUntil?: Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: boolean
    featuredUntil?: Date | string | null
    orientation?: $Enums.PropertyOrientation | null
    type: $Enums.PropertyType
    listingType: $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: string | null
    subcategoryId?: string | null
    ownerId?: string | null
    renterId?: string | null
    externalId?: string | null
    autoRenewEnabled?: boolean
    autoRenewStartDate?: Date | string | null
    autoRenewEndDate?: Date | string | null
    lastAutoRenewedAt?: Date | string | null
    bumpedAt?: Date | string | null
  }

  export type PropertyLocationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    children?: PropertyLocationUpdateManyWithoutParentNestedInput
    properties?: PropertyUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    children?: PropertyLocationUncheckedUpdateManyWithoutParentNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyLocationNestedInput
  }

  export type PropertyLocationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyUpdateWithoutPropertyLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByMember?: AgencyMemberUpdateOneWithoutCreatedPropertiesNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    agency?: AgencyUpdateOneWithoutPropertiesNestedInput
    PropertyFavorite?: PropertyFavoriteUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUpdateManyWithoutPropertyNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    subcategory?: PropertySubcategoryUpdateOneWithoutPropertiesNestedInput
    owner?: AgencyClientUpdateOneWithoutOwnedPropertiesNestedInput
    renter?: AgencyClientUpdateOneWithoutRentedPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyFavorite?: PropertyFavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    PropertySale?: PropertySaleUncheckedUpdateOneWithoutPropertyNestedInput
    PropertyEngagement?: PropertyEngagementUncheckedUpdateManyWithoutPropertyNestedInput
    propertyReview?: PropertySubmissionReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: JsonNullValueInput | InputJsonValue
    latitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    price?: IntFieldUpdateOperationsInput | number
    hasApproximatePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approximatePrice?: NullableIntFieldUpdateOperationsInput | number | null
    estimationPrice?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    video?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: NullableJsonNullValueInput | InputJsonValue
    yearBuilt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    builder?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCadastralMunicipality?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDeed?: NullableStringFieldUpdateOperationsInput | string | null
    inDevelopment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inDevelopmentUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyPlan?: NullableJsonNullValueInput | InputJsonValue
    poi?: NullableJsonNullValueInput | InputJsonValue
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orientation?: NullableEnumPropertyOrientationFieldUpdateOperationsInput | $Enums.PropertyOrientation | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listingType?: EnumPropertyListingTypeFieldUpdateOperationsInput | $Enums.PropertyListingType
    modifications?: NullableJsonNullValueInput | InputJsonValue
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    renterId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenewEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRenewStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAutoRenewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bumpedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProposalOfferCreateManyProposalInput = {
    id?: string
    title: string
    price: number
    description: string
    saleTimeline: Date | string
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalOfferUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutProposalOfferNestedInput
    proposalCollaboration?: ProposalCollaborationUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalCollaboration?: ProposalCollaborationUncheckedUpdateOneWithoutProposalOfferNestedInput
  }

  export type ProposalOfferUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    saleTimeline?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.NotificationStatus
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserFeatureRequestCreateManyUserInput = {
    id?: string
    featureName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AgencyInvitationCreateManySenderInput = {
    id?: string
    token: string
    agencyId: string
    email: string
    status?: $Enums.AgencyInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserFeatureRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeatureRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeatureRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyInvitationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutAgencyInvitationNestedInput
  }

  export type AgencyInvitationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyInvitationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumAgencyInvitationStatusFieldUpdateOperationsInput | $Enums.AgencyInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}